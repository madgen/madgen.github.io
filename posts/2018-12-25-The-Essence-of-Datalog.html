<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | The Essence of Datalog</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on December 25, 2018
  
  
    and last updated on December  7, 2019
  
  by Mistral Contrastin
</div>

<h1>The Essence of Datalog</h1>


<p class="in-which">In which we implement a simple Datalog engine in not many lines of Haskell to understand its semantics.</p>


<div class="post"><p>Datalog is arguably the simplest logic programming language there is. Depending
on your background, you can see it as a principled SQL or a Prolog with manners.
It has recently become popular among the scalable program analysis crowd.
Semantically, it is simple and clean, so it doesn’t take many lines of Haskell
to produce an (inefficient) implementation. I’ll follow Richard Feynman’s maxim:
“What I cannot create, I do not understand.” Hopefully, this post should give
you some feel for logic and relational programming and also demonstrate that
λ-calculus is not the only language you can implement with ease in Haskell.</p>
<p>We start by looking at a simple program and implement an evaluator for it.
Along with the implementation, we give a lightweight discussion of semantic
concerns, in particular about its termination. Later, we try quenching the
thirst for efficiency a little by giving some avenues for optimisation and
conclude with where to go next for those interested. There is a copy of the full
implementation at the end of the post.</p>
<p>I want this post to be accessible to everyone, not only to the programming
language people. For that reason, all uses of theory terms are auxiliary. If you
feel that’s not the case at any point, give me a shout on Twitter or email me
(both available in <a href="https://dodisturb.me">my homepage</a>) and I’ll fix it.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Dominic Orchard for pointing out that he did not advise Andrew Rice.
Also thanks to Daniel Kröni for providing a less restrictive <code>isRangeRestricted</code>
implementation and to Gilbert G for pointing out a broken link.</p>
<h2 id="a-crash-course-in-logic-programming">A crash course in logic programming</h2>
<p>The litmus test for any logic programming language is to be able to compute a
variation of the following ancestry program.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Andrew Rice</span><span class="ot">&quot;</span><span class="kw">,</span>     <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Andy Hopper</span><span class="ot">&quot;</span><span class="kw">,</span>     <span class="ot">&quot;</span><span class="er">Andrew Rice</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Alan Mycroft</span><span class="ot">&quot;</span><span class="kw">,</span>    <span class="ot">&quot;</span><span class="er">Dominic Orchard</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">David Wheeler</span><span class="ot">&quot;</span><span class="kw">,</span>   <span class="ot">&quot;</span><span class="er">Andy Hopper</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Rod Burstall</span><span class="ot">&quot;</span><span class="kw">,</span>    <span class="ot">&quot;</span><span class="er">Alan Mycroft</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Robin Milner</span><span class="ot">&quot;</span><span class="kw">,</span>    <span class="ot">&quot;</span><span class="er">Alan Mycroft</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>academicAncestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>) <span class="kw">:-</span> adviser(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>academicAncestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>) <span class="kw">:-</span> adviser(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> academicAncestor(<span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<p>This program encodes some facts about my academic genealogy encoded in the
<code>adviser</code> relation and has some basic rules that define what it means to be an
<code>academicAncestor</code>. The facts effectively constitute a database table. Rules
allow us to deduce new knowledge. The first rule says that an adviser is an
ancestor. The second says the adviser of a known ancestor is also an ancestor.
This ability to use recursion to specify relationships in data was one of the
original selling points of Datalog.</p>
<p>We want to query the data that is represented explicitly and implicitly. Here
are some example queries:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> academicAncestor(<span class="ot">&quot;</span><span class="er">Robin Milner</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="dt">Intermediate</span>)<span class="kw">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>   academicAncestor(<span class="dt">Intermediate</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> academicAncestor(<span class="ot">&quot;</span><span class="er">Alan Turing</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> academicAncestor(<span class="ot">&quot;</span><span class="er">David Wheeler</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span></code></pre></div>
<p>The first one says “is there an academic ancestorial connection between Robin
Milner and I and if so who?”. The second one says “is Alan Turing my academic
ancestor?” and the third one is the same question but for David Wheeler.</p>
<p>Another appeal of Datalog can be seen in these queries. Datalog is mostly
relations (hence the name relational programming). This means there are no
inherent inputs and outputs. That’s why we can fill in or leave out either
parameter of <code>academicAncestor</code>. You leave a variable in place of the knowledge
you want to know and the system fills it for you. This also means you can write
a program for a particular input and output relationship in mind and you get the
opposite program for free.</p>
<h2 id="evaluating-a-datalog">Evaluating a Datalog</h2>
<p>Datalog is similar to λ-calculus in the sense that there are as many
variants of both as there are sands in a beach.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The variation we
are going to implement today is the simplest one there is. The bits and pieces
you see in the previous section are all you get.</p>
<p>We’ll implement the engine the way we evaluate Datalog programs: <em>initially, one
rule at a time, then all at once</em>. Since Datalog is deeply rooted in database
theory, it is usually implemented as relational algebra concepts such as joins
and selections. I have a programming language background, so I’ll use
substitutions instead. This will be entirely equivalent, but also lead to
simpler code.</p>
<h3 id="representing-datalog">Representing Datalog</h3>
<p>A rule consists of a head and a body. A head is an atom and so are the comma
separated items in the body. An atom then consists of a predicate name like
<code>adviser</code> and a list of terms. We have two kinds of terms: variables and
symbols. This corresponds to few simple datatype declarations.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rule</span> <span class="ot">=</span> <span class="dt">Rule</span> {<span class="ot"> _head ::</span> <span class="dt">Atom</span>,<span class="ot"> _body ::</span> [ <span class="dt">Atom</span> ] }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Atom</span> <span class="ot">=</span> <span class="dt">Atom</span> {<span class="ot"> _predSym ::</span> <span class="dt">String</span>,<span class="ot"> _terms ::</span> [ <span class="dt">Term</span> ] } <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Sym</span> <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Eq</span></span></code></pre></div>
<p>The following rule</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>academicAncestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>) <span class="kw">:-</span> adviser(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> academicAncestor(<span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<p>corresponds to</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span>          [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ] ]</span></code></pre></div>
<p>Facts are just bodiless rules. For example,</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>adviser(<span class="ot">&quot;</span><span class="er">Andrew Rice</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span></code></pre></div>
<p>corresponds to</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span> [ <span class="dt">Sym</span> <span class="st">&quot;Andrew Rice&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ]) []</span></code></pre></div>
<p>You might be thinking but what about the queries, the <code>Rule</code> datatype doesn’t
allow headless bodies. That’s true, but the dirty secret about queries is that
they get rewritten as rules with the head atom generated from the query. The
predicate symbol for each query is fresh and the terms of the head are just the
variables in the body. For example,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> academicAncestor(<span class="ot">&quot;</span><span class="er">Robin Milner</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="dt">Intermediate</span>)<span class="kw">,</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>   academicAncestor(<span class="dt">Intermediate</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span></code></pre></div>
<p>gets fresh head atom <code>query1(Intermediate)</code> and can be thought of as</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>query1(<span class="dt">Intermediate</span>) <span class="kw">:-</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  academicAncestor(<span class="ot">&quot;</span><span class="er">Robin Milner</span><span class="ot">&quot;</span><span class="kw">,</span> <span class="dt">Intermediate</span>)<span class="kw">,</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  academicAncestor(<span class="dt">Intermediate</span><span class="kw">,</span> <span class="ot">&quot;</span><span class="er">Mistral Contrastin</span><span class="ot">&quot;</span>)<span class="kw">.</span></span></code></pre></div>
<p>An entire Datalog program is nothing but a collection of rules.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Program</span> <span class="ot">=</span> [ <span class="dt">Rule</span> ]</span></code></pre></div>
<p>We also need a way of representing the known facts about the universe. We can
call this our <em>knowledge base</em>. For simplicity, we use a horribly inefficient
list of atoms.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">KnowledgeBase</span> <span class="ot">=</span> [ <span class="dt">Atom</span> ]</span></code></pre></div>
<p>Since we’ll use substitutions to evaluate atoms, we can define that here too.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Substitution</span> <span class="ot">=</span> [ (<span class="dt">Term</span>, <span class="dt">Term</span>) ]</span></code></pre></div>
<p>Our substitutions are simpler than those that are used in λ-calculus. A Haskell
tuple <code>(x,c)</code> represents the substitution <code>[c/x]</code> meaning we replace <code>c</code> for
<code>x</code>. Here, <code>x</code> is always a variable and <code>c</code> is always a constant (symbol). The
variable restriction is usual; it is just not reflected in the type. The
constant restriction, however, is not. Datalog doesn’t have function symbols and
substituting a variable is not necessary for its evaluation. Like the variable
restriction, the constant restriction is also not reflected in the type.</p>
<p>Applying a substitution to an atom or a variable (potentially) makes it <em>ground</em>
that is it replaces the variable with a constant.</p>
<p>We can also define the only constant that will be used in the evaluator: the
empty substitution.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">emptySubstitution ::</span> <span class="dt">Substitution</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>emptySubstitution <span class="ot">=</span> []</span></code></pre></div>
<p>Mind-blowing, I know.</p>
<h3 id="one-rule-at-a-time">One rule at a time</h3>
<p>Let’s focus on evaluating a single rule from our example program.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>academicAncestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>) <span class="kw">:-</span> adviser(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> academicAncestor(<span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<p>We know some facts about the world and using this rule, we want to know some
more. There are two ways. One is to gather everything we know about
<code>adviser</code> and <code>academicAncestor</code> separately and <em>join</em> them together making
sure the second parameter (<code>Y</code>) of <code>adviser</code> matches the first parameter (<code>Y</code>)
of <code>academicAncestor</code>. Another way is to look at any one of the atoms and
find assignments to its variables and substitute them in the other atom, only
then we look for assignments to the remaining variables of this second atom.
This approach would work for the example above as follows: find possible
assignments to <code>X</code> and <code>Y</code> through <code>adviser</code>, substitute the values of <code>Y</code> in
<code>academicAncestor</code>, and finally look for values of <code>academicAncestor</code> in the
knowledge base that agree on the newly substituted value of <code>Y</code> to obtain values
for <code>Z</code>.</p>
<p>In the context of databases, the first is called <em>join-before-select</em> and the
second, not so surprisingly, <em>select-before-join</em>. We’ll implement the
latter because it is simpler.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>Since we need unification to obtain substitutions from facts &amp; body atoms and
substitution to ground further atoms. We start by implementing those.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">substitute ::</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Substitution</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>substitute atom substitution <span class="ot">=</span> atom { _terms <span class="ot">=</span> <span class="fu">map</span> go (_terms atom) }</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  go sym<span class="op">@</span><span class="dt">Sym</span>{} <span class="ot">=</span> sym</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  go var<span class="op">@</span><span class="dt">Var</span>{} <span class="ot">=</span> fromMaybe var (var <span class="ot">`lookup`</span> substitution)</span></code></pre></div>
<p>Substitution is pretty much what you would expect looking up what to substitute
for variables and do it whenever it can find a binding otherwise leaving the
variable alone.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unify ::</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>unify (<span class="dt">Atom</span> predSym ts) (<span class="dt">Atom</span> predSym' ts')</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> predSym <span class="op">==</span> predSym' <span class="ot">=</span> go <span class="op">$</span> <span class="fu">zip</span> ts ts'</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> [ (<span class="dt">Term</span>, <span class="dt">Term</span>) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  go []                           <span class="ot">=</span> <span class="dt">Just</span> emptySubstitution</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  go ((s<span class="op">@</span><span class="dt">Sym</span>{}, s'<span class="op">@</span><span class="dt">Sym</span>{}) <span class="op">:</span> rest) <span class="ot">=</span> <span class="kw">if</span> s <span class="op">==</span> s' <span class="kw">then</span> go rest <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  go ((v<span class="op">@</span><span class="dt">Var</span>{}, s<span class="op">@</span><span class="dt">Sym</span>{})  <span class="op">:</span> rest) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    incompleteSubstitution <span class="ot">&lt;-</span> go rest</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> v <span class="ot">`lookup`</span> incompleteSubstitution <span class="kw">of</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> s' <span class="op">|</span> s <span class="op">/=</span> s'   <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>      _                   <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> (v,s) <span class="op">:</span> incompleteSubstitution</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  go ((_, <span class="dt">Var</span>{}) <span class="op">:</span> _) <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;The second atom is assumed to be ground.&quot;</span></span></code></pre></div>
<p>Unification is also simple, in fact, too simple. For one thing, we cheat and
unify whenever we have two atoms that have the same predicate symbol. In
Datalog, a predicate is determined by its predicate symbol <em>and</em> arity
(the number of terms). Here, we assume each predicate symbol determines
the arity. More importantly, we throw an error when a term from the second
atom is a variable. The reason is unification only occurs between a body atom
and a fact. Since facts cannot have variables, this is safe. This is consistent
with our earlier assumptions about the form of substitutions.</p>
<p>We take special care of unification of atoms with repeated variables. It
requires failing in case of a contradictory variable assignment. Consider
unifying <code>p(X,X)</code> with <code>p("a","b")</code>.</p>
<p>Next we evaluate an atom into a list of substitutions by finding facts that fit
the template provided by a body atom and capturing the assignments to its
variables. Those assignments to variables are just the substitutions we are
looking for.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalAtom ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ] <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>evalAtom kb atom substitutions <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  substitution <span class="ot">&lt;-</span> substitutions</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> downToEarthAtom <span class="ot">=</span> substitute atom substitution</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  extension <span class="ot">&lt;-</span> mapMaybe (unify downToEarthAtom) kb</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> substitution <span class="op">&lt;&gt;</span> extension</span></code></pre></div>
<p>Here we do exactly what is described above but build the substitutions by
accumulation. This means we have substitutions that we use on the body atom to
ground its variables, but then unifying this more down to earth atom (it’s more
ground, get it?) with the facts we know gives us extensions to the substitution
we started with. Thus, we extend and accumulate substitutions.</p>
<p>Now all we need to do is to walk the body and accumulate substitutions, then
using these substitutions we deduce new facts based on the head of the rule.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">walk ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> [ <span class="dt">Atom</span> ] <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>walk kb <span class="ot">=</span> <span class="fu">foldr</span> (evalAtom kb) [ emptySubstitution ]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">evalRule ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>evalRule kb (<span class="dt">Rule</span> <span class="fu">head</span> body) <span class="ot">=</span> <span class="fu">map</span> (substitute <span class="fu">head</span>) (walk kb body)</span></code></pre></div>
<p>Here’s something to think about. We said the facts we deduce will be ground, but
<code>evalRule</code> does not check if the substitution has a binding for all the
variables that appear in the head. Does that mean we are potentially concluding
non-ground facts? Don’t worry if you’re not sure, we’ll come back to it
<a href="#range-restriction-and-domain-independence">below</a>.</p>
<h3 id="all-at-once">All at once</h3>
<p>All we need now is to evaluate all of the rules together. We’ll do one of the
simplest possible things. We’ll evaluate each rule independently and then
concatenate the newly derived facts together and bundle them with what we
already know. Then repeat the process until we can’t produce new facts any more.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">immediateConsequence ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>immediateConsequence rules kb <span class="ot">=</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  nub <span class="op">.</span> (kb <span class="op">&lt;&gt;</span>) <span class="op">.</span> <span class="fu">concatMap</span> (evalRule kb) <span class="op">$</span> rules</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>solve rules <span class="ot">=</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">all</span> isRangeRestricted rules</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> fix step []</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">error</span> <span class="st">&quot;The input program is not range-restricted.&quot;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  step ::</span> (<span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> (<span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  step f currentKB <span class="op">|</span> nextKB <span class="ot">&lt;-</span> immediateConsequence rules currentKB <span class="ot">=</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> nextKB <span class="op">==</span> currentKB</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> currentKB</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> f nextKB</span></code></pre></div>
<p>The <code>immediateConsequence</code> function does the bundling step and <code>solve</code> computes
the fixpoint from an empty set of facts.</p>
<p>The only thing left unexplained is the <code>isRangeRestricted</code> predicate which
ensures the program is well-formed.</p>
<h3 id="semantic-considerations">Semantic considerations</h3>
<p>Now that we have something that almost compiles we can talk about semantics.
Starting with the last missing piece: the range restriction predicate followed
by termination.</p>
<h4 id="range-restriction-and-domain-independence">Range restriction and domain independence</h4>
<p>In a rule, if every variable in the head appears somewhere in the body, we call
the rule range-restricted. We check if every rule is range-restricted before
evaluating them in <code>solve</code>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> This is why we didn’t
have to check if there were any variables left in the head after substitution in
<code>evalRule</code>. If we can get to the stage of substituting into head, we are
guaranteed to find values for each head variable.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isRangeRestricted ::</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>isRangeRestricted <span class="dt">Rule</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  vars _head <span class="ot">`isSubsetOf`</span> <span class="fu">concatMap</span> vars _body</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  isSubsetOf as bs <span class="ot">=</span> <span class="fu">all</span> (<span class="ot">`elem`</span> bs) as</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  vars <span class="dt">Atom</span>{<span class="op">..</span>} <span class="ot">=</span> nub <span class="op">$</span> <span class="fu">filter</span> (\<span class="kw">case</span> {<span class="dt">Var</span>{} <span class="ot">-&gt;</span> <span class="dt">True</span>; _ <span class="ot">-&gt;</span> <span class="dt">False</span>}) _terms</span></code></pre></div>
<p>There still remains the question of why we need range restriction at all? After
all, the ability to deduce generic facts seems useful. For example, stating
<code>p(X,X)</code> as a fact is a compact way of saying <code>p</code> is reflexive.</p>
<p>The problem is something called <em>domain independence</em>. It basically means if
the set of values a variable can take changes from one database to another (but
not the instance itself), queries still compute the same thing. In
other words, it prevents your program’s result to change under your feet if the
values in your database are the same. Since checking domain independence in
general is undecidable, range restriction is a safe syntactic approximation.</p>
<p>In this implementation what this means is if I change the definition of datatype
<code>Term</code> so that the symbols do not use <code>String</code> but instead a type for strings
up to length 10, if my initial ground facts were all strings of length up to 10,
then the results to all queries remain the same. We can’t guarantee the same
thing without domain independence.</p>
<p>Another problem is that when a query is posed with free variables, we expect
values to be filled for that variable. If we can deduce a generic fact such as
<code>p(X,X)</code>, then asking for the values of <code>X</code> would enumerate the set of infinite
strings.</p>
<p>Bear in mind, there are Datalog variants that lift this restriction. In fact, it
wouldn’t be too much work to implement it here. We just need a notion of
α-equivalence, a store that can handle non-ground values, and a unification
algorithm that handles variables.</p>
<h4 id="every-good-thing-must-come-to-an-end">Every good thing must come to an end</h4>
<p>Does this procedure terminate? Yes, it does. When? So long as you don’t have
infinite programs. It would be a cheeky thing to do though. One of the appeals
of Datalog is that it is not Turing-complete and every query to the system
terminates.</p>
<p>The termination argument is pretty simple. Immediate consequence function is
<em>monotone</em> that is the facts it produces encompasses the facts it starts with.
Further, the number of facts that can be produced is <em>bounded</em> if we start with
a finite database. Our initial set of facts used to kick-start <code>solve</code> is empty.
Hence, as long as our program is finite, we have finite number of
facts.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> As an upper bound, if we have <span class="math inline">\(N\)</span> constants
throughout the program, then for each relation of arity <span class="math inline">\(k\)</span>, we can have at most
<span class="math inline">\(N^k\)</span> facts. So the number of facts we can produce is also finite.</p>
<p>One place I’m being a bit loose is the monotone bit. What I said makes sense
with sets, but we’re working here with lists. Although <code>[1,2,3]</code> and <code>[2,1,3]</code>
encompass each other, they don’t compare equal using <code>==</code>. The reason this
implementation never gets in a cycle is because <code>nub</code> function called on the
amalgamation of facts in <code>immediateConsequence</code> preserves the first occurrence
of each element in the list. Since we prepend the already known facts before
calling <code>nub</code>, <code>==</code> behaves as if it is set equality.</p>
<p>If you want to sound smart explaining all of this and reduce the size of your
audience to a group of people who would understand this without you mentioning
anyway, you can just say the following. We have a non-empty finite lattice which
means it is complete and <a href="https://en.wikipedia.org/wiki/Knaster–Tarski_theorem">Knaster-Tarski
theorem</a> (which is a very
cool theorem ❤️) applied to the immediate consequence monotone function over this
complete lattice implies that it has a least fixpoint.</p>
<h2 id="quality-assurance">Quality assurance</h2>
<p>Time for the litmus test. We can now translate the ancestry program into
Haskell.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ancestor ::</span> <span class="dt">Program</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>ancestor <span class="ot">=</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Facts</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (\terms <span class="ot">-&gt;</span> <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span> terms) [])</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    [ [ <span class="dt">Sym</span> <span class="st">&quot;Andrew Rice&quot;</span>,     <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ]</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Dominic Orchard&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Andy Hopper&quot;</span>,     <span class="dt">Sym</span> <span class="st">&quot;Andrew Rice&quot;</span> ]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Dominic Orchard&quot;</span> ]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;David Wheeler&quot;</span>,   <span class="dt">Sym</span> <span class="st">&quot;Andy Hopper&quot;</span> ]</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Rod Burstall&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span> ]</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Robin Milner&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span> ]</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    ] <span class="op">&lt;&gt;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Actual rules</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ])</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ] ]</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ])</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span>          [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ]</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ] ]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>  ] <span class="op">&lt;&gt;</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Queries</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query1&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span> ])</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">fmap</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span>)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        [ [ <span class="dt">Sym</span> <span class="st">&quot;Robin Milner&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span> ]</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        , [ <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ])</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query2&quot;</span> [ ])</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>          [ <span class="dt">Sym</span> <span class="st">&quot;Alan Turing&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ]</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query3&quot;</span> [ ])</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>          [ <span class="dt">Sym</span> <span class="st">&quot;David Wheeler&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>We can make querying a bit more pleasant with a function that returns possible
bindings.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>query predSym pr <span class="ot">=</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> queryVarsL <span class="kw">of</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    [ queryVars ] <span class="ot">-&gt;</span> <span class="fu">zip</span> queryVars <span class="op">&lt;$&gt;</span> relevantKnowledgeBaseSyms</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;The query '&quot;</span> <span class="op">++</span> predSym <span class="op">++</span> <span class="st">&quot;' doesn't exist.&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;The query '&quot;</span> <span class="op">++</span> predSym <span class="op">++</span> <span class="st">&quot;' has multiple clauses.&quot;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  relevantKnowledgeBase <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">==</span> predSym) <span class="op">.</span> _predSym) <span class="op">$</span> solve pr</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  relevantKnowledgeBaseSyms <span class="ot">=</span> _terms <span class="op">&lt;$&gt;</span> relevantKnowledgeBase</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  queryRules <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">==</span> predSym) <span class="op">.</span> _predSym <span class="op">.</span> _head) pr</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  queryVarsL <span class="ot">=</span> _terms <span class="op">.</span> _head <span class="op">&lt;$&gt;</span> queryRules</span></code></pre></div>
<p>All it does it to run the program, find the named query and return the bindings
to its arguments. Let’s execute all three queries.</p>
<pre><code>&gt; query &quot;query1&quot; ancestor
[[(Intermediate,&quot;Dominic Orchard&quot;)],[(Intermediate,&quot;Alan Mycroft&quot;)]]
&gt; query &quot;query2&quot; ancestor
[]
&gt; query &quot;query3&quot; ancestor
[[]]</code></pre>
<p>The empty list of variable bindings, <code>[]</code>, mean there are no possible
assignments that satisfy the query, whereas the singleton empty binding, <code>[[]]</code>,
means the query is satisfied. It just didn’t have any variables that need to be
bound to values.</p>
<p>All three queries return the expected results. Dominic Orchard and Alan Mycroft
are between me and Robin Milner. I am not an academic descendant of Alan Turing,
but I am of David Wheeler.</p>
<p>Since these three queries run fine, we can safely conclude that the evaluator
here is bug-free.</p>
<h2 id="addressing-the-turtle-in-the-room">Addressing the turtle in the room</h2>
<p>As I mentioned before, this evaluator is inefficient. Discussing the reasons why
and what we can do to make it better is not only a software engineering
exercise, but also another way of highlighting why Datalog is a good language.
The optimisations I discuss here are quite major, but they are not a complete
list. There are many other optimisations that draw both from programming
languages and database theory literatures.</p>
<h3 id="optimise-for-the-query">Optimise for the query</h3>
<p>Basically, all I told you about Datalog semantics is incomplete. You’ll struggle
to find a resource that discusses Datalog evaluation the way I do because the
semantics are always defined with respect to a query. So what we really need is
a program query pair. What we compute here is much stronger and is also
unnecessary. For example, if the queries were interested only in the <code>adviser</code>
relation, computing <code>academicAncestors</code> would be a waste of time.</p>
<p>One way of dealing with this is to use a top-down evaluator which starts from
the query and uses <em>resolution</em> which is a proof technique. This allows only the
relevant facts to be derived. Most Prolog interpreters use a similar top-down
evaluation strategy. It is not preferred in Datalog for various reasons. One of
which is that the naïve implementation of it brings non-termination.</p>
<p>We can achieve the same in a bottom-up evaluator (like ours) using <em>magic set
transformation</em>. The very long story short, based on the input program, it
generates magic rules based on the dataflow of the program and inserts atoms
defined by these rules into the original rule bodies to restrict what can be
derived. Its effectiveness varies from program to program and there are
alternatives to it. If you want to learn more about it, you can look at <a href="https://www.sciencedirect.com/science/article/pii/074310669190038Q">On the
Power of
Magic</a> (you
must admit, it is a catchy title) by Beeri and Ramakrishnan.</p>
<h3 id="semi-naïve-evaluation">Semi-naïve evaluation</h3>
<p>While discussing <a href="#range-restriction">range restriction</a>, we mentioned that
this implementation rederives all the known facts in each iteration. This is
awful and is why it is called the naïve evaluation. There is also a modestly
named semi-naïve evaluation. It exploits a simple observation. In order to
derive a new fact from a rule, at least one new fact of the previous iteration
needs to be used.</p>
<p>The way this gets implemented is that we maintain a delta of facts as well as an
accumulator and rewrite the rules to make versions of them that use the deltas.</p>
<p>This is particularly effective for the so called <em>linear rules</em> such as the
recursive <code>academicAncestor</code> rule which only has one derived predicate in its
body. In that case, the semi-naïve evaluation turns a quadratic computation into
a linear one.</p>
<h3 id="incremental-evaluation">Incremental evaluation</h3>
<p>Datalog is amenable to incremental evaluation. Even in this version of the
evaluator, you can see that when a fixpoint is reached, we can enrich the
resulting knowledge base with additional facts and apply the fixpoint algorithm
again. This performs at least as good as starting from scratch and often much
much better.</p>
<p>The situation gets more complicated when there is negation in the language
because additional facts invalidate facts that depend on the negation of those
facts. This is a particular instance of <a href="https://en.wikipedia.org/wiki/Non-monotonic_logic"><em>non-monotonic
reasoning</em></a>. However,
Datalog, overall, is still a good language if you’re after incremental
evaluation.</p>
<p>Furthermore, the idea of incremental evaluation is intricately connected with
maintaining a delta of facts. If your evaluator uses semi-naïve evaluation
already, having an incremental evaluator is not much extra effort.</p>
<h3 id="data-structures">Data structures</h3>
<p>Using lists to compute over sets is a bad idea. Depending on the application,
hash tables, proper databases, in memory key-value stores, or at the very least
of <code>Set</code> and <code>Map</code> modules from the <code>containers</code> package will certainly make
things better. Use of sets in general is a good idea because then we don’t have
to rely on <code>nub</code> function’s internals for termination as discussed
<a href="#every-good-thing-must-come-to-an-end">earlier</a>.</p>
<h3 id="dependency-graphs">Dependency graphs</h3>
<p>We evaluate all rules in one pot but that is also very inefficient. We can
partition the program by determining dependencies between predicates. This
allows us to treat evaluated dependencies as static knowledge, so we have to
deal with a smaller collection of changing facts at any one time.</p>
<p>For example in the ancestor program, we would have a graph with <code>adviser</code> and
<code>academicAncestor</code> nodes where the former points to the latter and the latter
loops around. Meaning we can compute the fixpoint for <code>adviser</code> rules first,
then forget about those rules and compute the fixpoint of <code>academicAncestor</code>.</p>
<p>Also if your Datalog variant has <em>stratified negation</em> which is a popular way of
incorporating negated atoms, you already have to do the dependency analysis and
partition your program. So engineering-wise, this optimisation comes for free.</p>
<h3 id="parallelisation-distributed-computation">Parallelisation &amp; distributed computation</h3>
<p>Datalog evaluation is great for data-parallel computation. Even by inspecting
our implementation, it is evident that evaluating all the rules in a given
iteration is an embarrassingly parallel problem. The dependency graph can be
used to further parallelise the evaluation using work queues. Similarly, the
workload can be separated over multiple machines, a bit like
<a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a>.</p>
<h2 id="closing-remarks">Closing remarks</h2>
<p>Short program, long prose is the theme. I hope I managed to give some ideas
about how Datalog works. I tried to squeeze in as much semantics and tips for
more efficient implementation as possible which is probably more useful than a
short program.</p>
<p>If you want to look at Datalog further.
<a href="https://souffle-lang.github.io">Soufflé</a> is a modern variant geared towards
program analysis and is blazingly fast.</p>
<p>If you are interested in a more formal treatment of Datalog as well as some of
the optimisations I mentioned chapters 12 to 15 of <a href="http://webdam.inria.fr/Alice/">Foundations of
Databases</a> by Abiteboul, Hull, and Vianu are
probably the best resources which collect everything together in such detail and
with modern exposition.</p>
<h2 id="full-program">Full program</h2>
<p>Here’s the full program for your convenience.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SimpleDatalog</span> <span class="kw">where</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (fix)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (nub, intercalate, isSubsequenceOf)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (mapMaybe, fromMaybe, isNothing)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Program</span> <span class="ot">=</span> [ <span class="dt">Rule</span> ]</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rule</span> <span class="ot">=</span> <span class="dt">Rule</span> {<span class="ot"> _head ::</span> <span class="dt">Atom</span>,<span class="ot"> _body ::</span> [ <span class="dt">Atom</span> ] }</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Atom</span> <span class="ot">=</span> <span class="dt">Atom</span> {<span class="ot"> _predSym ::</span> <span class="dt">String</span>,<span class="ot"> _terms ::</span> [ <span class="dt">Term</span> ] } <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Sym</span> <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">KnowledgeBase</span> <span class="ot">=</span> [ <span class="dt">Atom</span> ]</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Substitution</span> <span class="ot">=</span> [ (<span class="dt">Term</span>, <span class="dt">Term</span>) ]</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a><span class="ot">emptySubstitution ::</span> <span class="dt">Substitution</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>emptySubstitution <span class="ot">=</span> []</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>solve rules <span class="ot">=</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">all</span> isRangeRestricted rules</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> fix step []</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">error</span> <span class="st">&quot;The input program is not range-restricted.&quot;</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="ot">  step ::</span> (<span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span>)</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> (<span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span>)</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>  step f currentKB <span class="op">|</span> nextKB <span class="ot">&lt;-</span> immediateConsequence rules currentKB <span class="ot">=</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> nextKB <span class="op">==</span> currentKB</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> currentKB</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> f nextKB</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="ot">isRangeRestricted ::</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>isRangeRestricted <span class="dt">Rule</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>  vars _head <span class="ot">`isSubsetOf`</span> <span class="fu">concatMap</span> vars _body</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>  isSubsetOf as bs <span class="ot">=</span> <span class="fu">all</span> (<span class="ot">`elem`</span> bs) as</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>  vars <span class="dt">Atom</span>{<span class="op">..</span>} <span class="ot">=</span> nub <span class="op">$</span> <span class="fu">filter</span> (\<span class="kw">case</span> {<span class="dt">Var</span>{} <span class="ot">-&gt;</span> <span class="dt">True</span>; _ <span class="ot">-&gt;</span> <span class="dt">False</span>}) _terms</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a><span class="ot">immediateConsequence ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>immediateConsequence rules kb <span class="ot">=</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>  nub <span class="op">.</span> (kb <span class="op">&lt;&gt;</span>) <span class="op">.</span> <span class="fu">concatMap</span> (evalRule kb) <span class="op">$</span> rules</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a><span class="ot">evalRule ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">Rule</span> <span class="ot">-&gt;</span> <span class="dt">KnowledgeBase</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>evalRule kb (<span class="dt">Rule</span> <span class="fu">head</span> body) <span class="ot">=</span> <span class="fu">map</span> (substitute <span class="fu">head</span>) (walk kb body)</span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a><span class="ot">walk ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> [ <span class="dt">Atom</span> ] <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a>walk kb <span class="ot">=</span> <span class="fu">foldr</span> (evalAtom kb) [ emptySubstitution ]</span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a><span class="ot">evalAtom ::</span> <span class="dt">KnowledgeBase</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ] <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a>evalAtom kb atom substitutions <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a>  substitution <span class="ot">&lt;-</span> substitutions</span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> downToEarthAtom <span class="ot">=</span> substitute atom substitution</span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a>  extension <span class="ot">&lt;-</span> mapMaybe (unify downToEarthAtom) kb</span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> substitution <span class="op">&lt;&gt;</span> extension</span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a><span class="ot">substitute ::</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Substitution</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a>substitute atom substitution <span class="ot">=</span> atom { _terms <span class="ot">=</span> <span class="fu">map</span> go (_terms atom) }</span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a>  go sym<span class="op">@</span><span class="dt">Sym</span>{} <span class="ot">=</span> sym</span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a>  go var<span class="op">@</span><span class="dt">Var</span>{} <span class="ot">=</span> fromMaybe var (var <span class="ot">`lookup`</span> substitution)</span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a><span class="ot">unify ::</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a>unify (<span class="dt">Atom</span> predSym ts) (<span class="dt">Atom</span> predSym' ts')</span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> predSym <span class="op">==</span> predSym' <span class="ot">=</span> go <span class="op">$</span> <span class="fu">zip</span> ts ts'</span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> [ (<span class="dt">Term</span>, <span class="dt">Term</span>) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Substitution</span></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true" tabindex="-1"></a>  go []                           <span class="ot">=</span> <span class="dt">Just</span> emptySubstitution</span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true" tabindex="-1"></a>  go ((s<span class="op">@</span><span class="dt">Sym</span>{}, s'<span class="op">@</span><span class="dt">Sym</span>{}) <span class="op">:</span> rest) <span class="ot">=</span> <span class="kw">if</span> s <span class="op">==</span> s' <span class="kw">then</span> go rest <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true" tabindex="-1"></a>  go ((v<span class="op">@</span><span class="dt">Var</span>{}, s<span class="op">@</span><span class="dt">Sym</span>{})  <span class="op">:</span> rest) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true" tabindex="-1"></a>    incompleteSubstitution <span class="ot">&lt;-</span> go rest</span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> v <span class="ot">`lookup`</span> incompleteSubstitution <span class="kw">of</span></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> s' <span class="op">|</span> s <span class="op">/=</span> s'   <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true" tabindex="-1"></a>      _                   <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> (v,s) <span class="op">:</span> incompleteSubstitution</span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true" tabindex="-1"></a>  go ((_, <span class="dt">Var</span>{}) <span class="op">:</span> _) <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;The second atom is assumed to be ground.&quot;</span></span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Andrew Rice&quot;,     &quot;Mistral Contrastin&quot;).</span></span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Dominic Orchard&quot;, &quot;Andrew Rice&quot;).</span></span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Andy Hopper&quot;,     &quot;Andrew Rice&quot;).</span></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Alan Mycroft&quot;,    &quot;Dominic Orchard&quot;).</span></span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;David Wheeler&quot;,   &quot;Andy Hopper&quot;).</span></span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Rod Burstall&quot;,    &quot;Alan Mycroft&quot;).</span></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true" tabindex="-1"></a><span class="co">- adviser(&quot;Robin Milner&quot;,    &quot;Alan Mycroft&quot;).</span></span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true" tabindex="-1"></a><span class="co">-</span></span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true" tabindex="-1"></a><span class="co">- academicAncestor(X,Y) :- adviser(X,Y).</span></span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true" tabindex="-1"></a><span class="co">- academicAncestor(X,Z) :- adviser(X,Y), academicAncestor(Y,Z).</span></span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true" tabindex="-1"></a><span class="co">-</span></span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true" tabindex="-1"></a><span class="co">- ?- academicAncestor(&quot;Robin Milner&quot;, Intermediate),</span></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true" tabindex="-1"></a><span class="co">-    academicAncestor(Intermediate, &quot;Mistral Contrastin&quot;).</span></span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true" tabindex="-1"></a><span class="co">- ?- academicAncestor(&quot;Alan Turing&quot;, &quot;Mistral Contrastin&quot;).</span></span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true" tabindex="-1"></a><span class="co">- ?- academicAncestor(&quot;David Wheeler&quot;, &quot;Mistral Contrastin&quot;).</span></span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true" tabindex="-1"></a><span class="ot">ancestor ::</span> <span class="dt">Program</span></span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true" tabindex="-1"></a>ancestor <span class="ot">=</span></span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Facts</span></span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (\terms <span class="ot">-&gt;</span> <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span> terms) [])</span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true" tabindex="-1"></a>    [ [ <span class="dt">Sym</span> <span class="st">&quot;Andrew Rice&quot;</span>,     <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ]</span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Dominic Orchard&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ]</span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Andy Hopper&quot;</span>,     <span class="dt">Sym</span> <span class="st">&quot;Andrew Rice&quot;</span> ]</span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Dominic Orchard&quot;</span> ]</span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;David Wheeler&quot;</span>,   <span class="dt">Sym</span> <span class="st">&quot;Andy Hopper&quot;</span> ]</span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Rod Burstall&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span> ]</span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true" tabindex="-1"></a>    , [ <span class="dt">Sym</span> <span class="st">&quot;Robin Milner&quot;</span>,    <span class="dt">Sym</span> <span class="st">&quot;Alan Mycroft&quot;</span> ]</span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true" tabindex="-1"></a>    ] <span class="op">&lt;&gt;</span></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Actual rules</span></span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ])</span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ] ]</span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ])</span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;adviser&quot;</span>          [ <span class="dt">Var</span> <span class="st">&quot;X&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> ]</span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;Y&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Z&quot;</span> ] ]</span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true" tabindex="-1"></a>  ] <span class="op">&lt;&gt;</span></span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Queries</span></span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query1&quot;</span> [ <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span> ])</span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">fmap</span> (<span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span>)</span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true" tabindex="-1"></a>        [ [ <span class="dt">Sym</span> <span class="st">&quot;Robin Milner&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span> ]</span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true" tabindex="-1"></a>        , [ <span class="dt">Var</span> <span class="st">&quot;Intermediate&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ])</span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query2&quot;</span> [ ])</span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span></span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true" tabindex="-1"></a>          [ <span class="dt">Sym</span> <span class="st">&quot;Alan Turing&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ]</span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Rule</span> (<span class="dt">Atom</span> <span class="st">&quot;query3&quot;</span> [ ])</span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">Atom</span> <span class="st">&quot;academicAncestor&quot;</span></span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true" tabindex="-1"></a>          [ <span class="dt">Sym</span> <span class="st">&quot;David Wheeler&quot;</span>, <span class="dt">Sym</span> <span class="st">&quot;Mistral Contrastin&quot;</span> ] ]</span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> [ <span class="dt">Substitution</span> ]</span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true" tabindex="-1"></a>query predSym pr <span class="ot">=</span></span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> queryVarsL <span class="kw">of</span></span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true" tabindex="-1"></a>    [ queryVars ] <span class="ot">-&gt;</span> <span class="fu">zip</span> queryVars <span class="op">&lt;$&gt;</span> relevantKnowledgeBaseSyms</span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;The query '&quot;</span> <span class="op">++</span> predSym <span class="op">++</span> <span class="st">&quot;' doesn't exist.&quot;</span></span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true" tabindex="-1"></a>    _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;The query '&quot;</span> <span class="op">++</span> predSym <span class="op">++</span> <span class="st">&quot;' has multiple clauses.&quot;</span></span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true" tabindex="-1"></a>  relevantKnowledgeBase <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">==</span> predSym) <span class="op">.</span> _predSym) <span class="op">$</span> solve pr</span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true" tabindex="-1"></a>  relevantKnowledgeBaseSyms <span class="ot">=</span> _terms <span class="op">&lt;$&gt;</span> relevantKnowledgeBase</span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true" tabindex="-1"></a>  queryRules <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">==</span> predSym) <span class="op">.</span> _predSym <span class="op">.</span> _head) pr</span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true" tabindex="-1"></a>  queryVarsL <span class="ot">=</span> _terms <span class="op">.</span> _head <span class="op">&lt;$&gt;</span> queryRules</span></code></pre></div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>My impression is, as time goes on, λ-calculus variants try to
tame λ-calculus (simply typed, linear, dependent, etc.) while Datalog variants
(relaxed range-restriction, functional symbols, explicit quantification, etc.)
let it run wild.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>As it happens, select-before-join is usually (but
certainly not always) the faster approach in real world. However, this doesn’t
affect us at all because the performance benefit requires an indexed database
for the columns that are grounded by substitution.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This is a simple check, but if we wanted, we
could make it even neater. Range-restriction is something that can be baked into
the <code>Rule</code> datatype using some dependent types. We would need to modify <code>Atom</code>
to keep track of its variables, but it is doable. While at it we could also
make substitutions keep track of their variables, which would enable us to
enforce the assumptions about our substitutions. You see, this is my favourite
kind of dependent types. It doesn’t give you full correctness, but eliminates a
whole class of software bugs and potentially give you some performance boost.
This may very well become a future blog post (famous last words on the topic).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Infinite programs are an interesting concept. I can’t
think of any use for it though. Also evaluating them is tricky as you can’t
traverse all your program statements, rules, etc. Notice that our Datalog
evaluator wouldn’t be terminating not only because of a potential infinite facts
problem, but because we try to evaluate each rule.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
