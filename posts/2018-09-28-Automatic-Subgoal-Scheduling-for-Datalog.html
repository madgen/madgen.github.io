<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Automatic Subgoal Scheduling for Datalog</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Serif" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on September 28, 2018
  
  
</div>

<h1>Automatic Subgoal Scheduling for Datalog</h1>


<p class="in-which">In which we investigate dataflow in declarative programs and talk about how to make Datalog safer by statically reordering goals when predicates with dataflow constraints are involved.</p>


<div class="post"><p>I recently presented <em>“Automatic Reordering for Dataflow Safety of Datalog”</em> (can be accessed freely if you follow the link from <a href="https://dodisturb.me">my homepage</a>) in the <a href="http://ppdp-lopstr-18.cs.uni-frankfurt.de/ppdp18.html">20th Symposium on Principles and Practice of Declarative Languages</a>. I collabroated with <a href="https://www.cs.kent.ac.uk/people/staff/dao7/">Dr Dominic Orchard</a> and <a href="https://www.cl.cam.ac.uk/~acr31/">Dr Andrew Rice</a> for this work. A few commented that the paper is technically dense and consequently hard going. I don’t want this work to be ignored because I suck at writing. So in an attempt to make things right and also to do some PR, I will explain the major ideas of the paper without the formalism and with numerous examples.</p>
<p>I want this post to be understandable with ease. If you find yourself confused or bored at any point or found some terms that are not very well explained, contact me via Twitter or email (both on <a href="https://dodisturb.me">my homepage</a>).</p>
<p>After explaining some standard terminology about Datalog, we start by describing what extralogical predicates are, why one might want them in Datalog, and what problems they bring along. Then we clarify what is meant by invocation safety of such predicates. This will lead us to the naïve, incomplete, and inefficient solution and that will lead us to a better solution. I’ll conclude by giving summarising the main points, mentioning where this work work might go and why you might like to look at the paper.</p>
<h2 id="terminology">Terminology</h2>
<p>Let’s briefly look at basic Datalog terminology through an example:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">ancestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>) <span class="kw">:-</span> parent(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> parent(<span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">.</span></code></pre></div>
<pre><code>                 -----------  -----------
                   Subgoal      Subgoal
-------------    ------------------------
    Head                   Body
------------------------------------------
                  Rule</code></pre>
<ul>
<li>This is a <strong>rule</strong> in Datalog (as it happens also in Prolog) with some parts highlighted.</li>
<li>A rule consists of a <strong>head</strong> (to the left of <code class="sourceCode prolog"><span class="kw">:-</span></code>) and a <strong>body</strong> (everything to the right of <code class="sourceCode prolog"><span class="kw">:-</span></code>). A body is a comma separated list of <strong>subgoals</strong>.</li>
<li>A subgoal is a <strong>predicate</strong> applied to a tuple.</li>
<li>A <strong>predicate</strong> qualifies a tuple with a name (sort). Throughout the text, we write subgoals in <code>monospace</code> and predicates in <span class="math inline"><em>i</em><em>t</em><em>a</em><em>l</em><em>i</em><em>c</em></span>. We sometimes say “the subgoal with <span class="math inline"><em>p</em></span>” to refer to a subgoal with the predicate <span class="math inline"><em>p</em></span> inside.</li>
<li>A tuple of subgoal consists of <strong>terms</strong> which are either <strong>constants</strong> like <code>&quot;Dragon Fruit&quot;</code> (with quotation marks) or <strong>variables</strong> like <code>Fruit</code> (no quotations, always capitalised).</li>
</ul>
<p>We’re good to go! All other terms will be defined in the text as we go along.</p>
<h2 id="motivation">Motivation</h2>
<h4 id="example-1">Example 1</h4>
<p>Here’s a hypothethical Datalog rule that authenticates a user:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>The reading of any rule in Datalog is “if every subgoal in the body holds, then we can conclude the head.” In this specific case, we can authenticate a user if we have a known password for a that user and the hash of that user is known to be valid. One of the nicest parts of this reading is that it doesn’t matter which order the subgoals are presented, we still reach the same conclusion. For example,</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>would authenticate exactly the same users as the previous example.</p>
<p>When the predicates in a program are <em>logical</em>, there are no dataflow restrictions for evaluation of a subgoal with that predicate. For example, <code class="sourceCode prolog">password(<span class="ot">&quot;</span><span class="er">Milner</span><span class="ot">&quot;</span><span class="kw">,</span><span class="dt">Pass</span>)</code> would bind the password of Milner to <code>Pass</code> while <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> would generate all known user and password pairs. There are no inherent input and output parameters to a logical predicate.</p>
<p>However, the <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> predicate stands out in the previous example because hash functions (if they are any good) work only in one direction. It is unreasonable to expect <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> to bind a value for the password given a hash. Let’s refer to predicates like <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> (those with dataflow requirements) as <em>extralogical</em> predicates.</p>
<p>In light of this knowledge, the versions of the rule defining <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> above are not equivalent. Evaluation of the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> produces a runtime error if the value of <code>Pass</code> is unknown. Suddenly, we have to be careful about the way we order subgoals. Not only those that are obviously extralogical like <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span>, but also any user-defined predicates that make use of extralogical ones! To make the matters worse, although semantically arithmetic relations such as <span class="math inline">&gt;</span> are logical, they are usually implemented as extralogical predicates (or relations).</p>
<h4 id="example-2">Example 2</h4>
<p>Just when you think things are looking bleak, it gets worse. Extralogical predicates may also cause code duplication. Let’ look at another example:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>

weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Here, we define a predicate <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> that checks if a password or a hash is weak. It does so looking for the hash of the password in a rainbow function (a function that can reverse <em>some</em> hashes). Like <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span>, <span class="math inline"><em>r</em><em>a</em><em>i</em><em>n</em><em>b</em><em>o</em><em>w</em></span> is also extralogical but in its second argument rather than the first. Now it is beneficial for both the client and the server to check if a hash is weak, but the client shouldn’t know the hash of a given password (otherwise it can construct a rainbow table of its own!) and the server shouldn’t know the password (in case it gets stolen). Hence, there are two predicates <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em><sub><em>c</em></sub><em>l</em><em>i</em><em>e</em><em>n</em><em>t</em></span> that takes a password and <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em><sub><em>s</em></sub><em>e</em><em>r</em><em>v</em><em>e</em><em>r</em></span> that takes a hash that can be used by the client and server respectively.</p>
<p>This example is worse than the previous one because regardless how careful the programmer is, she can’t rewrite the definition of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> in a single rule such that all dataflow requirements are satisfied. Now when <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em><sub><em>c</em></sub><em>l</em><em>i</em><em>e</em><em>n</em><em>t</em></span> is used, <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> should have the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first, since the password is known (satisfying <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span>’s dataflow requirement) and evalauting this subgoal produces a hash, satisfying the dataflow requirement of <span class="math inline"><em>r</em><em>a</em><em>i</em><em>n</em><em>b</em><em>o</em><em>w</em></span>. If <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em><sub><em>s</em></sub><em>e</em><em>r</em><em>v</em><em>e</em><em>r</em></span> is used, we need the opposite ordering because this time the hash value is known initially. So neither rule alone can be used to satisfy the requirements of the whole program. The only solution is a code duplicating rewrite:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak_client(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak_server(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>

weak_client(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
weak_server(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<h4 id="example-3">Example 3</h4>
<p>If you’re still not sold on the idea, I have one final motivating example. Even in the purely logical implementations of Datalog, dataflow problems exist. Stratified negation is indispensible in Datalog programming. When discussing negation, the emphasis is always on the lack of cyclic dependencies between predicates used negatively. However, there is another syntactic problem. Consider the following rule:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">accessed(<span class="ot">&quot;</span><span class="er">Mistral</span><span class="ot">&quot;</span>)<span class="kw">.</span>
accessed(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span>)<span class="kw">.</span>
accessed(<span class="ot">&quot;</span><span class="er">Rebecca</span><span class="ot">&quot;</span>)<span class="kw">.</span>

password(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span> <span class="kw">,</span><span class="ot">&quot;171717&quot;</span>)<span class="kw">.</span>
password(<span class="ot">&quot;</span><span class="er">Rebecca</span><span class="ot">&quot;</span><span class="kw">,</span><span class="ot">&quot;242424&quot;</span>)<span class="kw">.</span>

guest(<span class="dt">User</span>) <span class="kw">:-</span> not password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>

<span class="fu">?-</span> accessed(<span class="dt">User</span>)<span class="kw">,</span> guest(<span class="dt">User</span>)<span class="kw">.</span></code></pre></div>
<p>This program poses the query “out of those who are known to access the system, which ones are guests?”. Being a guest is defined as not having a password recorded for the given user identifier. This is a stratified program, so semantically negation should be fine. Yet most implementations would reject this program because Datalog semantics is also based on <a href="https://en.wikipedia.org/wiki/Herbrand_structure#Herbrand_universe">Herbrand Universes</a>. This means we can only conclude facts about constants that are known to the system. In this example, we can only conclude positive or negative negative facts about Mistral, Rebecca, and Hattie, but not about Jessica.</p>
<p>In principle, this should be fine because the values <code>User</code> variable can take are already restricted by the <code class="sourceCode prolog">accessed(<span class="dt">User</span>)</code> subgoal in the query. However, most implementations of Datalog would reject this as this subgoal does not appear directly within the rule of <span class="math inline"><em>g</em><em>u</em><em>e</em><em>s</em><em>t</em></span> and before the negated subgoal. This is a conservative approximation. Notice that we have not used any extralogical predicates, yet negated subgoals automatically require all variables appearing inside them to be bound by the subgoals preceding them. This is precisely the problem we have with extralogical predicates.</p>
<h3 id="overall-sentiment">Overall sentiment</h3>
<p>The chances are if you chose a declarative language such as Datalog over an imperative alternative, these sort of details are exactly what you are trying to run away from. It seems here we’re forced to choose between useful functionality and high-level programming. The work that follows allows you to have both and do so without incurring a runtime performance penalty.</p>
<h2 id="understanding-invocation-safety">Understanding invocation safety</h2>
<p>Although the examples illustrate the problems with extralogical predicates, they do not provide us anything concrete to compute with. We need a way of representing bindings of parameters and dataflow requirements in the program. As soon as we define these, the precise definition of invocation safety is simple.</p>
<h3 id="adornments-conrete-parameter-binding">Adornments: conrete parameter binding</h3>
<p><em>Adornments</em> indicate whether a parameter is bound or not. <em>Adornment transformation</em> is the standard analysis that computes it. Let’s understand this using <a href="#example-1">Example 1</a>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth(<span class="dt">User</span>) <span class="kw">:-</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Is the argument <code>Pass</code> in the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> bound? Yes, it is because the preceding subgoal <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> has this variable in it and its evaluation binds <code>Pass</code>. How about the <code>Pass</code> argument in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code>? It is free because we haven’t even seen this variable before<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, there is no way something else could have bound it. How about the <code>User</code> argument appearing in the same subgoal? It depends on the caller of the <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> predicate.</p>
<p>Different queries yield different answers:</p>
<ol style="list-style-type: decimal">
<li><code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="dt">U</span>)</code> asks which users can be authenticated. Since we do not know which user to authenticate, the <code>User</code> in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> variable is not bound to a value.</li>
<li><code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span>)</code> asks if Jasmine is authenticated. Since we know which user to authenticate, <code>User</code> in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> is bound to a value.</li>
</ol>
<p>What we learn from that example is the following:</p>
<ol style="list-style-type: decimal">
<li>Adornment is a top-down procedure starting from the query, the binding information flows down.</li>
<li>Constants such as <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span></code> are ground, hence are bound.</li>
<li>Variables of a subgoal are bound if they appear in subgoals that precede them like <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> preceding <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>.</li>
<li>Variables of a subgoal are also bound if the variable appears bound in the head of the rule. For example, <code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span>)</code> makes <code>User</code> in the head of the <span class="math inline"><em>u</em><em>s</em><em>e</em><em>r</em></span> rule bound. Consequently, <code>User</code> in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> is bound.</li>
</ol>
<p>These four rules define a top-down procedure for binding. Let’s invent something concrete to compute with. Let’s call parameters that are bound in an atomic formula <code>b</code> and those that are free <code>f</code>. We can then define binding (or adornment) patterns for atomic formula. From the example above, <code class="sourceCode prolog">auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span>)</code> would have the pattern <code>b</code> due to the constant, <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> would have <code>ff</code> or <code>bf</code> depending on if <code>User</code> is bound in the head of the rule, and <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> would have <code>bf</code>. As an exercise you can try to figure out the binding pattern for <code class="sourceCode prolog">valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> from the previous example (the answer<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>).</p>
<h4 id="example-4">Example 4</h4>
<p>Before moving on from adornments, let’s look at an extension of Example 2. There is something that brings us closer to the solution of the code duplication problem described above.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> check_client(<span class="ot">&quot;123456&quot;</span>)<span class="kw">.</span>
<span class="fu">?-</span> check_server(<span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span>

check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>

weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>This is the same program in <a href="#example-2">Example 2</a> except that we have two queries one using the <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em>_<em>c</em><em>l</em><em>i</em><em>e</em><em>n</em><em>t</em></span> predicate and the other using <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em>_<em>s</em><em>e</em><em>r</em><em>v</em><em>e</em><em>r</em></span>. Now let’s adorn this program but rather than noting the adornment patterns separately, let’s make them suffixes to the names of the predicates. This is how this analysis is usually conduct and is the reason why it is referred as a transformation despite being an analysis in spirit. As it is a top-down procedure we start from the queries.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> check_client_b(<span class="ot">&quot;123456&quot;</span>)<span class="kw">.</span>
<span class="fu">?-</span> check_server_b(<span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span></code></pre></div>
<p>Both queries receive the pattern <code>b</code> because all arguments are constants. Next we propagate this to the rules defining <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em>_<em>c</em><em>l</em><em>i</em><em>e</em><em>n</em><em>t</em></span> and <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em>_<em>s</em><em>e</em><em>r</em><em>v</em><em>e</em><em>r</em></span> predicates.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">check_client_b(<span class="dt">Pass</span>) <span class="kw">:-</span> weak_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_server_b(<span class="dt">Hash</span>) <span class="kw">:-</span> weak_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>The heads of each predicate receive their adornments directly from their callers. Since both callers have the pattern <code>b</code>, so do the heads. Now in the bodies, we have <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em>_<em>b</em><em>f</em></span> and <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em>_<em>f</em><em>b</em></span> predicates because <code class="sourceCode prolog">check_client_bf(<span class="dt">User</span>)</code> binds the first parameter of <code class="sourceCode prolog">weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> and <code class="sourceCode prolog">check_client_fb(<span class="dt">User</span>)</code> binds the second parameter of <code class="sourceCode prolog">weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>. Since we have two different bindings for <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span>, we need two versions of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> body.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">weak_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_bb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
weak_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_bb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>The adornment of these rules are done exactly as before, so I won’t describe them again. The important point is the adornment patterns of subgoals are effected by the adornments patern of the head. The binding patterns of <code>hash</code> above are <code>bf</code> and <code>fb</code> and this difference stems only from the head of the tules.</p>
<p>This looks remarkably similar to the code duplication solution we found to the problem described in <a href="#example-2">Example 2</a>. Once again, we ended up with two different versions of weak with suffixes are <code>bf</code> and <code>fb</code> instead of <code>client</code> and <code>server</code>. This is a spurfluous difference. The other difference is that the rule with head <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em>_<em>f</em><em>b</em></span> is not reordered while the one with <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em>_<em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> is. So it can’t be a solution to the invocation safety on its own, but it is a step in the right direction and we develop this furter <a href="#generalised-adornment">below</a>.</p>
<h3 id="modes-concrete-dataflow-requirements">Modes: concrete dataflow requirements</h3>
<p>A <em>mode</em> is an indication of input/output behaviour. Each predicate logical or otherwise have a <em>mode pattern</em> associated with it. We only need two modes for Datalog <code>+</code> and <code>?</code>. If the invocation a predicate is going to be safe, parameters with mode <code>+</code> must be bound and those with mode <code>?</code> are always safe bound or not.</p>
<p>For example, <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> from <a href="#example-1">Example 1</a> has a <code>+?</code> pattern because its first parameter needs to be bound at the time of invocation and the second parameter may be bound or not. If we evaluate the subgoal <code class="sourceCode prolog">hash(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span><span class="kw">,</span><span class="ot">&quot;42&quot;</span>)</code>, <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span></code> must be there to safely execute <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span>, but it doesn’t matter <code class="sourceCode prolog"><span class="ot">&quot;42&quot;</span></code> is there because if the hash of <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span></code> is <code class="sourceCode prolog"><span class="ot">&quot;0&quot;</span></code>, then we can compare <code class="sourceCode prolog"><span class="ot">&quot;0&quot;</span></code> and <code class="sourceCode prolog"><span class="ot">&quot;42&quot;</span></code> safely. Let’s look at <span class="math inline"><em>p</em><em>a</em><em>s</em><em>s</em><em>w</em><em>o</em><em>r</em><em>d</em></span> now. That predicate is a lot like a database table, there are no restrictions on what you can use to look up values. Hence, it has the mode pattern <code>??</code>. In standard Datalog, all predicates have <code>?</code> mode associated with all of their parameters<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Let’s adopt a scheme of ammending the predicate name with mode patterns to make things syntactically obvious just as we did in the <a href="#example-4">adornments example</a>. <a href="#example-1">Example 1</a> becomes</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth_x(<span class="dt">User</span>) <span class="kw">:-</span>
  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>You notice there is an <code>x</code> in place of <code>f</code> or <code>b</code> for the <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> predicate. That’s because we don’t know a way of determining modes of user-defined predicates. Intuitively, dataflow requirements of a user-defined predicate is some function of the subgoals that define those predicates. Indeed, finding an finding an effective procedure to precisely determine mode patterns of user-defined predicates is the only hard part of our quest to ensure invocation safety. Something we explore in the <a href="#solution">solution</a>.</p>
<h3 id="relating-adornments-to-modes-aka.-invocation-safety">Relating adornments to modes (aka. invocation safety)</h3>
<p>Remember <code>b</code> means the parameter <strong>is bound</strong> and <code>+</code> means the parameter <strong>needs to be bound</strong>. Modes and adornments are clearly related. Their main differences are:</p>
<ul>
<li>Adornment transformation needs an entry point (a query) and <strong>dataflow infromation flows top-down</strong> from heads to the bodies. We don’t have a procedure for computing modes (yet), but we mentioned the predicates defined in the heads should be a function of those. This suggests <strong>bottom-up information flow</strong>.</li>
<li>Binding (adornment) patterns <strong>qualify subgoals</strong> (predicates applied to tuples of variable and constants). Mode patterns, on the other hand, <strong>qualify predicates</strong> and hence don’t change from one subgoal to another.</li>
<li>Related to the previous point, adornment is entirely dependent on the query, whereas modes are not. This suggests we can perhaps compute modes beforehand and consult them as queries change.</li>
</ul>
<p>The agreement between adornments and modes be made precise: in an adorned program, invocations of extralogical predicates are safe when all subgoals with extralogical predicates are adorned with <code>b</code> for parameters with mode <code>+</code>. This is to say <strong>if it needs to be bound, it is bound.</strong> (Told you it was trivial.)</p>
<p>In the literature, invocation safety is called <em>well-modedness</em>. A well-moded query and program pair doesn’t produce invocation errors just like “well-typed programs don’t go wrong” as <a href="https://en.wikipedia.org/wiki/Robin_Milner">Robin Milner</a> put it.</p>
<h2 id="solution">Solution</h2>
<p>Now we start with the stupidest possible thing we can do and refine our approach.</p>
<h3 id="naïve-solution">Naïve solution</h3>
<p>The examples so far suggest that it is a simple reordering program of rule bodies. So why not let’s give this a go. Recall the variation of <a href="#example-1">Example 1</a> with <a href="#mode-summarising-dataflow-requirements">mode embellishments</a>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth_x(<span class="dt">User</span>) <span class="kw">:-</span>
  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Let’s adorn versions of this clause with the subgoals permuted with respect to the query <code class="sourceCode prolog"><span class="fu">?-</span> auth_x(<span class="dt">User</span>)</code>. The heads of the clauses are omitted as they are always <code class="sourceCode prolog">auth_x_f(<span class="dt">User</span>)</code>.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?<span class="dt">_bf</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
valid_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
valid_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>
hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>
hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>The last three are well-moded while the first three are not. Since <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> the only predicate with a binding requirement, namely on its parameters. Orderings that leads to a bound mode (<code>b</code>) at the first parameter are well-moded, while the others are not.</p>
<p>The obvious problem is if there are <span class="math inline"><em>n</em></span> subgoals we may need to adorn <span class="math inline"><em>n</em></span> factorial orderings to find a suitable ordering. But perhaps that’s not a big problem in practice if programmers stick to 3 to 5 subgoals per clause. The real problem is that we cannot isolate clauses.</p>
<h4 id="example-5">Example 5</h4>
<p>Let’s say we do some software engineering and factor <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> and <code class="sourceCode prolog">valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> into a new clause with head predicate <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> as follows:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> auth_x(<span class="dt">User</span>)
auth_x(<span class="dt">User</span>) <span class="kw">:-</span> check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>
check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Now let’s try adorning this program while considering different orderings of <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> as that is where the extralogical predicate <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> occurs.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> auth_x_f(<span class="dt">User</span>)
auth_x_f(<span class="dt">User</span>) <span class="kw">:-</span> check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>

check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> valid_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>This looks like bad news because when we reorder <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> alone, neither of the orderings lead to an adornment that makes invocation of <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> safe. They both are make the first parameter free.</p>
<p>At this point we can just say that we have a sound but incomplete analysis, tough luck. Alternatively, we recognise that the first parameter of the subgoal with <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> is <code>Pass</code> which appear in the head of the clause. As we learn in <a href="#adornments-summarising-binding-of-parameters">adornment transformation rules</a>, if a parameter is bound in the head then it is also bound in the body. So all we need is to turn the <code>ff</code> binding pattern of the head to <code>fb</code> or <code>bb</code>. This is indeed possible if we reorder the use of <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> within the <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> clause as follows:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> auth_x_f(<span class="dt">User</span>)
auth_x_f(<span class="dt">User</span>) <span class="kw">:-</span> password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>

check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?<span class="dt">_bf</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> valid_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>After permuting subgoals with <span class="math inline"><em>p</em><em>a</em><em>s</em><em>s</em><em>w</em><em>o</em><em>r</em><em>d</em></span> and <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span>, we end up with <code>bb</code> adornment for the head of <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> and regardless the order of subgoals in the body <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span>. This makes invocations of <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> safe in both cases. Computationally, however, this is problematic. Search space is exponential not only in the size of individual bodies but it is a multiplication of all possible orderings of all clauses from query down to the relevant clause. This is intractable even for small more programs. Now we tackle this problem.</p>
<h3 id="greed-is-good">Greed is good</h3>
<p>We can’t do better than exponential asymptotically, but we can make it exponential the way Hindley-Milner type inference is—only in degenerate cases.</p>
<p><strong>The most important insight</strong> to our solution is the following: although dataflow requirements are inherent to the predicates, they are conceptual. That is to say if a predicate parameter has mode <code>+</code> (requiring it to be bound) and the subgoal using that predicate has the variable <code>V</code> at that parameter, if a preceding subgoal already binds <code>V</code>, we can safely pretend as if the predicate has mode <code>?</code> in this context. So we can treat</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">... <span class="kw">:-</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> ...</code></pre></div>
<p>as</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">... <span class="kw">:-</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_??(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> ...</code></pre></div>
<p>so <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> in that context behaves as if it is a logical predicate.</p>
<p>Now we exploit the contextual nature of dataflow. We schedule subgoals with no dataflow requirements first such as <span class="math inline"><em>p</em><em>a</em><em>s</em><em>s</em><em>w</em><em>o</em><em>r</em><em>d</em></span> and <span class="math inline"><em>v</em><em>a</em><em>l</em><em>i</em><em>d</em></span>. These subgoals can be freely placed anywhere in the body as they are always safe to execute. So we <strong>adopt a greedy approach</strong> and schedule subgoals with such predicates as early as possible.</p>
<p>The benefits of this approach are two fold:</p>
<ol style="list-style-type: decimal">
<li>Combinatorially, there are fewer orderings to consider as placement of logical subgoals are restricted.</li>
<li>Variables of scheduled subgoals are propagated to the remaining alternatives to relax the dataflow constraints as described above. This would lead to further opportunities to apply the greedy schedule.</li>
</ol>
<p>Scheduling of subgoals fit nicely into a graph where the edges are labelled with subgoals to schedule and orderings are the paths from the root to vertices with no successors.</p>
<h4 id="example-6">Example 6</h4>
<p>Let’s apply this strategy to <a href="#example-1">Example 1</a>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth_x(<span class="dt">User</span>) <span class="kw">:-</span>
  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>The corresponding graph is:</p>
<pre><code>     {password, valid}             {hash}
V0 --------------------&gt; V1 -------------------&gt; V2</code></pre>
<p>This graph stores orderings where subgoals with predicates <span class="math inline"><em>p</em><em>a</em><em>s</em><em>s</em><em>w</em><em>o</em><em>r</em><em>d</em></span> and <span class="math inline"><em>v</em><em>a</em><em>l</em><em>i</em><em>d</em></span> are scheduled first and it doesn’t matter in which order, only then the subgoal with predicate <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> is scheduled.</p>
<p>The subgoals with predicates <span class="math inline"><em>p</em><em>a</em><em>s</em><em>s</em><em>w</em><em>o</em><em>r</em><em>d</em></span> and <span class="math inline"><em>v</em><em>a</em><em>l</em><em>i</em><em>d</em></span> could be scheduled first because they have no dataflow requirements (indicated by <code>??</code> mode pattern). The subgoal with <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> could not be scheduled at that point due to <code>+?</code> mode pattern. However, as we established earlier in this section, mode patterns can be relaxed at a given context. So if we treat the vertex <code>V1</code> in the graph as a context, <code>hash_+?(Pass,Hash)</code> behaves as <code>hash_??(Pass,Hash)</code> because on this path the subgoal <code>password(User,Pass)</code> precedes it and binds <code>Pass</code>, thus we can schedule it at that point using the greedy principle.</p>
<p>More concretely, this leads to the following orderings:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>These are the two of three well-moded orderings found through brute-force search in <a href="#naïve-solution">naïve solution</a> described above. Compared to that solution, we are missing one valid ordering. The ordering we miss have <code>valid_??(User,Hash)</code> at the end of the body. Greedy scheduling prevents us to discover this ordering.</p>
<p>This raises the question <strong>“are there cases in which we discard the only safe ordering?”</strong> The answer is no. If there is at least one safe ordering that can be found by reordering, greedy scheduling will also find at least one valid ordering. Surprisingly, <em>greed is good</em><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> and it doesn’t compromise completeness.</p>
<p>Before we move on to other examples of scheduling graphs, we can finally answer the pending question of mode patterns for user-defined predicates posed <a href="#modes-summarising-dataflow-requirements">where modes are introduced</a>.</p>
<h3 id="modes-of-user-defined-predicates">Modes of user-defined predicates</h3>
<p>Let’s continue with <a href="#example-6">Example 6</a> and deduce what <code>x</code> in <code>auth_x(User)</code> should be.</p>
<p>Since a mode marks a requirement of boundness, <code>x</code> should be <code>+</code> if <code>User</code> needs to be bound for the invocation to be safe and it should be <code>?</code> if invocation of all predicates in the body are safe regardless binding status of <code>User</code>. Technically, if it is safe with a <code>?</code> mode, then it is also safe with a <code>+</code> modes, so we are looking for the most relaxed mode<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. The orderings from the graph above didn’t make any conditional reasoning about boundedness of <code>User</code>, hence <code>?</code> is suitable for <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span>. We can revise the two versions of the cluase as follows:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">auth_?(<span class="dt">User</span>) <span class="kw">:-</span>
  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
auth_?(<span class="dt">User</span>) <span class="kw">:-</span>
  valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<h4 id="example-7">Example 7</h4>
<p>Let’s now look at <a href="#example-5">Example 5</a> again:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> auth_x(<span class="dt">User</span>)

auth_x(<span class="dt">User</span>) <span class="kw">:-</span> check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span>
check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Let’s look at the interesting scheduling graph first that is the one for for <code>check</code> at the head.</p>
<pre><code>     {valid}        {hash}
V1 ----------&gt; V2 ---------&gt; V3</code></pre>
<p>This graph looks similar to the previous one. We apply the greedy principle and schedule <code class="sourceCode prolog">valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first. The difference is the variable bound by this subgoal (<code>User</code> and <code>Hash</code>) don’t include <code>Pass</code> which is the variable at the dataflow restricted parameter of <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>. So the only way we can schedule <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> is that we require <code>Pass</code> to be bound from the moment we start evaluating the rule. This is same as saying the second parameter of <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span> (which is <code>Pass</code>) has to be bound. For the first parameter, there are no restrictions posed. Then the overall mode pattern for check is <code>?+</code>.</p>
<p>In the description above, we kept track of which variables on the path has to be resolved by the invoker of the predicate being defined. This information can naturally be stored in the vertices as an accumulator. This is indeed how it is done in the paper but we elide the details here to simplify the presentation.</p>
<p>Now that we know the mode pattern for <span class="math inline"><em>c</em><em>h</em><em>e</em><em>c</em><em>k</em></span>, we can draw a scheduling graph for the rule that defines <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> and deduce its predicate (again). This time we do not give a detailed explanation. It’d be a good exercise to see why we scheduled which predicate and why and what the mode pattern of <span class="math inline"><em>a</em><em>u</em><em>t</em><em>h</em></span> is.</p>
<pre><code>     {password}        {check}
V1 -------------&gt; V2 ----------&gt; V3</code></pre>
<p>We cheat here a bit and impose an order on building the graphs. In general, we can’t find such an order because rules can refer to themselves recursively or be mutually recursive with other clauses. Proper way of handling that situation is to assume <code>?</code> in place of <code>x</code> for modes of user-define predicates initially, and repeatedly apply this graph-based analysis to update the patterns until we reach stable mode patterns (fixpoint) for all user-define predicates. You can refer to the paper on why this works and why it terminates at all.</p>
<h4 id="example-8">Example 8</h4>
<p>So far it looks like all the scheduling graphs are just single paths. This is not the case in general and we can use <a href="#example-2">Example 2</a> to demonstrate it:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>We don’t have any logical predicates in this body. This can’t be a good start. There is only one thing we do, that is to default to brute-force search for a moment and try scheduling both subgoals.</p>
<pre><code>      {hash}          {rainbow}
  -------------&gt; V2 -------------&gt; V3
 /
V1
 \
  -------------&gt; V5 -------------&gt; V6
    {rainbow}           {hash}</code></pre>
<p>Finally, some more interesting <code>ASCII</code> art.</p>
<p>Let’s inspect the branch we try scheduling <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first. In this path, scheduling the subgoal with <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> predicate binds <code>Pass</code> and <code>Hash</code>, as a result at the context of <span class="math inline"><em>V</em>2</span>, rainbow behaves like a logical predicate (the dataflow constrained second parameter has <code>Pass</code> which is already bound). Since we couldn’t schedule hash the subgoal with <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> for free, it seems we need to constraint the first parameter (<code>Pass</code>) of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> leading <code>+?</code> mode pattern.</p>
<p>But wait a second! if we inspect the other branch instead, we commit to requiring <code>Hash</code> to be bound in the head of the rule (and consequently dealt with by the caller) instead. This suggests a mode pattern <code>?+</code>.</p>
<p>So which is it? In a way, it is both. Depending on the ordering of the clauses we have different dataflow requirements. This is good! Now we can just select a representitive ordering for each mode pattern. When the clause is used differently, we use the appropriate ordering. So the overall mode pattern of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> is <code>+?/?+</code> to signify either of them can be used.</p>
<p>One reason we ended with two alternatives is that the mode patterns we obtained are incomparable. If we had options <code>+?</code> and <code>++</code>, instead we could have discarded <code>++</code> because <code>+?</code> is a more favourable alternative. This allows us to store fewer orderings. We say more about that in the paper.</p>
<h3 id="multiple-rules">Multiple rules</h3>
<p>So far we have been assuming that a predicate is defined by a single rule. Now we look at those defined by multiple rules. Let’s extend <a href="#example-8">Example 8</a> to have a custom extralogical predicate that checks weakness of a password hash pair and requires both of them to execute safely.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> custom_weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>We already know the first rule leads to the mode pattern <code>+?/?+</code>. The second rule is so simple that we can tell the mode pattern it leads without drawing the relevant scheduling graph, namely <code>++</code> inherited from its single defining subgoal.</p>
<p>Now what does it mean to invoke a predicate in Datalog? It means we are going to try each of its defining rules to collect all possible conclusions. This implies any invocation of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> is going to evaluate both rules. Therefore, the only thing we can do to ensure safety is to satisfy the dataflow requirements of each clause simultaneously. What this means for our example is that we generate all possible combinations that is <code>++</code> &amp; <code>+?</code> and <code>++</code> &amp; <code>?+</code>. In each case, <code>++</code> is stricter for every parameter, so it shadows the other. Hence, we end up with <code>++/++</code>, but since both alternatives are identical, the overall mode pattern for <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> is <code>++</code>.</p>
<p>This is the second time we are combining mode patterns and there is a form of subsumption going on. When we consider two alternative dataflow requirements and their combination leads to a more relaxed mode pattern. When we combine two mode patterns that need to be satisfied simultaneously, the combination is more strict. You must have noticed that these two operations sound very algebraic. Indeed, to our surprise, they form <a href="https://www.cl.cam.ac.uk/teaching/0910/L11/L11_04_08.pdf">Martelli’s semiring</a> (sorry, there aren’t any non-academic resources I could find) originally used to compute cutsets of a graph. To the best of my knowledge this hasn’t been used in dataflow context before and seems general enough to be used beyond Datalog and extralogical predicates.</p>
<h3 id="generalised-adornment">Generalised adornment</h3>
<p>Now we know how to determine dataflow requirements of user-defined predicates as well as orderings of subgoals that lead to these requirements. However, this does not help very much with our definition of <a href="#relating-adornments-to-modes-aka.-invocation-safety">invocation safety</a>. The reason is that definition rely on adorning a program in the given order of subgoals. This is already in the result of <a href="#example-4">Example 4</a> with two different versions of the <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> clause with different adornments but static ordering of subgoals.</p>
<p>So the final step in our quest to invocation safety is to generalise adornment procedure such that it can take reorderings into the account.</p>
<p>We modify the adornment procedure in a single way. We let the procedure take a reordering function that given a clause and a binding pattern produces an ordering. Of course, we compute these orderings through scheduling graphs as above. Then, right before we start adorning the body of a clause, we apply the reordering first, then adorn from left to right as usual.</p>
<h4 id="example-9">Example 9</h4>
<p>Consider the following example adapted from <a href="#example-4">Example 4</a>.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> weak_+?/?+(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span>

weak_+?/?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>So the head of <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> clause will have the adornment <code>fb</code> due to the query. We almost computed the ordering function for <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> in <a href="#example-8">Example 8</a>. For <code>?+</code> mode pattern alternative which is the only alternative compatible with <code>fb</code> binding pattern, we have an ordering in which the subgoal with <span class="math inline"><em>r</em><em>a</em><em>i</em><em>n</em><em>b</em><em>o</em><em>w</em></span> comes first and the subgoal with <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> come second. So we reorder the body first and then perform the adornment and that leads to the following adorned program:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)

weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> rainbow_?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>And voilà, we have a <span class="math inline"><em>r</em><em>a</em><em>i</em><em>n</em><em>b</em><em>o</em><em>w</em></span> subgoal with an adornment for its second parameter <code>b</code> and <span class="math inline"><em>h</em><em>a</em><em>s</em><em>h</em></span> subgoal with an adornment for its first parameter <code>b</code> as required. As all extralogical predicates are used in subgoals with adornments that match their modes, the program is safe to invoke.</p>
<h3 id="checking-invocation-safety">Checking invocation safety</h3>
<p>Once we compute modes for all-user defined predicates including the query, we don’t have to adorn the program to see if the program is well-moded. We only need to look at the query.</p>
<h4 id="example-10">Example 10</h4>
<p>In <a href="#example-9">Example 9</a> the query was <code class="sourceCode prolog"><span class="fu">?-</span> weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)</code>, here the fact that <code>fb</code> is consistent with one of the mode pattern alternatives, namely <code>?+</code> immediately indicates that we have a ordering function that satisfy all dataflow requirements.</p>
<p>If, on the other, hand we pose the same query to the version of weak used in explaining <a href="#multiple-rules">modes of predicates with multiple rules</a>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)

weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span>
weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> custom_weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></code></pre></div>
<p>Just by looking at the query, we know the program is not well-moded with respect to this query because the predicate <span class="math inline"><em>w</em><em>e</em><em>a</em><em>k</em></span> in this case requires both of its parameters to be bound but the first argument to the query is the free variable <code>Pass</code>.</p>
<h3 id="some-properties">Some properties</h3>
<p>This algorithm enjoys a number of properties. I am neither going to get into their proofs nor the mathematical details, but it would be amiss to omit them entirely:</p>
<ol style="list-style-type: decimal">
<li>Soundness: if the algorithm finds a reordering function for a program, the the reordered rules won’t have invocation safety.</li>
<li>Completeness: if there are any orderings of clauses that ensure invocation safety, then the algorithm will find a (possible different) set of orderings that ensure invocation safety.</li>
<li>Incremental computation: addition of new rules don’t invalidate the old results, hence the mode patterns of existing user-defined predicates can be used to seed the analysis leading to faster execution.</li>
<li>Termination: the analysis terminates on all inputs.</li>
</ol>
<p>In particular, incremental computation is useful for making this analysis scalable. In the specical case that the added rule does not extend an existing predicate, <em>i.e.</em>, have a freash head, we don’t have to reanalyse old rules. This means we can analyse libraries and ship the mode patterns of predicates defined in the library with them. The users of the library won’t have to reanalyse the code in the library.</p>
<h2 id="summary-concluding-thoughts">Summary &amp; concluding thoughts</h2>
<p>The main take away is declarative programming is awesome! In the case of Datalog, we can supplement expressivity by allowing extralogical predicates. This brings the syntactic order of execution problem with it, but our analysis completely eliminates this and restores the promise of declarative programming!</p>
<p>The analysis relies on computing dataflow requirements (modes) of user-defined predicates and verifying their consistency with respect to the actual bindings (adornments) of the program and query pairs.</p>
<p>We avoid inefficiency through a greedy scheduling algorithm, but we don’t sacrifice completeness. Additionally, our analysis is incremental and thus scalable to multi module programs with relative ease.</p>
<p>Here are few reasons why you might like to read the paper:</p>
<ul>
<li>understanding the mathematical foundation for modes &amp; bindings,</li>
<li>gaining insights into about an implementation (paper is effectively executable maths),</li>
<li>need more advanced examples (illustrating omitted aspects of the algorithm),</li>
<li>and looking for generalisation from Datalog to other contexts.</li>
</ul>
<p>There are number of directions this work may go. I believe the constraint-based approach of the paper can be generalised to other declarative languages which need more sophisticated modes. I firmly believe there is a fundamental link between Martelli’s semiring and dataflow in general. We didn’t discuss user-level annotations as you noticed. There are interesting design questions about an annotation language for modes that might work exploring. Finally (and a bit more abstractly), extralogical predicates are inevitable in logic programming but they are afterthoughts to clear declarative semantics. I’d like them to be first-class citizens so we can reason about them and analyse them better.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>Pass</code> in this rule is an existentially quantified variable, so there is indeed nothing that could have bound it out of the rule context.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>It is <code>bb</code> because both <code>User</code> and <code>Pass</code> appear in preceding subgoals.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>This seems to contradict what I said in <a href="#example-3">Example 3</a>, so let me clarify. In a subgoal like <code class="sourceCode prolog">not r(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)</code>, the predicate <span class="math inline"><em>r</em></span> still has <code>???</code> mode pattern. It is the negation that imposes makes <code>r</code> behave as if it has <code>+++</code> pattern.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This is a quote from a famous movie speech by the character <a href="https://en.wikipedia.org/wiki/Gordon_Gekko">Gordon Gekko</a> in <a href="https://www.rottentomatoes.com/m/wall_street">Wall Street</a>. Highly recommended.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>In the paper, we show and heavily use the fact that constraints (which are derived from modes) form a bounded partial order. We can talk about <em>principal moding</em> or <em>sub moding</em>, but they are only relevant if we have explicit annotations for modes which are not strictly necessary for safety checking and automated reordering. Perhaps another paper? Feel free to contact me if you want to discuss this more.<a href="#fnref5">↩</a></p></li>
</ol>
</div></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
