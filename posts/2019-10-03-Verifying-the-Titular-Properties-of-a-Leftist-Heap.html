<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Verifying the Titular Properties of a Leftist Heap</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on October  3, 2019
  
  
    and last updated on October  8, 2019
  
  by Mistral Contrastin
</div>

<h1>Verifying the Titular Properties of a Leftist Heap</h1>


<p class="in-which">In which my job search leads me to verify the leftist and heap properties of a leftist heap using Haskell's type-level features and to test various implementations by way of simulation using QuickCheck. We also cover much of Haskell's type-level computation features from scratch.</p>


<div class="post"><h2 id="the-story">The story</h2>
<p>I’ve made it to the final stage of my computer science PhD, you know the one
where you start looking for jobs, get yourself a copy of <a href="https://amzn.to/2Q74ckU">Cracking the Coding
Interview</a> (affiliate link), and realise that you
haven’t done much of the kind of programming that about half of the companies
expect you to do at their job interviews (and at their job interviews only).</p>
<p>At some point in the book, it says “know how to implement these data structures
by heart: dynamically sized arrays, hash tables, […], <strong>binary heaps</strong>,
[…]”. It dawned on me that I remember the heap property and the heap
interface, but not how to implement it. I was horrified when I remembered
despite conceptually being a tree, binary heaps are implemented using arrays.
Despite having used Haskell as my primary language, decided to implement it in
Ruby—my prior primary language. Some time and indexing errors later, I got it
working. Then ported it to Haskell’s using the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-ST.html"><code>ST</code>
monad</a>.
After writing <code class="sourceCode haskell"><span class="dt">STRef</span></code> one too many times, I got that working too, but
it left much to be desired. “Save the trees” yelled my terminal!</p>
<p>Finally, I consulted Dr Chris Okasaki’s <a href="https://amzn.to/34ICTAM">Purely Functional Data
Structures</a> (affiliate link). A leftist heap is one of
the first data structures discussed in the book. It has better worst-case
asymptotic complexity than the binary heap, is represented as
a tree, and doesn’t need mutation. Great! I was pleased to have a heap under my
belt that was much easier to remember and much more difficult to get its
implementation wrong.</p>
<p>Staring at it for a while (and being bored while trying to find various
substrings with various properties in linear time and constant space under an
hour over the phone), I got a burning desire to encode the titular properties
of a leftist heap using fancy types. Having listened to hundreds of people
complain about the state of type-level programming in Haskell, I found the
process to be rough around the edges, but functional (see what I did there).</p>
<h2 id="the-spiel">The spiel</h2>
<p>This brings us to the post at hand. This post is a bit long, but the upside is
there is something for everybody. Hopefully, some of the following piques your
interest:</p>
<ul>
<li>leftist heaps as a purely functional alternative to array-based binary heaps,</li>
<li>complexity analysis of operations on leftist heaps,</li>
<li>a case study on the internalist approach to verifying data structures,</li>
<li>a tutorial on most major features of type-level programming in Haskell,</li>
<li>a commentary on the ergonomics of verification using fancy types in Haskell,</li>
<li>and practical advice on avoiding pitfalls when using fancy types.</li>
</ul>
<p>Beginners beware! Type-level programming can be daunting. It certainly was for
me for a long time. I’ll attempt to explain fancy types from scratch. If you
find yourself getting confused, it’s almost certainly my fault. Just let me know
(contact details on my <a href="../">homepage</a>) and I’ll clarify the post.</p>
<h2 id="the-itinerary">The itinerary</h2>
<p>Here are the sections and what to expect from them.</p>
<ul>
<li><a href="#a-simple-heap">A simple heap</a> covers the generic heap interface through a
typeclass and a trivial instance for it. Type-level features: associated type
families;</li>
<li><a href="#a-leftist-heap">A leftist heap</a> describes a data type for leftist heaps
without using fancy types and discusses the asymptotic complexities of its
operations;</li>
<li><a href="#terms-types-and-kinds">Terms, types, and kinds</a> covers the basic entities
in modern Haskell and how they relate to each other. Type-level features:
<a href="#data-type-promotion">data type promotion</a>, <a href="#kind-polymorphism">kind
polymorphism</a>, and
<a href="#levity-polymorphism">levity polymorphism</a>;</li>
<li><a href="#verifying-the-leftist-property">Verifying the leftist property</a> explains
the data type encoding the leftist property and the implementation of its
property preserving operations. Type-level features: <a href="#generalised-algebraic-data-types">generalised algebraic
data types</a>,
<a href="#singletons-faking-dependent-types">singletons</a>, and existential types
through <a href="#heap-instance-for-safeheap">the heap instance</a>. We also reinvent
type-level <a href="#natural-numbers">natural numbers</a> and <a href="#comparing-without-forgetting">prove
theorems</a> about them using typed holes;</li>
<li><a href="#verifying-the-heap-property">Verifying the heap property</a> encodes both the
leftist and the heap properties into a data type. Most of this section is on
the property preserving merge. Type-level features: <a href="#type-families">closed type
families</a> and <a href="#propositional-equality">propositional
equality</a>. Additionally, it extends on theorem
proving and use of existential types;</li>
<li><a href="#simulating-heap-operations">Simulating heap operations</a> tests the
functional equivalence of the heap implementations in this post. We use
QuickCheck to simulate evaluation of <em>arbitrary</em> sequence of insertions and
deletions. Type-level features: <a href="#there-is-lambda-then-there-is-lambda">visible type-applications, explicit
foralls</a>, and <a href="#quickchecking-functional-equivalence">scoped type
variables</a>;</li>
<li><a href="#conclusion">Conclusion</a> acknowledges people who made this post possible and
reminds some take-aways.</li>
</ul>
<p>The exposition of the code is fragmented and out of order, but a well-organised
version of the <a href="https://github.com/madgen/verified-leftist-heap/blob/master/VerifiedLeftistHeap.hs"><strong>SOURCE
CODE</strong></a>
exists. We won’t use any libraries except
<a href="http://hackage.haskell.org/package/QuickCheck-2.13.2">QuickCheck</a>.</p>
<h1 id="a-simple-heap">A simple heap</h1>
<p>A heap is a (conceptually) tree-based data structure used to quickly access and
maintain access to the maximum or the minimum of a collection of values. It
satisfies the <em>heap property</em>, that is (for a maximum heap) the label of a node
is bigger than or equal to that of its children. The following typeclass
summarises its common operations.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Heap</span> heap <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    isEmpty, empty,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    (singleton | insert),</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    (fromList | (singleton, merge)),</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    (insert | (merge, singleton)),</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    (merge | (decompose, insert)),</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    (decompose | (findMax, deleteMax))</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    #-}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> heap</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Predicates</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  isEmpty ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Access</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  findMax ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Elem</span> heap)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  findMax <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> decompose</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Creation</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="ot">  empty ::</span> heap</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="ot">  singleton ::</span> <span class="dt">Elem</span> heap <span class="ot">-&gt;</span> heap</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  singleton <span class="ot">=</span> (<span class="ot">`insert`</span> empty)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromList ::</span> [ <span class="dt">Elem</span> heap ] <span class="ot">-&gt;</span> heap</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  fromList xs <span class="ot">=</span> <span class="co">-- O(n) for leftist heaps</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> go (<span class="fu">map</span> singleton xs) <span class="kw">of</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      [ heap ] <span class="ot">-&gt;</span> heap</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>      [ ]      <span class="ot">-&gt;</span> empty</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>      _        <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Fatal error. Did not converge to a single heap.&quot;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    go [] <span class="ot">=</span> []</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    go [ x ] <span class="ot">=</span> [ x ]</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    go (x <span class="op">:</span> y <span class="op">:</span> rest) <span class="ot">=</span> go (merge x y <span class="op">:</span> go rest)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Modification</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="ot">  insert ::</span> <span class="dt">Elem</span> heap <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> heap</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>  insert x <span class="ot">=</span> merge (singleton x)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="ot">  merge ::</span> heap <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> heap</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  heap1 <span class="ot">`merge`</span> heap2 <span class="ot">=</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> decompose heap1 <span class="kw">of</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> (heapMax, heapRest) <span class="ot">-&gt;</span> heapRest <span class="ot">`merge`</span> (heapMax <span class="ot">`insert`</span> heap2)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span>                  <span class="ot">-&gt;</span> heap2</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="ot">  decompose ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Elem</span> heap, heap)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>  decompose heap <span class="ot">=</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> (findMax heap, deleteMax heap) <span class="kw">of</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Just</span> heapMax, <span class="dt">Just</span> heapRest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (heapMax, heapRest)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Nothing</span>     , <span class="dt">Nothing</span>      ) <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Just</span> _      , <span class="dt">Nothing</span>      ) <span class="ot">-&gt;</span> <span class="fu">error</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Impossible happened. There is a max but the heap is empty.&quot;</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Nothing</span>     , <span class="dt">Just</span> _       ) <span class="ot">-&gt;</span> <span class="fu">error</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Impossible happened. Heap is non-empty but there is a max.&quot;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="ot">  deleteMax ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>  deleteMax <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> decompose</span></code></pre></div>
<p>This is a bit mouthful because many operations are inter-definable as reflected
by the <code class="sourceCode haskell"><span class="dt">MINIMAL</span></code> pragma.</p>
<p>The <code class="sourceCode haskell"><span class="dt">Elem</span></code> <em>type family</em> (enabled by <code>TypeFamilies</code> extension)
associated with <code class="sourceCode haskell"><span class="dt">Heap</span></code> gives the type of elements for a particular
instance. This is nothing but a function from types of containers to types of
their elements. We could have equally used <code>MultiParamTypeClasses</code> and
<code>FunctionalDependencies</code> extensions to establish the same container-element
relationship. I chose a type family here because we will use type families in a
moment anyway and because I think <code class="sourceCode haskell"><span class="dt">Elem</span> heap</code> has less cognitive
overhead than remembering functional dependencies between type variables.</p>
<p>Although <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">findMax</code> and <code class="sourceCode haskell">deleteMax</code> are
the most commonly used operations of <code class="sourceCode haskell"><span class="dt">Heap</span></code>, <code class="sourceCode haskell">merge</code> is the
one that we care the most about. For all data structures we’ll use as heaps
today, implementing <code class="sourceCode haskell">isEmpty</code>, <code class="sourceCode haskell">findMax</code>,
<code class="sourceCode haskell">singleton</code>, and <code class="sourceCode haskell">empty</code> are trivial. Then with
<code class="sourceCode haskell">merge</code>, we can implement <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">fromList</code>,
<code class="sourceCode haskell">decompose</code>, and <code class="sourceCode haskell">deleteMax</code>. As we see in the next section,
implementing <code class="sourceCode haskell">merge</code> and deriving the rest is not only optimal in
terms of productivity but also in terms of performance for leftist
heaps.</p>
<p>Before implementing this interface for a leftist heap, let’s look at a much
simpler instance.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> [ a ] <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> [ a ] <span class="ot">=</span> a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  isEmpty <span class="ot">=</span> <span class="fu">null</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> []</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  fromList xs <span class="ot">=</span> xs</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  insert <span class="ot">=</span> (<span class="op">:</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  merge <span class="ot">=</span> (<span class="op">&lt;&gt;</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  decompose [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  decompose xs <span class="ot">=</span> <span class="dt">Just</span> (heapMax, left <span class="op">++</span> <span class="fu">tail</span> right)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    heapMax       <span class="ot">=</span> <span class="fu">maximum</span> xs</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    (left, right) <span class="ot">=</span> <span class="fu">span</span> (<span class="op">/=</span> heapMax) xs</span></code></pre></div>
<p>This may be the easiest heap implementation. Insertion is <span class="math inline">\(O(1)\)</span>, merging is
<span class="math inline">\(O(n)\)</span>, conversion from a list is <span class="math inline">\(O(1)\)</span>, and decomposing (and subsequently
finding and deleting the maximum) is <span class="math inline">\(O(n)\)</span>. If it wasn’t for that last <span class="math inline">\(O(n)\)</span>,
this would have been a perfectly fine heap implementation, alas here we are.</p>
<p>This implementation is obviously correct, thus any other correct heap
implementation should be <em>functionally equivalent</em> to it. This means performing
the same operations on two empty heaps of different implementations should
result in two heaps with the same maximum. Hence, this simple heap
implementation is perfect for <a href="#simulating-heap-operations">testing other implementations’
correctness</a>.</p>
<h1 id="a-leftist-heap">A leftist heap</h1>
<p>Since we’ll go through the trouble of implementing leftist heaps multiple
times, let’s spend a second on comparing it to array-based binary heaps.</p>
<p>Why bother with the leftist heap? It is persistent (hence better suited for
multi-threaded computation), both conceptually and implementation-wise a tree,
and more resilient against off-by-one errors. Why bother with the array-based
binary heap? Better average case complexity of insertions; its operations are in
place; and it probably performs better in practice because of good locality of
reference (this is a hunch and I’d like to be proven wrong).</p>
<p>We can also look at their complexities more concretely. Leftist heaps have
<span class="math inline">\(O(\lg{n})\)</span> worst-case complexity for insertion and deleting the maximum, while
maintaining <span class="math inline">\(O(1)\)</span> complexity for finding the maximum. Building a heap out of a
collection is <span class="math inline">\(O(n)\)</span>. So far we’re on par with binary heaps. But we can do one
better. While merging binary heaps is <span class="math inline">\(O(n)\)</span>, it’s only <span class="math inline">\(O(\lg{n})\)</span> for leftist
heaps. In fact, this is why insertion and deletion are <span class="math inline">\(O(\lg{n})\)</span>.</p>
<h2 id="the-data-structure-and-its-properties">The data structure and its properties</h2>
<p>A leftist heap is as a tree and we implement it as such.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LeftistHeap</span> a <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">|</span> <span class="dt">Node</span> a <span class="dt">Int</span> (<span class="dt">LeftistHeap</span> a) (<span class="dt">LeftistHeap</span> a)</span></code></pre></div>
<p>The tree is standard except for the <code class="sourceCode haskell"><span class="dt">Int</span></code> parameter. This is the
<em>rank</em> of the <code class="sourceCode haskell"><span class="dt">Node</span></code>, which is the least distance to a
<code class="sourceCode haskell"><span class="dt">Leaf</span></code>. The rank of a <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is 0 and the rank of a
<code class="sourceCode haskell"><span class="dt">Node</span></code> is one more than the minimum of its children’s ranks.</p>
<p>Let’s briefly look at the relationship between the size of a tree and its rank.</p>
<p>A first question is how many elements there needs to be in the tree if its rank
is <span class="math inline">\(R\)</span>? If the rank of a tree is <span class="math inline">\(R\)</span>, then it must be the case that each path
from the root has <span class="math inline">\(R\)</span> <code class="sourceCode haskell"><span class="dt">Node</span></code>s, otherwise the rank of the tree would be
fewer. This means the tree has at least <span class="math inline">\(2^{R} - 1\)</span> elements.</p>
<p>Then the followup question is, if a tree has <span class="math inline">\(N\)</span> elements, what is its maximum
rank? Well, we know that the rank imposes a lower bound on the tree size, so
conversely, the tree size should impose a maximum on the rank. If <span class="math inline">\(R\)</span> is the
maximum rank, we have <span class="math inline">\(2^{R} - 1 \leq N \lt 2^{R + 1} - 1\)</span>, so <span class="math inline">\(R \leq \lg{(N + 1)} &lt; R + 1\)</span>. Hence, <span class="math inline">\(\left\lfloor{\lg{(N + 1)}} \right\rfloor\)</span> is the desired maximum.</p>
<p>The leftist heap has the <em>leftist property</em>. In short, the shortest path from
any node to a <code class="sourceCode haskell"><span class="dt">Leaf</span></code> must be the right-most one. Since each subtree in
a leftist heap is also a leftist heap, the rank of any left child is at least as
big as that of the right, hence the name.</p>
<p>How can we refine the earlier calculation about the maximum rank for leftist
heaps? The distance between the root and the right-most <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is at
most <span class="math inline">\(\left\lfloor{\lg{(N + 1)}} \right\rfloor\)</span> if the leftist heap has <span class="math inline">\(N\)</span>
elements in it. This is the critical information we’ll use to derive the
complexity of the <code class="sourceCode haskell">merge</code> operation.</p>
<p>Accessing the rank is handy, so let’s create a typeclass for it.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasRank</span> a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">RankType</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  rank ::</span> a <span class="ot">-&gt;</span> <span class="dt">RankType</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasRank</span> (<span class="dt">LeftistHeap</span> a) <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">RankType</span> (<span class="dt">LeftistHeap</span> a) <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  rank <span class="dt">Leaf</span>           <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  rank (<span class="dt">Node</span> _ r _ _) <span class="ot">=</span> r</span></code></pre></div>
<p>Here is the <code class="sourceCode haskell"><span class="dt">Heap</span></code> instance for the <code class="sourceCode haskell"><span class="dt">LeftistHeap</span></code>. The
<code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint is for the heap property. The element of a
<code class="sourceCode haskell"><span class="dt">LeftistHeap</span> a</code> is <code class="sourceCode haskell">a</code>. Its operations are implemented over
the next two sections.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">LeftistHeap</span> a) <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">LeftistHeap</span> a) <span class="ot">=</span> a</span></code></pre></div>
<h2 id="merging-two-heaps">Merging two heaps</h2>
<p>Let’s tackle the most important operation head-on.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>merge <span class="dt">Leaf</span> heap <span class="ot">=</span> heap</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>merge heap <span class="dt">Leaf</span> <span class="ot">=</span> heap</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>merge h1<span class="op">@</span>(<span class="dt">Node</span> x _ left1 right1)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      h2<span class="op">@</span>(<span class="dt">Node</span> y _ left2 right2) <span class="ot">=</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> x <span class="op">&gt;</span> y</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> mkNode x left1 (merge right1 h2)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> mkNode y left2 (merge right2 h1)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  mkNode a heap1 heap2 <span class="ot">=</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> rank heap1 <span class="op">&lt;=</span> rank heap2</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="dt">Node</span> a (rank heap1 <span class="op">+</span> <span class="dv">1</span>) heap2 heap1</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="dt">Node</span> a (rank heap2 <span class="op">+</span> <span class="dv">1</span>) heap1 heap2</span></code></pre></div>
<p>The base cases are simple as <code class="sourceCode haskell"><span class="dt">Leaf</span></code> acts as the identity element for
<code class="sourceCode haskell">merge</code>.</p>
<p>In the inductive case, we walk over the right-most paths of the input heaps. You
can see this in the recursive calls; they never touch the left children.</p>
<p>To preserve the heap property, we recurse on the right child of the argument
heap with the bigger label.</p>
<p>To build a new node, we use <code class="sourceCode haskell">mkNode</code> helper rather than
<code class="sourceCode haskell"><span class="dt">Node</span></code> constructor directly. The helper does two things. First, it
makes the child with the lowest rank the right child. Since the arguments to
<code class="sourceCode haskell">mkNode</code> are leftist heaps themselves, this flip ensures the
right-most path to <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is still the shortest. Second, it calculates
the new rank which is one more than the rank of the right child.</p>
<p>Now what is the complexity of this? At each recursive call we potentially do a
flip, increase the rank, and construct a tree node, these are all constant time
operations. So the question is the number of recursive calls. If the leftist
heaps being merged have <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> elements inside, we know their right-most
paths are at most length <span class="math inline">\(\left\lfloor lg{(L + 1)}\right\rfloor\)</span> and
<span class="math inline">\(\left\lfloor lg{(R + 1)}\right\rfloor\)</span> respectively. Hence, we at most do
<span class="math inline">\(\left\lfloor\lg{(L + 1)} + \lg{(R + 1)}\right\rfloor\)</span> calls. So the overall
complexity is <span class="math inline">\(O(\lg{(L \times R)})\)</span> which is a subset of <span class="math inline">\(O(\lg{(L + R)})\)</span> (can
you see why?). In short, the merge operation is logarithmic in the size of the
output.</p>
<p>This is not where the beauty of <code class="sourceCode haskell">merge</code> ends. Recall that most leftist
heap elements live outside the right-most path. Then since we only recurse over
the right-most path, we never touch the trees where most elements live. We just
move them around. In a purely functional language, this means the output tree
does not have to allocate new memory for those trees, it can just share them
with the input heaps.</p>
<h2 id="every-other-operation">Every other operation</h2>
<p>The remaining operations needed to satisfy the typeclass are as follows.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>isEmpty <span class="dt">Leaf</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>isEmpty _    <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Leaf</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>singleton x <span class="ot">=</span> <span class="dt">Node</span> x <span class="dv">1</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>decompose <span class="dt">Leaf</span>                  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>decompose (<span class="dt">Node</span> x _ left right) <span class="ot">=</span> <span class="dt">Just</span> (x, merge left right)</span></code></pre></div>
<p>From <code class="sourceCode haskell">merge</code> follows everything else. Maximum is maintained at the
root, so accessing it is easy. The <code class="sourceCode haskell">decompose</code> operation returns the
maximum along with the rest of the heap with the maximum removed by merging the
two children of the root. Insertion (the default implementation) creates a
singleton heap out of the inserted label and merges it into the heap.</p>
<p>Since <code class="sourceCode haskell">merge</code> has logarithmic complexity, so does <code class="sourceCode haskell">insert</code>
and <code class="sourceCode haskell">deleteMax</code>. Since we store the maximum at the root,
<code class="sourceCode haskell">findMax</code> runs in constant time.</p>
<p>Conversion from a list is more interesting. The obvious implementation is to
fold over the list of elements and insert them into the heap, this turns out not
to be the most efficient way. If we instead turn each element into a singleton
heap and repeatedly merge two heaps at a time (with multiple passes) until one
heap is left, conversion happens in linear time. The following default
implementation does exactly that.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> [ <span class="dt">Elem</span> heap ] <span class="ot">-&gt;</span> heap</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>fromList xs <span class="ot">=</span> <span class="co">-- O(n) for leftist heaps</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> go (<span class="fu">map</span> singleton xs) <span class="kw">of</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    [ heap ] <span class="ot">-&gt;</span> heap</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    [ ]      <span class="ot">-&gt;</span> empty</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    _        <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Impossible. Did not converge to a single heap.&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  go [] <span class="ot">=</span> []</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  go [ x ] <span class="ot">=</span> [ x ]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  go (x <span class="op">:</span> y <span class="op">:</span> rest) <span class="ot">=</span> go (merge x y <span class="op">:</span> go rest)</span></code></pre></div>
<p>Why does this run in linear time? Assume for simplicity that there are <span class="math inline">\(2^R\)</span>
elements. Then in the first pass, we do <span class="math inline">\(2^{R-1}\)</span> <span class="math inline">\(O(\lg{2})\)</span> operations. In the
next pass, we do <span class="math inline">\(2^{R-2}\)</span> <span class="math inline">\(O(\lg{4})\)</span>, then <span class="math inline">\(2^{R-3}\)</span> <span class="math inline">\(O(\lg{8})\)</span> operations
and so on. So the overall complexity is <span class="math inline">\(O(\sum^{R}_{i = 1}{(\lg{2^i}) 2^{R-i}}\,)\)</span> which is <span class="math inline">\(O(\sum^{R}_{i = 1}{i \; 2^{R-i}}\,)\)</span> and that is
<span class="math inline">\(O(2^{R})\)</span>. That is the number of elements we started with, so conversion from a
list is done in linear time.</p>
<h1 id="terms-types-and-kinds">Terms, types, and kinds</h1>
<p>Before doing verification with fancy types, we need to understand terms, types,
and kinds. Here’s the gist: all terms have types, all types have kinds, and
there is no distinction between types and kinds since GHC 8.0, but terms and
types (for now) occupy different realms.</p>
<p>For example, just as you can say <code class="sourceCode haskell"><span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span></code>, you can also say <code class="sourceCode haskell"><span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (<code class="sourceCode haskell"><span class="op">*</span></code> is a deprecated
synonym of <code class="sourceCode haskell"><span class="dt">Type</span></code>; import <code class="sourceCode haskell"><span class="dt">Data.Kind</span></code> for <code class="sourceCode haskell"><span class="dt">Type</span></code>).
We can read these as “<code class="sourceCode haskell"><span class="dv">42</span></code> is an <code class="sourceCode haskell"><span class="dt">Int</span></code>”, “<code class="sourceCode haskell"><span class="dt">Int</span></code> is
a <code class="sourceCode haskell"><span class="dt">Type</span></code>”, and “<code class="sourceCode haskell"><span class="dt">Type</span></code> is a <code class="sourceCode haskell"><span class="dt">Type</span></code>” (yup, not a
typo).</p>
<p>Just as you can use <code>:type</code> or <code>:t</code> learn the type of a term in <code>ghci</code>, you can
use <code>:k</code> or <code>:kind</code> to learn the kind of a type.</p>
<p>We now look at types and kinds in more detail. It may be too much information to
soak in at once, but the broad-strokes should be enough for this post. For a
broader overview of the subject, see Diogo Castro’s amazing <a href="https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/">blog
post</a>.
More generally, one can get away without an in-depth understanding of these and
still be able to verify data structures. But then we’d be relying on GHC to yell
at us when certain extensions are missing and not understand why we’re being
yelled at.</p>
<h2 id="proofs-and-contradictions">Proofs and contradictions</h2>
<p>Famously, Ludwig Wittgenstein wasn’t terribly concerned about inconsistencies in
mathematics as most were, including Alan Turing. They even have a <a href="https://www.britishwittgensteinsociety.org/wp-content/uploads/documents/lectures/Turing-and-Wittgenstein-on-Logic-and-Mathematics.pdf">direct
exchange</a>
on this subject. Surprisingly, Haskell’s type system seems to agree more with
Wittgenstein than with Turing.</p>
<p>If <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> makes you uncomfortable, you’re right, it is
problematic and it leads to <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russel’s
paradox</a>. This is one reason
people don’t like type-level programming in Haskell. It means as a proof system,
Haskell’s type system is inconsistent. What that means is that <em>we don’t have
the ability to tell the truth</em>. The expectation, due to the <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard
correspondance</a>, is
that if we have a type corresponding to some logical statement, a term for that
type (if it exists) is a proof. Inconsistency means, we can have terms that are
not valid proofs of the statement, but satisfy the type checker. In particular,
<code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> leads to such menace.</p>
<p>That said, since Haskell already has <code class="sourceCode haskell"><span class="kw">let</span> x <span class="ot">=</span> x <span class="kw">in</span> x</code>,
<code class="sourceCode haskell"><span class="fu">undefined</span></code>, and <code class="sourceCode haskell"><span class="fu">error</span> <span class="st">&quot;QED&quot;</span></code> satisfying types of
propositions, we didn’t have the ability to tell the truth to start with. Hence,
we are not worse off. At least, this is the argument in Prof. Stephanie
Weirich’s <a href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a> as
well as <a href="https://downloads.haskell.org/~ghc/8.8.1/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type">the GHC
documentation</a>.</p>
<p>One might think existing flaws don’t justify adding new ways to break a system.
Ordinarily, that’s right, but contradictions are infectious. As soon as there is
a little crack, it is difficult to contain. So the marginal harm done by <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> is less than expected.</p>
<p>There are <a href="https://en.wikipedia.org/wiki/Paraconsistent_logic"><em>paraconsistent
logics</em></a> limiting the harm
done by inconsistencies, but they are not employed in type systems as far as I
know.</p>
<p>To sum up, Haskell proofs are partial. If a term (proof) corresponding to a type
(proposition) compiles, one of two things happened. The term is a valid proof or
its evaluation will diverge. By contrast, Agda and Idris proofs are always
terminating and are thus valid proofs as long as the type checker says so (up to
compiler bugs). Hence, despite the syntactic similarity, you should have more
faith in the latter.</p>
<h2 id="why-is-type-a-misnomer">Why is <code class="sourceCode haskell"><span class="dt">Type</span></code> a misnomer?</h2>
<p>The kind <code class="sourceCode haskell"><span class="dt">Type</span></code> has a very confusing name. It should really be named
<code class="sourceCode haskell"><span class="dt">LiftedType</span></code>. Let’s understand why.</p>
<p>It has two important features. The term <code class="sourceCode haskell"><span class="fu">undefined</span></code> (or <span class="math inline">\(\bot\)</span> in
academic papers) is a valid term for any type with kind <code class="sourceCode haskell"><span class="dt">Type</span></code>. This
makes <code>Type</code> the kind of <em>lifted</em> types. Consequently, all of these types are
<em>inhabited</em>.</p>
<p>The GHC manual (until recently) called <code class="sourceCode haskell"><span class="dt">Type</span></code> “the kind of types with
values”. This is not true. If we enable the <code>MagicHash</code> extension and import
<code class="sourceCode haskell"><span class="dt">GHC.Prim</span></code>, we get access to unlifted types such as <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>.
<code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> definitely has values as witnessed by <code class="sourceCode haskell"><span class="dv">42</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">Int</span><span class="op">#</span></code>,
but when we query <code class="sourceCode haskell"><span class="op">:</span>k <span class="dt">Int</span><span class="op">#</span><span class="ot"> ::</span> <span class="dt">Type</span></code>, we get an error saying “Expecting
a lifted type, but <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> is unlifted”. So there are inhabited types
without kind <code class="sourceCode haskell"><span class="dt">Type</span></code>.</p>
<p>It is also wrong to say that <code class="sourceCode haskell"><span class="dt">Type</span></code> is the kind of types that
definitely has inhabitants. Once again the kind of <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> is <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> and <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> is the only type of that kind. We
already know it has inhabitants. In fact, in a sense <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> is
superior because <code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Void</span></code> creates a type <code class="sourceCode haskell"><span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span></code>
where the only inhabitants are degenerate such as <code class="sourceCode haskell"><span class="fu">error</span> <span class="st">&quot;Oops!&quot;</span></code> and
<code class="sourceCode haskell"><span class="fu">undefined</span></code>. Neither of these are proper values. <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> can claim to be <em>a</em> kind of types that has non-degenerate
inhabitants.</p>
<p>As a final piece of evidence about why <code class="sourceCode haskell"><span class="dt">Type</span></code> is a bad name, you can
consult <code class="sourceCode haskell"><span class="dt">GHC.Types</span></code> which defines the kind <code class="sourceCode haskell"><span class="dt">Type</span></code> as <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'LiftedRep</span></code>. Even GHC admits that <code class="sourceCode haskell"><span class="dt">Type</span></code> is more specific
than what the name implies.</p>
<p>So <code class="sourceCode haskell"><span class="dt">Type</span></code> is a bad name because of non-<code class="sourceCode haskell"><span class="dt">Type</span></code> types! We’ve
already seen <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>,
let’s find some more.</p>
<h2 id="type-constructors"><code class="sourceCode haskell"><span class="dt">Type</span></code> constructors</h2>
<p><code class="sourceCode haskell"><span class="dt">Maybe</span></code> takes a <code class="sourceCode haskell"><span class="dt">Type</span></code> and returns a <code class="sourceCode haskell"><span class="dt">Type</span></code>. How
about <code class="sourceCode haskell"><span class="dt">Either</span></code>? It takes two <code class="sourceCode haskell"><span class="dt">Type</span></code>s and returns a
<code class="sourceCode haskell"><span class="dt">Type</span></code>. You can say they are type-level functions and you wouldn’t be
wrong, but we can be more specific. We can say that <code class="sourceCode haskell"><span class="dt">Maybe</span></code> and
<code class="sourceCode haskell"><span class="dt">Either</span></code> construct <code class="sourceCode haskell"><span class="dt">Type</span></code>s just like <code class="sourceCode haskell">(<span class="op">:</span>)</code> and
<code class="sourceCode haskell">[]</code> at the term level.</p>
<p>Are <code class="sourceCode haskell"><span class="dt">Maybe</span></code> and <code class="sourceCode haskell"><span class="dt">Either</span></code> types themselves? They are types
but not <code class="sourceCode haskell"><span class="dt">Type</span></code>s. Asking <code>ghci</code> reveals that <code class="sourceCode haskell"><span class="dt">Maybe</span></code> has
kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">Either</span></code> has kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code>.</p>
<p><code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> is not the same thing as <code class="sourceCode haskell"><span class="dt">Type</span></code>, but (here is
the confusing part) <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> has the kind <code class="sourceCode haskell"><span class="dt">Type</span></code>. Get
your head around that! If you can’t, that’s fine. The intuition is that types
and kinds are one and the same, then so are the function arrow <code class="sourceCode haskell">(<span class="ot">-&gt;</span>)</code>
and kind arrow <code class="sourceCode haskell">(<span class="ot">-&gt;</span>)</code>. A more concrete explanation will follow once we
cover <a href="#levity-polymorphism">levity polymorphism</a>. One implication of <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> is that, it is inhabited. For example, <code class="sourceCode haskell"><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> type checks.</p>
<p>We have <code class="sourceCode haskell"><span class="dt">Type</span></code>s; we have things that construct <code class="sourceCode haskell"><span class="dt">Type</span></code>s; and
we have unlifted types such as <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>. What else?</p>
<h2 id="data-type-promotion">Data type promotion</h2>
<p>So far, we’ve only seen inhabited types. <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>
are obviously examples, but <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> is also inhabited since
that too has kind <code class="sourceCode haskell"><span class="dt">Type</span></code>.</p>
<p>Emphasising inhabitation as a property implies that there must be some
uninhabited kinds. In fact, these are the pillars of theorem proving and
property encoding in Haskell.</p>
<p>Consider the following <code class="sourceCode haskell"><span class="dt">List</span></code> declaration.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>In vanilla Haskell, this generates a type <code class="sourceCode haskell"><span class="dt">List</span></code> and two data
constructors <code class="sourceCode haskell"><span class="dt">Nil</span></code> and <code class="sourceCode haskell"><span class="dt">Cons</span></code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</span></code></pre></div>
<p>With the <code>DataKinds</code> extension, you also get the following.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">'Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">'Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</span></code></pre></div>
<p>Despite looking pretty similar, these are different beasts. Since there is no
distinction between types and kinds, the type constructor <code class="sourceCode haskell"><span class="dt">List</span></code> is
also a kind constructor. Then, <code class="sourceCode haskell"><span class="dt">'Nil</span></code> and <code class="sourceCode haskell"><span class="dt">'Cons</span></code> are type
constructors, but they are not <code class="sourceCode haskell"><span class="dt">Type</span></code> constructors, they are <code class="sourceCode haskell"><span class="dt">List</span> a</code> constructors! All promoted types are automatically uninhabited. So
there is no term <code class="sourceCode haskell">t</code> with <code class="sourceCode haskell"><span class="ot">t ::</span> <span class="dt">'Cons</span> <span class="dt">Int</span> <span class="dt">'Nil</span></code>.</p>
<p>This promotion feature alone spawns multiple reasons why people do not like
fancy types in Haskell:</p>
<ol type="1">
<li><p>The <code>'</code> prefix of promoted type-constructors is optional, but terms and
types are completely separate. So when I type <code class="sourceCode haskell"><span class="dt">Nil</span></code>, GHC figures out
whether it is a term or a type constructor depending on the context. In the
absence of <code>'</code>, we need to disambiguate ourselves.</p></li>
<li><p>The built-in list type <code class="sourceCode haskell">[a]</code> is automatically promoted. This
means there is <code class="sourceCode haskell">[]</code>, the equivalent of <code class="sourceCode haskell"><span class="dt">Nil</span></code>. There is
<code class="sourceCode haskell">[]</code>, the type and kind constructor equivalent to <code class="sourceCode haskell"><span class="dt">List</span></code>.
Then there is <code class="sourceCode haskell">'[]</code>, the type constructor equivalent to
<code class="sourceCode haskell"><span class="dt">'Nil</span></code>. Remember that <code>'</code> is optional. So when I use <code class="sourceCode haskell">[]</code>,
we don’t know, if it is the type constructor <code class="sourceCode haskell"><span class="dt">List</span></code> or the type
constructor <code class="sourceCode haskell"><span class="dt">Nil</span></code>. A similar situation occurs with tuples, where the
term and the type share similar syntax.</p></li>
</ol>
<p>Note that this is the improved state of affairs. Kinds and types used to be
separated and there was also a separate kind <code class="sourceCode haskell">[]</code> with sort (the
classification of kinds) <code class="sourceCode haskell"><span class="dt">BOX</span></code>.</p>
<p>Nevertheless, promoted types are a blessing. They act as indices to other data
types and help encoding various properties at type level. We come back to this
while introducing GADTs.</p>
<h2 id="kind-polymorphism">Kind polymorphism</h2>
<p>Just as there are polymorphic types such as <code class="sourceCode haskell">[a] <span class="ot">-&gt;</span> [a]</code>, there are
also polymorphic kinds. In fact, <code class="sourceCode haskell"><span class="dt">'Cons</span></code> has kind <code class="sourceCode haskell">a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</code> where <code class="sourceCode haskell">a</code> is a kind variable. We can see this in <code>ghci</code>.</p>
<p>The kind variable <code class="sourceCode haskell">a</code> can be <code class="sourceCode haskell"><span class="dt">Type</span></code>,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">'Cons</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">'Cons</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Type</span></span></code></pre></div>
<p>Or it can be the kind of a type constructor such as <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">'Cons</span> <span class="dt">Maybe</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">'Cons</span> <span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">List</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)'</span></code></pre></div>
<p>We can also use a promoted kind such as <code class="sourceCode haskell"><span class="dt">List</span> a</code>, which results in
another kind polymorphic type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">'Cons</span> <span class="dt">'Nil</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">'Cons</span> <span class="dt">'Nil</span><span class="ot"> ::</span> <span class="dt">List</span> (<span class="dt">List</span> a) <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">List</span> a)</span></code></pre></div>
<h2 id="levity-polymorphism">Levity polymorphism</h2>
<p>The distinction between types with and without inhabitants stand on solid ground
in GHC and leads to beautiful generalisations over types that have inhabitants.
We now explore that.</p>
<p>This section consolidates the previous discussions of type habitation. If you’re
solely interested in verification, you can skip it.</p>
<p>What is the kind of the <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor <code class="sourceCode haskell"><span class="dt">List</span></code>?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">List</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>The return kind makes sense, it’s a <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor after all, but
why the input kind <code class="sourceCode haskell"><span class="dt">Type</span></code>? Since <code class="sourceCode haskell"><span class="dt">Cons</span></code>’s first parameter
has type <code class="sourceCode haskell">a</code>, constructing a term <code class="sourceCode haskell"><span class="dt">Cons</span> x xs</code> necessitates a
term <code class="sourceCode haskell"><span class="ot">x ::</span> a</code>, hence <code class="sourceCode haskell">a</code> must be a type with kind
<code class="sourceCode haskell"><span class="dt">Type</span></code>.</p>
<p>Hopefully, my rant about <code class="sourceCode haskell"><span class="dt">Type</span></code> being a misnomer made you doubt the
last statement. What about <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>? Since <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> has
inhabitants, by the reasoning above <code class="sourceCode haskell">a</code> can also be <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code>.
More generally, we want <code class="sourceCode haskell">a</code> to be a type that has a runtime
representation.</p>
<p>You remember <code class="sourceCode haskell"><span class="dt">TYPE</span></code>? The kind that spawns <code class="sourceCode haskell"><span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code>. Let see what kind it has.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>k <span class="dt">TYPE</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">TYPE</span><span class="ot"> ::</span> <span class="dt">RuntimeRep</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>Aha! <code class="sourceCode haskell"><span class="dt">TYPE</span></code> constructs things that have runtime representations. So we
want the type variable of <code class="sourceCode haskell"><span class="dt">List</span></code> to have kind <code class="sourceCode haskell"><span class="dt">TYPE</span> rep</code>, so
that it ranges over everything that has a runtime representation. This idea of
abstracting over runtime representations is called <em>levity polymorphism</em>.</p>
<p>But why doesn’t GHC infer that as the kind of <code class="sourceCode haskell">a</code>? Let’s try declaring
a levity polymorphic <code class="sourceCode haskell"><span class="dt">List</span></code> explicitly.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">List</span> (<span class="ot">a ::</span> <span class="dt">TYPE</span> rep) <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<pre><code>A levity-polymorphic type is not allowed here:
  Type: a
  Kind: TYPE rep</code></pre>
<p>The reason this doesn’t work and why GHC defaults <code class="sourceCode haskell">a</code> to
<code class="sourceCode haskell"><span class="dt">Type</span></code> is because if we want to create a data type, we need to know
its runtime representation in advance to lay down the data while generating
code. For example, <code class="sourceCode haskell"><span class="dt">Int</span><span class="op">#</span></code> requires 32 bits but <code class="sourceCode haskell"><span class="dt">Int</span></code>
requires a pointer to a thunk, hence 64 bits. Unless you know how big the data
is you can’t generate the code (at least not without introducing runtime code
generation or indirection which defeats the purpose of unlifted types).</p>
<p>More generally, <a href="https://cs.brynmawr.edu/~rae/papers/2017/levity/levity.pdf">the paper introducing levity
polymorphism</a> has
the following maxim for its usage:</p>
<blockquote>
<p>Never move or store a levity-polymorphic value.</p>
</blockquote>
<p>This rules out making a function as simple as <code class="sourceCode haskell"><span class="fu">id</span></code> levity polymorphic
because it moves values.</p>
<p>This raises the question, what can be levity polymorphic? The classic example is
<code class="sourceCode haskell"><span class="fu">error</span></code>. It has type <code class="sourceCode haskell"><span class="dt">String</span> <span class="ot">-&gt;</span> a</code>, so <code class="sourceCode haskell">a</code> needs
to be runtime representable. It neither stores nor moves whatever <code class="sourceCode haskell">a</code>
is. Hence, it can be and is levity polymorphic in GHC:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">error</span><span class="ot"> ::</span> <span class="kw">forall</span> (<span class="ot">rep ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">a ::</span> <span class="dt">TYPE</span> rep)<span class="op">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>You need <code>-fprint-explicit-runtime-reps</code> flag and the <code>+v</code> option to <code>:t</code> to get
the signature.</p>
<pre><code>&gt; :set -fprint-explicit-runtime-reps
&gt; :t +v error</code></pre>
<p>Let’s look at something more interesting. What is the kind of the function type
constructor <code class="sourceCode haskell">(<span class="ot">-&gt;</span>)</code>?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(-&gt;) ::</span> <span class="kw">forall</span> {<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>} {<span class="ot">s ::</span> <span class="dt">RuntimeRep</span>}<span class="op">.</span>  <span class="dt">TYPE</span> r <span class="ot">-&gt;</span> <span class="dt">TYPE</span> s <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>This shows why <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> has inhabitants. It is because
<code class="sourceCode haskell">(<span class="ot">-&gt;</span>)</code> is a <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor. More importantly, it shows
that when we write a function between lifted and unlifted data types, we are in
fact using the same arrow rather than syntactic magic.</p>
<h2 id="inhabitable-out-of-uninhabitable">Inhabitable out of uninhabitable</h2>
<p>What is the kind of the following data type?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyProxy</span> a <span class="ot">=</span> <span class="dt">MkMyProxy</span></span></code></pre></div>
<p>If we ask <code>ghci</code>, we get <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> again. However, this time
<code class="sourceCode haskell">a</code> does not appear as a type parameter to the sole constructor of
<code class="sourceCode haskell"><span class="dt">MyProxy</span></code>, so there is no reason for it to have a runtime
representation. In principle, the type argument to <code class="sourceCode haskell"><span class="dt">MyProxy</span></code> can be
<em>anything</em>. This sounds kind polymorphic.</p>
<p>GHC, by default, assumes that the type variables of a type constructor have the
kind <code class="sourceCode haskell"><span class="dt">Type</span></code> even if they can be more generic. If you turn on the
<code>PolyKinds</code> extension, GHC correctly infers the kind <code class="sourceCode haskell">k <span class="ot">-&gt;</span> <span class="dt">Type</span></code> to
<code class="sourceCode haskell"><span class="dt">Proxy</span></code>, where <code class="sourceCode haskell">k</code> is a kind variable.</p>
<p>This is nice because it is general, but also unmotivated at the moment because
we haven’t yet made any use of poly-kindedness.
<a href="#propositional-equality">Later</a>, we define a poly-kinded equality type
illustrating the utility of kind polymorphism.</p>
<h2 id="summary">Summary</h2>
<p>Haskell is slowly evolving into a practical language that unifies terms and
types. We are not quite there yet and the gradual transition creates some
interesting and tough-to-wrap-your-head-around language concepts. This section
gives a bird’s-eye view of these concepts that we shall use as building blocks
of useful type-level programming.</p>
<h1 id="verifying-the-leftist-property">Verifying the leftist property</h1>
<p>Let’s encode the leftist property in a data type. That is, we will ensure that
each the rank of each right child of a node is less than or equal to the rank of
its left child. This necessitates access to ranks at the type-level. Previously,
we used <code class="sourceCode haskell"><span class="dt">Int</span></code> for ranks, but ranks are really just natural numbers.</p>
<p>We have two (main) options for type-level naturals:</p>
<ol type="1">
<li>importing <code class="sourceCode haskell"><span class="dt">GHC.TypeLits</span></code>, which uses compiler magic to define a
<code class="sourceCode haskell"><span class="dt">Nat</span></code> kind</li>
<li>or defining a <code class="sourceCode haskell"><span class="dt">Nat</span></code> kind inductively from scratch.</li>
</ol>
<p>The advantage of (1) is it is efficient and we get to use numeric literals such
as <code class="sourceCode haskell"><span class="dv">42</span></code>. The advantage of (2) is that it is not compiler magic and we
get to see how theorem proving works in action. Hence, we’ll do (2).</p>
<p>If you reproduce this implementation using (1), you should probably use <a href="http://hackage.haskell.org/package/singletons">the
<code>singletons</code> library</a> to fake
dependent types and the fantastic GHC type-checker plugin
<a href="http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7"><code>ghc-typelits-natnormalise</code></a>
to use arithmetic properties of natural numbers. Because type-level naturals are
not inductively defined, we can’t do the kind of proofs that dependently-typed
languages are good at. Thus, we rely on external solvers.</p>
<p>Here’s the plan: reinvent natural numbers and <span class="math inline">\(\leq\)</span>; use those to define a data
type that makes non-leftist heaps illegal; attempt and fail to define
<code class="sourceCode haskell">merge</code>; go prove some properties about natural numbers; and finally
succeed at implementing <code class="sourceCode haskell">merge</code>. Ready? It will be fun; I promise.</p>
<h2 id="natural-numbers">Natural numbers</h2>
<p>We need the type-level natural numbers and <span class="math inline">\(\leq\)</span> relation between them.
Let’s start with naturals.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>This gives us a type and a kind <code class="sourceCode haskell"><span class="dt">Nat</span></code>, data constructors <code class="sourceCode haskell"><span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Nat</span></code> and <code class="sourceCode haskell"><span class="dt">S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></code>, and type constructors <code class="sourceCode haskell"><span class="dt">'Z</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></code> and <code class="sourceCode haskell"><span class="dt">'S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></code>.</p>
<h3 id="generalised-algebraic-data-types">Generalised algebraic data types</h3>
<p>Type-level naturals were pretty easy. Next, we need to define the <span class="math inline">\(\leq\)</span>
relation using generalised algebraic data types (GADTs) enabled via <code>GADTs</code>
extension. However, since <span class="math inline">\(\leq\)</span> is a mean first example for GADTs, we start
with natural numbers that remember whether they are zero or not at the type
level.</p>
<p>GADTs provide an alternative syntax for declaring data types and the ability to
discriminate types based on constructors. The <code class="sourceCode haskell"><span class="dt">AnotherNat</span></code> data type
in GADT syntax below is exactly the same as <code class="sourceCode haskell"><span class="dt">Nat</span></code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AnotherNat</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AZ</span><span class="ot"> ::</span>               <span class="dt">AnotherNat</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AS</span><span class="ot"> ::</span> <span class="dt">AnotherNat</span> <span class="ot">-&gt;</span> <span class="dt">AnotherNat</span></span></code></pre></div>
<p>The (boring) return types of constructors are now explicit. GADTs shine when the
constructor choice affects the return type. Consider a data type for natural
numbers encoding zeroness of a natural.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Zeroness</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">NonZero</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TaggedNat</span><span class="ot"> ::</span> <span class="dt">Zeroness</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TZ</span><span class="ot"> ::</span>                <span class="dt">TaggedNat</span> <span class="dt">'Zero</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TS</span><span class="ot"> ::</span> <span class="dt">TaggedNat</span> a <span class="ot">-&gt;</span> <span class="dt">TaggedNat</span> <span class="dt">'NonZero</span></span></code></pre></div>
<p>This says if a term is constructed using <code class="sourceCode haskell"><span class="dt">TZ</span></code>, we have a
<code class="sourceCode haskell"><span class="dt">'Zero</span></code> natural. But if it is constructed with <code class="sourceCode haskell"><span class="dt">TS</span></code> instead,
regardless the natural number being succeeded, we have a <code class="sourceCode haskell"><span class="dt">'NonZero</span></code>
natural number.</p>
<p>With this we can write a total function a <code class="sourceCode haskell"><span class="fu">div</span><span class="ot"> ::</span> <span class="dt">TaggedNat</span> a <span class="ot">-&gt;</span> <span class="dt">TaggedNat</span> <span class="dt">'NonZero</span> <span class="ot">-&gt;</span> <span class="dt">TaggedNat</span> b</code> and the compiler will complain every time we
try to divide by zero.</p>
<p>Now if we implement <code class="sourceCode haskell"><span class="fu">div</span></code>, it is tempting to be a good developer and
write the following case.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">div</span> _ <span class="dt">TZ</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Impossible! The compiler ensures it!&quot;</span></span></code></pre></div>
<p>Doing so prompts GHC to kindly inform us that this case cannot occur and thus is
not needed. In fact, GHC wouldn’t even bother generating the code to raise the
infamous “non-exhaustive patterns” exception because it knows the type checker
wouldn’t let such an offence reach code generation. So not only do GADTs improve
safety, but also, other things equal, lead to less code and consequently improve
efficiency.</p>
<h3 id="less-than-or-equal-to-relation">Less than or equal to relation</h3>
<p>Let’s finally define <span class="math inline">\(\leq\)</span>.The <code>TypeOperators</code> extension is needed to use infix
operators at the type level.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span><span class="ot"> (&lt;=) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Base</span><span class="ot">   ::</span>             <span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'Z</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Single</span><span class="ot"> ::</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span>    n <span class="op">&lt;=</span> <span class="dt">'S</span> m</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Double</span><span class="ot"> ::</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="op">&lt;=</span> <span class="dt">'S</span> m</span></code></pre></div>
<p>This defines a relation between two <code class="sourceCode haskell"><span class="dt">Nat</span></code>s. It records a series of
steps that gets us to the desired <span class="math inline">\(n \leq m\)</span> starting from an indisputable fact.
The record of these steps is a proof of membership to this relation.</p>
<p>The indisputable fact is <span class="math inline">\(\vdash_{\mathit{PA}} 0 \leq 0\)</span> (<span class="math inline">\(\vdash_{\mathit{PA}}\)</span>
means the statement is provable with the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano
axioms</a> which constitutes the
everyday theory of arithmetic) encoded by the <code class="sourceCode haskell"><span class="dt">Base</span></code> constructor.
Then by applying a series of <code class="sourceCode haskell"><span class="dt">Single</span></code>s and <code class="sourceCode haskell"><span class="dt">Double</span></code>s, we try
to produce the desired inequality <span class="math inline">\(n \leq m\)</span>. These constructors encode the
following statements: <span class="math inline">\(\vdash_{\mathit{PA}} n \leq m \implies n \leq m + 1\)</span>, and
<span class="math inline">\(\vdash_{\mathit{PA}} n \leq m \implies n + 1 \leq m + 1\)</span>. Hopefully, neither
are controversial as our verification claims hinge on these being sound.</p>
<p>For example, to establish <span class="math inline">\(1 \leq 2\)</span> we need to give a term of type <code class="sourceCode haskell"><span class="dt">'S</span> <span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'S</span> (<span class="dt">'S</span> <span class="dt">'Z</span>)</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oneLEQtwo ::</span> <span class="dt">'S</span> <span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'S</span> (<span class="dt">'S</span> <span class="dt">'Z</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>oneLEQtwo <span class="ot">=</span> <span class="dt">Single</span> <span class="op">$</span> <span class="dt">Double</span> <span class="op">$</span> <span class="dt">Base</span></span></code></pre></div>
<p>This proof can be read as “from <span class="math inline">\(0 \leq 0\)</span>, we can get to <span class="math inline">\(1 \leq 1\)</span> by
incrementing both sides; and from there, we can get to <span class="math inline">\(1 \leq 2\)</span> by incrementing
the right side.”.</p>
<p>Besides soundness, we also care about <em>completeness</em>. Is it the case that by
applying <code class="sourceCode haskell"><span class="dt">Single</span></code>s and <code class="sourceCode haskell"><span class="dt">Double</span></code>s to <code>Base</code>, we can get to
all valid <span class="math inline">\(n \leq m\)</span>? Yes, but we won’t prove it in this post. In fact there are
multitude of ways of proving a valid <span class="math inline">\(n \leq m\)</span>. As an example, let’s look
at another proof of <code class="sourceCode haskell">oneLEQtwo</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oneLEQtwo' ::</span> <span class="dt">'S</span> <span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'S</span> (<span class="dt">'S</span> <span class="dt">'Z</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>oneLEQtwo' <span class="ot">=</span> <span class="dt">Double</span> <span class="op">$</span> <span class="dt">Single</span> <span class="op">$</span> <span class="dt">Base</span></span></code></pre></div>
<p>You might have noticed that, the order of <code class="sourceCode haskell"><span class="dt">Single</span></code>s and
<code class="sourceCode haskell"><span class="dt">Double</span></code>s doesn’t matter. Then, a proof of <span class="math inline">\(n \leq m\)</span> always starts
with <code class="sourceCode haskell"><span class="dt">Base</span></code>, and is followed by <span class="math inline">\(m - n\)</span> <code class="sourceCode haskell"><span class="dt">Single</span></code>s and <span class="math inline">\(n\)</span>
<code class="sourceCode haskell"><span class="dt">Double</span></code>s in any order.</p>
<h3 id="singletons-faking-dependent-types">Singletons: faking dependent types</h3>
<p>We can use the insight for reaching a valid <span class="math inline">\(n \leq m\)</span> to recover <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>
given an inequality. What would be the type of a function doing that? We could
try the following.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">recoverAttempt ::</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> (n,m)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>recoverAttempt <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>This doesn’t work because <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> have kind <code class="sourceCode haskell"><span class="dt">Nat</span></code> but the
<code class="sourceCode haskell">(,)</code> type constructor has the kind signature <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code>. So is it just the case that <code class="sourceCode haskell">(,)</code> is not the right
kind of container? The problem runs deeper. Eventually we want access to
<code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code> at runtime, this implies there should be some
terms <code class="sourceCode haskell"><span class="ot">t ::</span> n</code> and <code class="sourceCode haskell"><span class="ot">r ::</span> m</code>. We know this won’t work because
<code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code> have kind <code class="sourceCode haskell"><span class="dt">Nat</span></code> and types of that kind
don’t have inhabitants.</p>
<p>In a dependently-typed language this wouldn’t be an issue because there is no
distinction between terms and types, so every entity, let it be term or type,
can survive compilation.</p>
<p>Sadly, Haskell is not there yet, so we need to fake it using <em>singletons</em>. The
idea is to create an indexed data type, so that there is exactly one term for
each indexing type. That is all a bit vague, let’s just do it for naturals.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">'Z</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n)</span></code></pre></div>
<p>You see while the type <code class="sourceCode haskell"><span class="dt">'Z</span></code> has kind <code class="sourceCode haskell"><span class="dt">Nat</span></code>, the type <code class="sourceCode haskell"><span class="dt">SNat</span> <span class="dt">'Z</span></code> has kind <code class="sourceCode haskell"><span class="dt">Type</span></code> and it has exactly one inhabitant:
<code class="sourceCode haskell"><span class="dt">SZ</span></code>. This correspondence is true for all naturals. Hence, we can use
the singleton type <code class="sourceCode haskell"><span class="dt">SNat</span><span class="ot"> n ::</span> <span class="dt">Type</span></code> as the term-level representative
for <code class="sourceCode haskell"><span class="ot">n ::</span> <span class="dt">Nat</span></code>.</p>
<p>Now, we can write the recovery function.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">recover ::</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n, <span class="dt">SNat</span> m)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>recover <span class="dt">Base</span> <span class="ot">=</span> (<span class="dt">SZ</span>, <span class="dt">SZ</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>recover (<span class="dt">Single</span> nLEQsm) <span class="op">|</span> (x,y) <span class="ot">&lt;-</span> recover nLEQsm <span class="ot">=</span> (   x, <span class="dt">SS</span> y)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>recover (<span class="dt">Double</span> nLEQm)  <span class="op">|</span> (x,y) <span class="ot">&lt;-</span> recover nLEQm  <span class="ot">=</span> (<span class="dt">SS</span> x, <span class="dt">SS</span> y)</span></code></pre></div>
<p>This function uses the inductive structure of <code class="sourceCode haskell">n <span class="op">&lt;=</span> m</code>. We know from
their types that, <code class="sourceCode haskell"><span class="dt">Single</span></code> increments the right side of <code class="sourceCode haskell"><span class="op">&lt;=</span></code>
and <code class="sourceCode haskell"><span class="dt">Double</span></code> increments both sides. We just turn them to explicit
increments to recover the singletons for <code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code>.</p>
<p>In fact, we can be sure that our implementation is correct. The type is so
specific that unless we use a degenerate term like <code class="sourceCode haskell"><span class="fu">undefined</span></code>, there
is simply no way of getting a buggy implementation to type check.</p>
<h2 id="rank-encoded-leftist-heaps">Rank encoded leftist heaps</h2>
<p>We have everything needed to encode the leftist property at the type level.
Since the leftist property involves comparing ranks of subheaps, we need access
to rank at type level. <code class="sourceCode haskell"><span class="dt">Rank</span></code> does that using a an <code class="sourceCode haskell"><span class="dt">SNat</span></code>.
We also define a helper to increment the rank for later use.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Rank</span> n <span class="ot">=</span> <span class="dt">Rank</span> {<span class="ot"> _unRank ::</span> <span class="dt">SNat</span> n }</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">inc ::</span> <span class="dt">Rank</span> rank <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> rank)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>inc (<span class="dt">Rank</span> snat) <span class="ot">=</span> <span class="dt">Rank</span> (<span class="dt">SS</span> snat)</span></code></pre></div>
<p>Since heaps need to be indexed by their rank, we use a GADT.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SafeHeap</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Leaf'</span><span class="ot"> ::</span> <span class="dt">SafeHeap</span> <span class="dt">'Z</span> a</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node'</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> m)             <span class="co">-- Node' data</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> n a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> m a <span class="co">-- Children</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> m <span class="op">&lt;=</span> n                       <span class="co">-- Leftist invariant</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> m) a</span></code></pre></div>
<p>This data type hopefully doesn’t look scary anymore. The <code class="sourceCode haskell"><span class="dt">Leaf'</span></code>
constructor creates a <code class="sourceCode haskell"><span class="dt">SafeHeap</span></code> of rank 0. The <code class="sourceCode haskell"><span class="dt">Node'</span></code>
constructor grows the heap only when we can show that the rank of the right
subheap is less than or equal to that of the left subheap. Further, the
resulting heap has rank one more than that of the right subheap.</p>
<p>What did we just do? We created a data type whose inhabitants are either vacuous
or that it is a tree satisfying the leftist property. Let’s try some examples.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">heap1 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>heap1 <span class="ot">=</span> <span class="dt">Leaf'</span></span></code></pre></div>
<p>This fails because the <code class="sourceCode haskell"><span class="dt">Leaf'</span></code> forces the rank to be <code class="sourceCode haskell"><span class="dt">'Z</span></code>
instead of <code class="sourceCode haskell"><span class="dt">'S</span> <span class="dt">'Z</span></code> as required by the signature.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">heap2 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>heap2 <span class="ot">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) <span class="dt">Leaf'</span> <span class="dt">Leaf'</span> <span class="dt">Base</span></span></code></pre></div>
<p>This type checks because <code class="sourceCode haskell"><span class="dt">Leaf'</span></code>s has rank <code class="sourceCode haskell"><span class="dt">'Z</span></code> and
<code class="sourceCode haskell"><span class="dt">Base</span></code> proves <code class="sourceCode haskell"><span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'Z</span></code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">heap3 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>heap3 <span class="ot">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) heap2' <span class="dt">Leaf'</span> (<span class="dt">Single</span> <span class="dt">Base</span>)</span></code></pre></div>
<p>This also type checks because the right child has a lower rank (<code class="sourceCode haskell"><span class="dt">'Z</span></code>)
than the left child (<code class="sourceCode haskell"><span class="dt">'S</span> <span class="dt">'Z</span></code>) and <code class="sourceCode haskell"><span class="dt">Single</span> <span class="dt">Base</span></code> proves <code class="sourceCode haskell"><span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'S</span> <span class="dt">'Z</span></code>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">heap4 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>heap4 <span class="ot">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) <span class="dt">Leaf'</span> heap2' <span class="op">???</span></span></code></pre></div>
<p>Unless we replace <code class="sourceCode haskell"><span class="op">???</span></code> with a degenerate term, we won’t be able to
find a proof for <code class="sourceCode haskell"><span class="dt">'S</span> <span class="dt">'Z</span> <span class="op">&lt;=</span> <span class="dt">'Z</span></code> on the account of its being false. This
is precisely how the data type prevents us from violating the leftist property.</p>
<p>We just made terms that violate the leftist property illegal. Pretty cool, huh?</p>
<h2 id="heap-instance-for-safeheap">Heap instance for SafeHeap</h2>
<p>Making property violating terms illegal is one thing, defining operations on
legal ones another.</p>
<p>The <code class="sourceCode haskell"><span class="dt">Heap</span></code> instance for <code class="sourceCode haskell"><span class="dt">LeftistHeap</span></code> was directly on that
data type. Consequently, the signatures of heap operations all involved
<code class="sourceCode haskell"><span class="dt">LeftistHeap</span></code>. This direct approach tends to fail with
property-encoding fancy types.</p>
<p>Say we tried to make <code class="sourceCode haskell"><span class="dt">SafeHeap</span> rank a</code> an instance of
<code class="sourceCode haskell"><span class="dt">Heap</span></code>.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">SafeHeap</span> rank a) <span class="kw">where</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">SafeHeap</span> rank a) <span class="ot">=</span> a</span></code></pre></div>
<p>We’re already in a bad place. This forces the type of <code class="sourceCode haskell">merge</code> to be
<code class="sourceCode haskell"><span class="dt">SafeHeap</span> rank a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> rank a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> rank a</code>. This type is
too restrictive! We want to be able to merge heaps of different ranks and to
produce a heap of rank not identical to the input heaps.</p>
<p>Let’s say that we gave up on the typeclass and decided to define all the
operations at the top level. Then we could give <code class="sourceCode haskell">merge</code> the type
<code class="sourceCode haskell"><span class="dt">SafeHeap</span> rank1 a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> rank2 a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> (<span class="dt">Fx</span> rank1 rank2) a</code>.
Here <code class="sourceCode haskell"><span class="dt">Fx</span></code> is some type-level function. This allows inputting heaps of
different ranks. We still need to figure out the rank of the output, but that
<em>depends</em> on the input heaps in their entirety not just their ranks. The word
“depend” is a red flag. Do we need to create singletons for
<code class="sourceCode haskell"><span class="dt">SafeHeap</span></code>s as well? This line of thinking will lead to too much
work.</p>
<p>Time to take a deep breath and think. What was our original goal? It was to
preserve the leftist property. Does that require knowing the effects of
operations on the rank of the heap at type level? No, not really. For <code>merge</code>,
we want to input two <code class="sourceCode haskell"><span class="dt">SafeHeap</span></code>s of <em>some</em> rank and produce a
<code class="sourceCode haskell"><span class="dt">SafeHeap</span></code> of <em>some</em> rank. The fact that the output is a
<code class="sourceCode haskell"><span class="dt">SafeHeap</span></code> is enough to ensure the leftist property is preserved,
which is our goal.</p>
<p>So we want to perform the operations a data type that is indifferent to the rank
at the type-level just as the untyped version was. Existential types enabled via
<code>ExistentialQuantification</code> can achieve this.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeSafeHeap</span> label <span class="ot">=</span> <span class="kw">forall</span> rank<span class="op">.</span> <span class="dt">SSH</span> (<span class="dt">SafeHeap</span> rank label)</span></code></pre></div>
<p>Despite writing <code class="sourceCode haskell"><span class="kw">forall</span></code>, what we mean is “within <code>SomeSafeHeap a</code>,
<strong>there exists</strong> a <code class="sourceCode haskell">rank</code> such that <code class="sourceCode haskell"><span class="dt">SafeHeap</span> rank a</code>”.
Hence, the name existential types. Let’s try the <code class="sourceCode haskell"><span class="dt">Heap</span></code> instance
again.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> label <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">SomeSafeHeap</span> label) <span class="kw">where</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">SomeSafeHeap</span> label) <span class="ot">=</span> label</span></code></pre></div>
<p>Now, <code class="sourceCode haskell">merge</code> has type <code class="sourceCode haskell"><span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a</code> which makes no assertions about ranks. Yet its inputs
and output contain <code class="sourceCode haskell"><span class="dt">SafeHeap</span></code>s and thus satisfy the leftist property.</p>
<p><strong>The key take away:</strong> if you use fancy types, reach for the existential as soon
as possible.</p>
<p>This is not to say that you should never implement operations relating fancy
types of inputs and outputs. If you succeed, it will give you more static
guarantees! The question is whether they justify the effort.</p>
<p>The <code class="sourceCode haskell">singleton</code> function for <code class="sourceCode haskell"><span class="dt">SomeSafeHeap</span> a</code> is a trivial
example of this. We know that the singleton heap should have rank 1. Since rank
information is hidden behind an existential, there is nothing preventing us from
defining <code>singleton x</code> to be <code>empty</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>singleton x <span class="ot">=</span> empty</span></code></pre></div>
<p>This type checks just fine. One way to improve the situation is to extract the
<code class="sourceCode haskell"><span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) a</code> into its own definition and reduce the likelihood
of such a mistake.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>singleton x <span class="ot">=</span> <span class="dt">SSH</span> singleton'</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  singleton' ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) a</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  singleton' <span class="ot">=</span> <span class="dt">Node'</span> x (<span class="dt">Rank</span> (<span class="dt">SS</span> <span class="dt">SZ</span>)) <span class="dt">Leaf'</span> <span class="dt">Leaf'</span> <span class="dt">Base</span></span></code></pre></div>
<p>This is less formal verification and more trying to squeeze every bit of safety
through self-discipline, but it did help me catch bugs more than once.</p>
<h2 id="merging-safeheaps">Merging <code class="sourceCode haskell"><span class="dt">SafeHeap</span></code>s</h2>
<p>Here’s the partial code for the <code>merge</code> operation on safe heaps.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>merge (<span class="dt">SSH</span> <span class="dt">Leaf'</span>) heap <span class="ot">=</span> heap</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>merge heap (<span class="dt">SSH</span> <span class="dt">Leaf'</span>) <span class="ot">=</span> heap</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>merge heap1<span class="op">@</span>(<span class="dt">SSH</span> (<span class="dt">Node'</span> x _ left1 right1 _))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>      heap2<span class="op">@</span>(<span class="dt">SSH</span> (<span class="dt">Node'</span> y _ left2 right2 _)) <span class="ot">=</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> x <span class="op">&gt;</span> y</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> mkNode x (<span class="dt">SSH</span> left1) (merge (<span class="dt">SSH</span> right1) heap2)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> mkNode y (<span class="dt">SSH</span> left2) (merge (<span class="dt">SSH</span> right2) heap1)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>  mkNode a (<span class="dt">SSH</span> h1) (<span class="dt">SSH</span> h2) <span class="ot">=</span> _</span></code></pre></div>
<p>This bit is almost identical to the unverified version except for some
unwrapping and wrapping with <code class="sourceCode haskell"><span class="dt">SSH</span></code>. This makes sense because as we
pointed in the unverified version, <code class="sourceCode haskell">mkNode</code> is where the leftist
property is preserved by placing the heap with the smaller rank to the right.</p>
<h3 id="comparing-without-forgetting">Comparing without forgetting</h3>
<p>In the unverified leftist heap’s <code class="sourceCode haskell">mkNode</code>, the term-level
<code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> operator decided on which child is placed to the right. It
seems all we need is to provide an analogous operator for <code class="sourceCode haskell"><span class="dt">SNat</span></code>s.
However, we now also need a proof that the rank of the right child is less than
the rank of the left child. Sadly, <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> determines the desired
property and forgets it immediately by returning a <code class="sourceCode haskell"><span class="dt">Bool</span></code>.</p>
<p>What we want here is <em>connexity</em>, that is given any <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>, either <span class="math inline">\(n \leq m\)</span> or <span class="math inline">\(m \leq n\)</span>. This holds for <a href="https://en.wikipedia.org/wiki/Total_order">total
orders</a> including <span class="math inline">\(\leq\)</span> on natural
numbers. We can express this in Haskell easily.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lemConnexity ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Either</span> (n <span class="op">&lt;=</span> m) (m <span class="op">&lt;=</span> n)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>lemConnexity <span class="dt">SZ</span> y <span class="ot">=</span> <span class="dt">Left</span>  (lemZLEQAll y)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>lemConnexity x <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Right</span> (lemZLEQAll x)</span></code></pre></div>
<p>The base cases are simple, we need to show <span class="math inline">\(0 \leq m\)</span> and <span class="math inline">\(0 \leq n\)</span>. A lemma
for <span class="math inline">\(0 \leq x\)</span> for an arbitrary <span class="math inline">\(x\)</span> would handle both cases. Let’s suppose
<code class="sourceCode haskell"><span class="ot">lemZLEQAll ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Z'</span> <span class="op">&lt;=</span> n</code> for the moment.</p>
<p>This make-believe with lemmas is how top-down proofs work. To focus on the proof
at hand, we postulate reasonable looking statements.</p>
<p>The inductive case is also simple and is a good opportunity to demonstrate doing
proofs with <em>typed holes</em>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="ot">=</span> _</span></code></pre></div>
<p>The <code class="sourceCode haskell">_</code> symbol is a typed hole. It causes an error stating what type
of term needs to go in <code class="sourceCode haskell">_</code> and the types of terms within the scope.
Incremental development with typed holes is helpful with fancy types because
when we pattern match on a GADT, the goal and the argument types automatically
get refined (especially if type-level functions are involved, <a href="#type-families">more on that
later</a>). Without the compiler telling you, it’s difficult to
keep track of the refined types in different branches.</p>
<p>Since <code class="sourceCode haskell"><span class="dt">SNat</span></code> is a GADT, pattern matching on <code class="sourceCode haskell"><span class="dt">SS</span></code> refines the
type of <code class="sourceCode haskell">_</code>. The goal becomes <code class="sourceCode haskell"><span class="dt">Either</span> (<span class="dt">'S</span> n1 <span class="op">&lt;=</span> <span class="dt">'S</span> n2) (<span class="dt">'S</span> n2 <span class="op">&lt;=</span> <span class="dt">'S</span> n1)</code> and the arguments become <code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">SNat</span> n1</code> and <code class="sourceCode haskell"><span class="ot">y ::</span> <span class="dt">SNat</span> n2</code>. If we had <code class="sourceCode haskell"><span class="dt">Either</span> (n1 <span class="op">&lt;=</span> n2) (n2 <span class="op">&lt;=</span> n1)</code>, we could probably make progress. Recursively calling
<code class="sourceCode haskell">lemConnexity</code> gives us that.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="ot">=</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">case</span> lemConnexity x y <span class="kw">of</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Left</span>  xLEQy <span class="ot">-&gt;</span> _</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Right</span> yLEQx <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>Now we have two typed holes. We need to build terms of <code class="sourceCode haskell"><span class="dt">Either</span> (<span class="dt">'S</span> n1 <span class="op">&lt;=</span> <span class="dt">'S</span> n2) (<span class="dt">'S</span> n2 <span class="op">&lt;=</span> <span class="dt">'S</span> n1)</code> from <code class="sourceCode haskell"><span class="ot">xLEQy ::</span> n1 <span class="op">&lt;=</span> n2</code> and from <code class="sourceCode haskell"><span class="ot">yLEQX ::</span> n2 <span class="op">&lt;=</span> n1</code> independently. The <code class="sourceCode haskell"><span class="dt">Double</span></code> constructor
produces a new inequality from an existing one by incrementing both sides.
Combined with <code class="sourceCode haskell"><span class="dt">Left</span></code> or <code class="sourceCode haskell"><span class="dt">Right</span></code> depending on the case, we
reach the desired terms.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="ot">=</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">case</span> lemConnexity x y <span class="kw">of</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Left</span>  xLEQy <span class="ot">-&gt;</span> <span class="dt">Left</span>  (<span class="dt">Double</span> xLEQy)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Right</span> yLEQx <span class="ot">-&gt;</span> <span class="dt">Right</span> (<span class="dt">Double</span> yLEQx)</span></code></pre></div>
<p>We are now almost done with <code class="sourceCode haskell">lemConnexity</code>. Earlier we postulated
<code class="sourceCode haskell">lemZLEQAll</code>. That still needs proving.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lemZLEQAll ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">'Z</span> <span class="op">&lt;=</span> n</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>lemZLEQAll <span class="dt">SZ</span>     <span class="ot">=</span> <span class="dt">Base</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>lemZLEQAll (<span class="dt">SS</span> x) <span class="ot">=</span> <span class="dt">Single</span> (lemZLEQAll x)</span></code></pre></div>
<p>That’s it. We just proved some order theoretic properties.</p>
<p>The ergonomics of this process are lacking. Errors are not a productive way to
interact with typed holes. Inspecting terms and their types available at a given
hole without clutter would be useful, but GHC spits 50 lines per hole and very
little of that is helpful. There isn’t much help with crafting the proof either.</p>
<p>By contrast, Idris and Agda provide editor integration to quickly inspect the
context of holes, to search and fill in terms that satisfy the hole, and to
refine the whole when given a partial expression.</p>
<p>Haskell has <em>valid hole fits</em> which are term suggestions for holes. They are
also verbose (but can be made less so with <code>-funclutter-valid-hole-fits</code> flag)
and, in my experience, not very helpful because imported libraries often include
degenerate terms with polymorphic return types (like <code class="sourceCode haskell"><span class="fu">error</span></code>). Hence
valid hole fits always include them but are not what we want. For example, in
the source code of this project I’ve imported QuickCheck from early on. It
exports <code class="sourceCode haskell"><span class="ot">discard ::</span> <span class="kw">forall</span> a<span class="op">.</span>  a</code> which gets suggested as a valid hole
fit to every single hole.</p>
<p>That said, with some discipline about making the lemmas small and properties
simple, we can go a long distance as long as we are not trying to mechanise an
entire field of mathematics.</p>
<p>If you are interested in this style of <em>type-driven development</em>, there is a
<a href="https://amzn.to/2OjXoxB">(w)hole book</a> (affiliate link) on it by the Idris
language creator Dr Edwin Brady.</p>
<h3 id="making-nodes-with-proofs">Making nodes with proofs</h3>
<p>By harnessing <code>lemConnexity</code>, implementing <code>mkNode</code> is a breeze.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>mkNode a (<span class="dt">SSH</span> h1) (<span class="dt">SSH</span> h2) <span class="ot">=</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity (_unRank <span class="op">.</span> rank <span class="op">$</span> h1) (_unRank <span class="op">.</span> rank <span class="op">$</span> h2) <span class="kw">of</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  r1LEQr2 <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node'</span> a (inc <span class="op">$</span> rank h1) h2 h1 r1LEQr2</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> r2LEQr1 <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node'</span> a (inc <span class="op">$</span> rank h2) h1 h2 r2LEQr1</span></code></pre></div>
<p>The lemma tells us which heap has the lower rank (hence needs to be the right
child) as well as giving us a proof for it which is all that is needed to
construct a <code class="sourceCode haskell"><span class="dt">Node'</span></code>.</p>
<h1 id="verifying-the-heap-property">Verifying the heap property</h1>
<p>Let’s do it one last time with both the heap and the leftist properties.</p>
<p>So what is the heap property mathematically? For a node <span class="math inline">\(n\)</span> and its children <span class="math inline">\(l\)</span>
and <span class="math inline">\(r\)</span>, it is the case that <span class="math inline">\(\mathit{label}(l) \leq \mathit{label}(n)\)</span> and
<span class="math inline">\(\mathit{label}(r) \leq \mathit{label}(n)\)</span>.</p>
<p>We now need labels in types as well as ranks. So far we used arbitrary
<code class="sourceCode haskell"><span class="dt">Type</span></code>s for labels. As a simplification, we decree that they must
effectively be <code class="sourceCode haskell"><span class="dt">SNat</span></code>s, so that we can build on our existing theory of
naturals.</p>
<h2 id="rank-and-label-encoded-leftist-heaps">Rank and label encoded leftist heaps</h2>
<p>To avoid confusion with ranks which also use <code class="sourceCode haskell"><span class="dt">SNat</span></code>s, we wrap the
label <code class="sourceCode haskell"><span class="dt">SNat</span></code>s.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Label</span> n <span class="ot">=</span> <span class="dt">Label</span> {<span class="ot"> _unLabel ::</span> <span class="dt">SNat</span> n }</span></code></pre></div>
<p>We don’t need anything else to declare the data type that makes non-heaps
illegal.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SaferHeap</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Leaf''</span><span class="ot"> ::</span> <span class="dt">SaferHeap</span> <span class="dt">'Z</span> <span class="dt">'Z</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node''</span><span class="ot"> ::</span> <span class="dt">Label</span> a <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> m)         <span class="co">-- Node' data</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> n b <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> m c <span class="co">-- Children</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> m <span class="op">&lt;=</span> n                         <span class="co">-- Leftist property</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> b <span class="op">&lt;=</span> a <span class="ot">-&gt;</span> c <span class="op">&lt;=</span> a               <span class="co">-- Heap property</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> (<span class="dt">'S</span> m) a</span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">SaferHeap</span></code> looks a lot like <code class="sourceCode haskell"><span class="dt">SafeHeap</span></code>, except for
<code class="sourceCode haskell"><span class="dt">Node''</span></code>’s fancy-typed label and two inequalities to maintain the heap
property.</p>
<p><code class="sourceCode haskell"><span class="dt">Leaf''</span></code> carries a label <code class="sourceCode haskell"><span class="dt">'Z</span></code> because every
<code class="sourceCode haskell"><span class="dt">SaferHeap</span></code> needs a type-level label. Using <code class="sourceCode haskell"><span class="dt">'Z</span></code> is a hack.
It is the least natural number, hence it can’t inhibit a <code class="sourceCode haskell"><span class="dt">Node''</span></code>
construction whatever its label may be.</p>
<p>There are two immediate alternatives to this:</p>
<ol type="1">
<li><p>Using <code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Nat</span></code> rather than <code class="sourceCode haskell"><span class="dt">Nat</span></code> for the label. This
requires modifying the heap property so that rather than <code class="sourceCode haskell">b <span class="op">&lt;=</span> a</code>,
we’d need “given <code class="sourceCode haskell">b</code> is <code class="sourceCode haskell"><span class="dt">'Just</span> b'</code>, <code class="sourceCode haskell">b' <span class="op">&lt;=</span> a</code>”
and similarly for <code class="sourceCode haskell">c <span class="op">&lt;=</span> a</code>.</p></li>
<li><p>Using <code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Nat</span></code> again, but instead of changing the heap
property, we create three <code class="sourceCode haskell"><span class="dt">Node''</span></code> like constructors: one with both
children having <code class="sourceCode haskell"><span class="dt">'Just</span></code> labels, one with only the left child having a
<code class="sourceCode haskell"><span class="dt">'Just</span></code> label, and one with neither having <code class="sourceCode haskell"><span class="dt">'Just</span></code> labels
(why don’t we need the fourth case?). This way, the heap property remains
simple.</p></li>
</ol>
<p>These may be cleaner than exploiting <code>'Z</code> being the least element in a total
order. Both, however, complicate every function that needs to scrutinise a
<code class="sourceCode haskell"><span class="dt">SaferHeap</span></code>.</p>
<p>The next step is to wrap the data type in an existential just like last time.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeSaferHeap</span> <span class="ot">=</span> <span class="kw">forall</span> rank label<span class="op">.</span> <span class="dt">SSH'</span> (<span class="dt">SaferHeap</span> rank label)</span></code></pre></div>
<p>At this point, if we construct some <code class="sourceCode haskell"><span class="dt">SaferHeap</span></code>s, we’d get bored
quickly due to constructing tedious explicit proofs. Luckily we use existentials
and <code class="sourceCode haskell"><span class="dt">Heap</span></code> to interact with the data type.</p>
<h2 id="heap-instance-for-saferheap">Heap instance for SaferHeap</h2>
<p>Just as before the instance is for the existentially wrapped type.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Heap</span> <span class="dt">SomeSaferHeap</span> <span class="kw">where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> <span class="dt">SomeSaferHeap</span> <span class="ot">=</span> <span class="dt">Nat</span></span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">Elem</span></code> for <code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code> is interesting because we don’t
actually store <code class="sourceCode haskell"><span class="dt">Nat</span></code>s anywhere. So <code class="sourceCode haskell">insert</code> requires a
conversion from <code class="sourceCode haskell"><span class="dt">SNat</span></code> to <code class="sourceCode haskell"><span class="dt">Nat</span></code> and <code class="sourceCode haskell">findMax</code> from
<code class="sourceCode haskell"><span class="dt">Nat</span></code> to <code class="sourceCode haskell"><span class="dt">SNat</span></code>.</p>
<p>The <code class="sourceCode haskell"><span class="dt">SNat</span></code> to <code class="sourceCode haskell"><span class="dt">Nat</span></code> direction is easy.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">demote ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>demote <span class="dt">SZ</span>     <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>demote (<span class="dt">SS</span> n) <span class="ot">=</span> <span class="dt">S</span> (demote n)</span></code></pre></div>
<p>But the opposite direction would have a signature <code class="sourceCode haskell"><span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</code>.
Let’s try to write that.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">promoteAttempt ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>promoteAttempt <span class="dt">Z</span>                                <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>promoteAttempt (<span class="dt">S</span> n) <span class="op">|</span> snat <span class="ot">&lt;-</span> promoteAttempt n <span class="ot">=</span> <span class="dt">SS</span> snat</span></code></pre></div>
<p>Well, this doesn’t type check because one branch returns <code class="sourceCode haskell"><span class="dt">SNat</span> <span class="dt">'Z</span></code> and
the other <code class="sourceCode haskell"><span class="dt">SNat</span> (<span class="dt">'S</span> m)</code> for some <code class="sourceCode haskell">m</code>. Neither <code class="sourceCode haskell"><span class="dt">'Z</span></code>
nor <code class="sourceCode haskell"><span class="dt">'S</span></code> unifies with <code>n</code> in the signature.</p>
<p>This might initially sound like a bad reason because when recovering
<code class="sourceCode haskell"><span class="dt">SNat</span></code>s out of a <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code>, the function signature is <code class="sourceCode haskell">n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n, <span class="dt">SNat</span> m)</code>, so it seems the same unification problem should
occur there as well. The difference is that because the argument also contains
<code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code> and that <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> is a GADT, pattern
matching <em>locally</em> refines what <code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code> are. However,
pattern matching on <code class="sourceCode haskell"><span class="dt">Nat</span></code> in <code class="sourceCode haskell">promoteAttempt</code> does not
refine the return type.</p>
<p>Since heap operations are performed on existentially wrapped types, we only need
the type-level <code class="sourceCode haskell">n</code> in the function body and not in the type signature
for the operation. So we do not really care what <code class="sourceCode haskell">n</code> is going to be so
long as there is <em>some</em> <code class="sourceCode haskell">n</code> that we can embed in the heap. This
sounds like an existential. So the <code class="sourceCode haskell">promote</code> returns an existentially
wrapped <code class="sourceCode haskell"><span class="dt">SNat</span></code>.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeNat</span> <span class="ot">=</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">SomeNat</span> (<span class="dt">SNat</span> n)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">promote ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">SomeNat</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>promote <span class="dt">Z</span>                                 <span class="ot">=</span> <span class="dt">SomeNat</span> <span class="dt">SZ</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>promote (<span class="dt">S</span> n) <span class="op">|</span> <span class="dt">SomeNat</span> snat <span class="ot">&lt;-</span> promote n <span class="ot">=</span> <span class="dt">SomeNat</span> <span class="op">$</span> <span class="dt">SS</span> snat</span></code></pre></div>
<p>A good exercise is to implement <code>singleton</code> for <code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code>. It is
similar to that for <code class="sourceCode haskell"><span class="dt">SomeSafeHeap</span></code>, except for the use
<code class="sourceCode haskell">promote</code> and the evidence for the heap property. See the source code
for the answer.</p>
<h2 id="merging-saferheaps">Merging <code class="sourceCode haskell"><span class="dt">SaferHeap</span></code>s</h2>
<p>The merge operation is, once again, all we care about. The overall structure is
going to be the same, but we’ll need more lemmas and plumbing.</p>
<h3 id="making-nodes">Making nodes</h3>
<p>This time let’s start from <code class="sourceCode haskell">mkNode</code>. Here’s an attempt.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span> <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>mkNode vc (<span class="dt">SSH</span> hA) (<span class="dt">SSH</span> hB)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="ot">=</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr <span class="op">???</span> <span class="op">???</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar <span class="op">???</span> <span class="op">???</span></span></code></pre></div>
<p>This attempt fails due to a lack of evidence for the heap property.</p>
<p>We have the parent and the children labels, so we could decide on the evidence.
But this requires us to handle the case of <code class="sourceCode haskell">vc</code> being smaller than one
of the children labels. This should be established in the body of
<code class="sourceCode haskell">merge</code> if it is anything like the previous version. Let’s assume
<code class="sourceCode haskell">merge</code> indeed passes down the evidence.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span> <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> a <span class="op">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="op">&lt;=</span> c</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>mkNode vc (<span class="dt">SSH</span> hA) (<span class="dt">SSH</span> hB) aLEQc bLEQc</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="ot">=</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr bLEQc aLEQc</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar aLEQc bLEQc</span></code></pre></div>
<p>This doesn’t work either because we have an <code class="sourceCode haskell">a <span class="op">&lt;=</span> c</code> for the first
<code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code>, but that type hides <code class="sourceCode haskell">a</code>. As far as the type
checker is concerned the rank of <code class="sourceCode haskell">hA</code> has nothing to do with <code class="sourceCode haskell"><span class="dt">Rank</span> a</code>.</p>
<p>It seems we’re hiding too much. Since <code class="sourceCode haskell">mkNode</code> is not part of the
<code class="sourceCode haskell"><span class="dt">Heap</span></code> typeclass, perhaps we can use <code class="sourceCode haskell"><span class="dt">SaferHeap</span></code> instead of
<code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code> in the signature of <code class="sourceCode haskell">mkNode</code>.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> r1 a <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> r2 b</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> a <span class="op">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="op">&lt;=</span> c</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> <span class="op">???</span> c</span></code></pre></div>
<p>This type signature relates the input heaps to the evidence, but it also
requires handling ranks. There are three viable choices for <code class="sourceCode haskell"><span class="op">???</span></code>:
<code class="sourceCode haskell">r3</code>, <code class="sourceCode haskell"><span class="dt">'S</span> r1</code>, and <code class="sourceCode haskell"><span class="dt">'S</span> r2</code>. The first one runs
into the same problem as <code class="sourceCode haskell">promote</code>, the calculated node rank won’t
unify with <code class="sourceCode haskell">r3</code>. The last two can be made the work but it presupposes
that the call site already knows which heap is going to be the right child,
hence <code class="sourceCode haskell">mkNode</code> would be pointless.</p>
<p>So <code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code> hides too much and <code class="sourceCode haskell"><span class="dt">SaferHeap</span></code> hides too
little. What we need is something in the middle to hide the rank, but expose the
label. Once again existential types come to the rescue.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AlmostSomeSaferHeap</span> label <span class="ot">=</span> <span class="kw">forall</span> rank<span class="op">.</span> <span class="dt">ASSH</span> (<span class="dt">SaferHeap</span> rank label)</span></code></pre></div>
<p>With this, the <code class="sourceCode haskell">mkNode</code> we need is not too different from that for
<code class="sourceCode haskell"><span class="dt">SomeSafeHeap</span></code>.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> a <span class="op">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="op">&lt;=</span> c</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> c</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>mkNode vc (<span class="dt">ASSH</span> hA) (<span class="dt">ASSH</span> hB) aLEQc bLEQc</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="ot">=</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">ASSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr bLEQc aLEQc</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">ASSH</span> <span class="op">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar aLEQc bLEQc</span></code></pre></div>
<h3 id="merging-nodes">Merging nodes</h3>
<p>We’d like to work with <code class="sourceCode haskell"><span class="dt">AlmostSomeSaferHeap</span></code> for the <code class="sourceCode haskell">merge</code>
implementation as well. In short, unless we do that the implementation doesn’t
go through, but it is going to take some time to explain exactly why. For now,
bear with me.</p>
<p>Let’s observe the use of the intermediary function <code class="sourceCode haskell">merge'</code> and its
type signature.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>merge (<span class="dt">SSH'</span> h1) (<span class="dt">SSH'</span> h2) <span class="op">|</span> <span class="dt">ASSH</span> mergedHeap <span class="ot">&lt;-</span> merge' (<span class="dt">ASSH</span> h1) (<span class="dt">ASSH</span> h2) <span class="ot">=</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SSH'</span> mergedHeap</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">merge' ::</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> (<span class="dt">Max</span> a b)</span></code></pre></div>
<p>The type of <code>merge'</code> will be very precise. The label of a merge result is a
function of the labels of the inputs. Particularly, it is the maximum of the
input labels.</p>
<p>This brings me to type-level functions. We already use type families within the
<code class="sourceCode haskell"><span class="dt">Heap</span></code> and <code class="sourceCode haskell"><span class="dt">HasRank</span></code> typeclasses, but those are both simple
maps of types. <code class="sourceCode haskell"><span class="dt">Max</span></code> is more sophisticated and uses recursion.</p>
<h4 id="type-families">Type families</h4>
<p>The type-level <code class="sourceCode haskell"><span class="dt">Max</span></code> function is defined using a closed type family
enabled by the <code>TypeFamilies</code> extension.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Max</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Max</span> <span class="dt">'Z</span> m          <span class="ot">=</span> m</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Max</span> n <span class="dt">'Z</span>          <span class="ot">=</span> n</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Max</span> (<span class="dt">'S</span> n) (<span class="dt">'S</span> m) <span class="ot">=</span> <span class="dt">'S</span> (<span class="dt">Max</span> n m)</span></code></pre></div>
<p>This is analogous to the following term level <code>max</code> function on
<code class="sourceCode haskell"><span class="dt">Nat</span></code>s.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span> <span class="dt">Z</span> m <span class="ot">=</span> m</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span> n <span class="dt">Z</span> <span class="ot">=</span> n</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span> (<span class="dt">S</span> n) (<span class="dt">S</span> m) <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">max</span> n m)</span></code></pre></div>
<p>You might be wondering why not just write that and get a promoted version of
<code class="sourceCode haskell"><span class="fu">max</span></code> just as we did with data types and kinds? It’s an excellent
question and this syntactic dichotomy is another reason why people don’t like
type-level programming in Haskell. In Idris and Agda, you can write one function
and use it for both terms and types.</p>
<p>The problem is multifaceted. For one thing, type families existed in GHC since
2007, whereas data-type promotion was added in 2012, and the mandate for moving
term and type levels closer is fairly recent. Further, adding type-level
computation into Haskell is an after-thought, so you need to retrofit the
syntax. On top of that, the behaviour of type families is different than
functions, the patterns of a type family can do unification whereas pattern
matches of a function can’t.</p>
<p>For example, the following returns the type <code class="sourceCode haskell"><span class="dt">Int</span></code> if its arguments
unify and <code class="sourceCode haskell"><span class="dt">Char</span></code> otherwise.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Same</span> a b <span class="kw">where</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Same</span> a a <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Same</span> _ _ <span class="ot">=</span> <span class="dt">Char</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="ot">sameInt ::</span> <span class="dt">Same</span> [ a ] [ a ]</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>sameInt <span class="ot">=</span> <span class="dv">42</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="ot">sameChar ::</span> <span class="dt">Same</span> (<span class="dt">Maybe</span> a) [ a ]</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>sameChar <span class="ot">=</span> <span class="ch">'c'</span></span></code></pre></div>
<p>So although we can promote term-level functions to the type families
(<code>singletons</code> library does this via Template Haskell), they are not exactly
equivalent because term-level variables act differently than their type-level
counterparts.</p>
<p>I don’t know what the current plan is, but since changing the behaviour of type
families would break backwards compatibility, the way forward seems to be
allowing unification at the term level or adding another extension that makes it
illegal at the type-level. Since types heavily rely on unification, the former
seems more likely to me, but I’m not an expert!</p>
<h4 id="type-families-vs-gadts">Type families vs GADTs</h4>
<p>We could have encoded <code class="sourceCode haskell"><span class="dt">Max</span></code> as a GADT as well and similarly we could
have encoded <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> as a type family.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AltMax</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">L</span><span class="ot"> ::</span>                 <span class="dt">AltMax</span> n <span class="dt">'Z</span> n</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">R</span><span class="ot"> ::</span>                 <span class="dt">AltMax</span> <span class="dt">'Z</span> m m</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">B</span><span class="ot"> ::</span> <span class="dt">AltMax</span> m n r <span class="ot">-&gt;</span> <span class="dt">AltMax</span> (<span class="dt">'S</span> m) (<span class="dt">'S</span> n) (<span class="dt">'S</span> r)</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> n <span class="op">&lt;==</span><span class="ot"> m ::</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">'Z</span>     <span class="op">&lt;==</span> m      <span class="ot">=</span> <span class="dt">'True</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>  n      <span class="op">&lt;==</span> <span class="dt">'Z</span>     <span class="ot">=</span> <span class="dt">'False</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">'S</span> n) <span class="op">&lt;==</span> (<span class="dt">'S</span> m) <span class="ot">=</span> n <span class="op">&lt;==</span> m</span></code></pre></div>
<p>These would have also worked. The proofs would have looked different, but they’d
have worked. However, there are reasons to choose one over the other.</p>
<ol type="1">
<li><p>If you intend to do induction over your relation, then constructors are
helpful, so GADTs get a point.</p></li>
<li><p>If what you have is a function, then the GADT encoding forces you to add
another type variable for the result and the fact that the arguments determine
the result get lost.</p></li>
<li><p>Conversely, if you have a relation that is not a function and you choose to
use a type family, since there is no clear result variable, you need to return
a type of kind <code class="sourceCode haskell"><span class="dt">Bool</span></code> or its equivalent.</p></li>
<li><p>With type families, when you learn more information about the type, the
reduction happens automatically, whereas with GADTs you need to pattern match
and pass the relation around.</p></li>
<li><p>More pragmatically, you might already have some type-level relations in your
codebase and you might want to stay consistent with the related relations.
Beyond consistency, this might allow you to reuse some lemmas by exploiting
duality and/or generalising the lemmas with minor effort.</p></li>
</ol>
<p>My choices in this post embody the first three principles.</p>
<h4 id="getting-back-to-the-merge">Getting back to the merge</h4>
<p>We are ready to look at the base cases for <code class="sourceCode haskell">merge'</code>.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">merge' ::</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> (<span class="dt">Max</span> a b)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>merge' (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) heap <span class="ot">=</span> heap</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>merge' heap (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) <span class="ot">=</span> heap</span></code></pre></div>
<p>Pattern matches reveal the <code class="sourceCode haskell"><span class="dt">Leaf''</span></code> labels as <code class="sourceCode haskell"><span class="dt">'Z</span></code> to
the type checker. We need to show that <code class="sourceCode haskell"><span class="dt">Max</span> <span class="dt">'Z</span> b</code> and <code class="sourceCode haskell"><span class="dt">Max</span> a <span class="dt">'Z</span></code> are <code>b</code> and <code>a</code> respectively. These are proved definitionally
because <code class="sourceCode haskell"><span class="dt">'Z</span></code> hits the base cases of <code class="sourceCode haskell"><span class="dt">Max</span></code>.</p>
<p>In the previous version, term-level <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> decided on the top
label and the subheap to recurse on. We’ve already seen that
<code class="sourceCode haskell">lemConnexity</code> is the replacement we need for comparing
<code class="sourceCode haskell"><span class="dt">SNat</span></code>s. By mimicking the structure of the previous implementation, we
can provide a partial implementation.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>merge' (<span class="dt">ASSH</span> hA<span class="op">@</span>(<span class="dt">Node''</span> vA<span class="op">@</span>(<span class="dt">Label</span> sA) _ aLeft aRight _ lLEQa rLEQa))</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>       (<span class="dt">ASSH</span> hB<span class="op">@</span>(<span class="dt">Node''</span> vB<span class="op">@</span>(<span class="dt">Label</span> sB) _ bLeft bRight _ lLEQb rLEQb)) <span class="ot">=</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity sA sB <span class="kw">of</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  aLEQb <span class="ot">-&gt;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> child1 <span class="ot">=</span> <span class="dt">ASSH</span> bLeft</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>          c1LEQp <span class="ot">=</span> _</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>          child2 <span class="ot">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>          c2LEQp <span class="ot">=</span> _</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> bLEQa <span class="ot">-&gt;</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> child1 <span class="ot">=</span> <span class="dt">ASSH</span> aLeft</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>          c1LEQp <span class="ot">=</span> _</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>          child2 <span class="ot">=</span> merge' (<span class="dt">ASSH</span> aRight) (<span class="dt">ASSH</span> hB)</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>          c2LEQp <span class="ot">=</span> _</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> mkNode vA child1 child2 c1LEQp c2LEQp</span></code></pre></div>
<p>I said at the beginning of <code class="sourceCode haskell">merge</code> implementation that I’d explain why
we used <code class="sourceCode haskell"><span class="dt">AlmostSomeSaferHeap</span></code> as opposed to <code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code>
for the <code>merge'</code> implementation. We can now see why. We need to pass
<code class="sourceCode haskell">child2</code> to <code class="sourceCode haskell">mkNode</code> and also produce it as a result of a
recursive call to <code class="sourceCode haskell">merge'</code>, if <code class="sourceCode haskell">merge'</code> used
<code class="sourceCode haskell"><span class="dt">SomeSaferHeap</span></code>, even if we extract a <code class="sourceCode haskell"><span class="dt">SaferHeap</span></code> out of
<code class="sourceCode haskell">child2</code>, its label wouldn’t relate to the label used in
<code class="sourceCode haskell">c2LEQp</code>. This is the same problem we ran into in <code class="sourceCode haskell">mkNode</code>
with too much hiding.</p>
<p>Let’s focus on the <code class="sourceCode haskell"><span class="dt">Left</span></code> branch first. The type checker complains
about the holes, but more importantly it complains about the <code class="sourceCode haskell">mkNode</code>
application. GHC says that it could not deduce <code class="sourceCode haskell"><span class="dt">Max</span> a b <span class="op">~</span> b</code>, where
<code class="sourceCode haskell"><span class="op">~</span></code> means types are equal.</p>
<p>But of course! We have <code class="sourceCode haskell">aLEQb</code> of type <code class="sourceCode haskell">a <span class="op">&lt;=</span> b</code>, but the
type checker is too stupid to know that this implies <code class="sourceCode haskell"><span class="dt">Max</span> a b</code> is just
<code class="sourceCode haskell">b</code>. So we need to prove this. That brings us to <em>propositional
equality</em>.</p>
<h4 id="propositional-equality">Propositional equality</h4>
<p>Let me introduce you to <code class="sourceCode haskell">(<span class="op">:~:</span>)</code>, the data type that tells the type
checker that two types are equal. It took me ages to get my head around it. So
you have trouble with it, keep using it until it clicks.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span><span class="ot"> (:~:) ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="co">-- Same as that in Data.Type.Equality</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="op">:~:</span> a</span></code></pre></div>
<p>It is a poly-kinded <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor. Good that it is poly-kinded,
if it was restricted to <code class="sourceCode haskell"><span class="dt">Type</span></code> or <code class="sourceCode haskell"><span class="dt">Nat</span></code> that would restrict
which types we can show to be equal. This definition makes no assumptions.</p>
<p>If we pattern match on a term with type <code class="sourceCode haskell">a <span class="op">:~:</span> b</code>, the only case is
the <code class="sourceCode haskell"><span class="dt">Refl</span></code> constructor. Just like the previous pattern matches on
GADTs, this refines the typing context. In this case, it reveals <code>a</code> and <code>b</code> to
be the same (the signature for <code class="sourceCode haskell"><span class="dt">Refl</span></code> says so). Hence, the type
checker learns <code class="sourceCode haskell">a <span class="op">~</span> b</code>.</p>
<p>We need <code class="sourceCode haskell"><span class="dt">Max</span> n m <span class="op">~</span> m</code> given <code class="sourceCode haskell">n <span class="op">&lt;=</span> m</code>, so we show <code class="sourceCode haskell"><span class="dt">Max</span> n m <span class="op">:~:</span> m</code>. Proceed by induction on <code class="sourceCode haskell">n <span class="op">&lt;=</span> m</code>.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lemMaxOfLEQ ::</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> <span class="dt">Max</span> n m <span class="op">:~:</span> m</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>lemMaxOfLEQ <span class="dt">Base</span> <span class="ot">=</span> <span class="dt">Refl</span></span></code></pre></div>
<p>In the base case, the pattern match on <code class="sourceCode haskell"><span class="dt">Base</span></code> reveals both
<code class="sourceCode haskell">n</code> and <code class="sourceCode haskell">m</code> to be <code class="sourceCode haskell"><span class="dt">'Z</span></code>. So we need to show <code class="sourceCode haskell"><span class="dt">'Z</span> <span class="op">:~:</span> <span class="dt">'Z</span></code>. We can use <code class="sourceCode haskell"><span class="dt">Refl</span></code> by instantiating <code class="sourceCode haskell">a</code> to
<code class="sourceCode haskell"><span class="dt">'Z</span></code> in <code class="sourceCode haskell">a <span class="op">:~:</span> a</code> behind the scenes.</p>
<p>Then comes the first inductive case with <code class="sourceCode haskell"><span class="dt">Double</span></code> constructor.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>lemMaxOfLEQ (<span class="dt">Double</span> xLEQy) <span class="op">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ xLEQy <span class="ot">=</span> <span class="dt">Refl</span></span></code></pre></div>
<p>Here, <code class="sourceCode haskell">xLEQy</code> has type <code class="sourceCode haskell">n <span class="op">&lt;=</span> m</code> and we need to show <code class="sourceCode haskell"><span class="dt">Max</span> (<span class="dt">'S</span> n) (<span class="dt">'S</span> m) <span class="op">:~:</span> <span class="dt">'S</span> m</code>. By the inductive case of <code class="sourceCode haskell"><span class="dt">Max</span></code>’s
definition, the goal reduces to <code class="sourceCode haskell"><span class="dt">'S</span> (<span class="dt">Max</span> n m) <span class="op">:~:</span> <span class="dt">'S</span> m</code>. Since
<code class="sourceCode haskell">xLEQy</code> is smaller than the original argument, we can recursively call
<code class="sourceCode haskell">lemMaxOfLEQ</code> to get a term of type <code class="sourceCode haskell"><span class="dt">Max</span> n m <span class="op">:~:</span> m</code>.
Pattern matching on that tells the compiler <code class="sourceCode haskell"><span class="dt">Max</span> n m <span class="op">~</span> m</code>, so the goal
reduces to <code class="sourceCode haskell"><span class="dt">'S</span> m <span class="op">~</span> <span class="dt">'S</span> m</code>. Once again, <code class="sourceCode haskell"><span class="dt">Refl</span></code> trivially
proves this.</p>
<p>The last case was fairly mechanical and this is often the case. The final
inductive case is more interesting.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>lemMaxOfLEQ (<span class="dt">Single</span> xLEQy) <span class="ot">=</span> _</span></code></pre></div>
<p>The term <code class="sourceCode haskell">xLEQy</code> has type <code class="sourceCode haskell">n <span class="op">&lt;=</span> m</code> and we need to prove <code class="sourceCode haskell"><span class="dt">Max</span> n (<span class="dt">'S</span> m) <span class="op">:~:</span> <span class="dt">'S</span> m</code>. Since we don’t know if <code class="sourceCode haskell">n</code> is built
with <code class="sourceCode haskell"><span class="dt">'S</span></code> constructor (it could be <code class="sourceCode haskell"><span class="dt">'Z</span></code>), we don’t get an
automatic reduction of our goal like last time. We still have <code class="sourceCode haskell">xLEQy</code>,
so we could apply <code class="sourceCode haskell">lemMaxOfLEQ</code> recursively. That would get us <code class="sourceCode haskell"><span class="dt">Max</span> n m <span class="op">:~:</span> m</code>, but pattern matching on that doesn’t reduce the goal any
further.</p>
<p>The mechanical process got stuck. It’s time to take a step back and think.
Taking inspiration from the previous case, if we knew that <code class="sourceCode haskell">n</code> was of
the form <code class="sourceCode haskell"><span class="dt">'S</span> k</code>, our goal would reduce to <code class="sourceCode haskell"><span class="dt">'S</span> (<span class="dt">Max</span> k m) <span class="op">:~:</span> <span class="dt">'S</span> m</code>. Then we could show <code class="sourceCode haskell"><span class="dt">Mak</span> k m <span class="op">:~:</span> m</code> and that would reduce
the overall goal to a measly <code class="sourceCode haskell"><span class="dt">'S</span> m <span class="op">~</span> <span class="dt">'S</span> m</code>. To obtain <code class="sourceCode haskell"><span class="dt">Max</span> k m <span class="op">:~:</span> m</code>, we need a recursive call to <code class="sourceCode haskell">lemMaxOfLEQ</code> with a term of
type <code class="sourceCode haskell">k <span class="op">&lt;=</span> m</code>, but we only have <code class="sourceCode haskell"><span class="dt">'S</span> k <span class="op">&lt;=</span> m</code>. Luckily we now
from grade school that <span class="math inline">\(\vdash_{\mathit{PA}} k + 1 \leq m \implies k \leq m\)</span>. So
all we need is a lemma with type <code class="sourceCode haskell"><span class="dt">'S</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="op">&lt;=</span> m</code>.</p>
<p>But we forgot something! This all hinges on <code class="sourceCode haskell">n</code> being of the form <code class="sourceCode haskell"><span class="dt">'S</span> k</code>, what if it isn’t? Well, then it must be <code class="sourceCode haskell"><span class="dt">'Z</span></code>, and <code class="sourceCode haskell"><span class="dt">Max</span> <span class="dt">'Z</span> m <span class="op">:~:</span> m</code> reduces to <code class="sourceCode haskell">m <span class="op">:~:</span> m</code>, so we are good.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>lemMaxOfLEQ (<span class="dt">Single</span> xLEQy) <span class="ot">=</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">fst</span> <span class="op">$</span> recover xLEQy <span class="kw">of</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SZ</span>                                           <span class="ot">-&gt;</span> <span class="dt">Refl</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">SS</span> _ <span class="op">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ (lemDecLEQ xLEQy) <span class="ot">-&gt;</span> <span class="dt">Refl</span></span></code></pre></div>
<p>Alright, we can prove our final lemma.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lemDecLEQ ::</span> <span class="dt">'S</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="op">&lt;=</span> m</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>lemDecLEQ snLEQm <span class="ot">=</span> <span class="fu">uncurry</span> go (recover snLEQm) snLEQm</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="op">&lt;=</span> m</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  go _            <span class="dt">SZ</span>     _            <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Impossible case.&quot;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>  go _            (<span class="dt">SS</span> _) (<span class="dt">Single</span> leq) <span class="ot">=</span> <span class="dt">Single</span> (lemDecLEQ leq)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>  go (<span class="dt">SS</span> <span class="dt">SZ</span>)      y      (<span class="dt">Double</span> _)   <span class="ot">=</span> lemZLEQAll y</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>  go (<span class="dt">SS</span> (<span class="dt">SS</span> _))  (<span class="dt">SS</span> _) (<span class="dt">Double</span> leq) <span class="ot">=</span> <span class="dt">Double</span> (lemDecLEQ leq)</span></code></pre></div>
<p>There is nothing particularly difficult about this lemma apart from the number
of arguments the induction involves, but it has some lessons.</p>
<p>Haskell doesn’t have a termination checker. This is a feature, but when we do
proofs, it feels like walking barefoot right after breaking a glass. We can
easily create an infinite loop that type checks but does not constitute a valid
proof (the circular argument fallacy).</p>
<p>This proof is particularly vulnerable to accidental loops because we pattern
match on three variables which makes it difficult to see that we are recursing
on something smaller in every case.</p>
<p>We remedy this in <code class="sourceCode haskell">lemDecLEQ</code> by making the recursive calls in the
body of <code>go</code> to <code class="sourceCode haskell">lemDecLEQ</code> rather than <code class="sourceCode haskell">go</code> itself. This is
less efficient, but makes it easier to confirm that each recursive call is to
something strictly smaller than what we started with.</p>
<p>The other interesting bit is the base case of <code class="sourceCode haskell">go</code>.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="ot">go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="op">&lt;=</span> m</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>go _ <span class="dt">SZ</span> _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Inaccessible case.&quot;</span></span></code></pre></div>
<p>We use <code>error</code> due to a deficiency of Haskell. When the second argument is
<code class="sourceCode haskell"><span class="dt">SZ</span></code>, there is no constructor of <code class="sourceCode haskell">(<span class="op">&lt;=</span>)</code> that can make <code class="sourceCode haskell"><span class="dt">'S</span> n <span class="op">&lt;=</span> m</code>, but we have a proof of this, namely the third argument. We can
see this by pattern matching on the third argument.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="ot">go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="op">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="op">&lt;=</span> m</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>go _ <span class="dt">SZ</span> <span class="dt">Base</span>     <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>go _ <span class="dt">SZ</span> <span class="dt">Single</span>{} <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>go _ <span class="dt">SZ</span> <span class="dt">Double</span>{} <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>If you compile this, GHC will give you pattern match inaccessible warnings
combined with type errors about why these arguments can’t coexist together.</p>
<p>In Agda and Idris, you can syntactically make it an inaccessible case which the
compiler can confirm or deny. In Idris, it looks like this:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>go _ <span class="dt">SZ</span> _ impossible</span></code></pre></div>
<p>We don’t have this in Haskell, but there is a stale
<a href="https://gitlab.haskell.org/ghc/ghc/issues/10756#comment:4">proposal</a>. What if
we omit this case altogether? This leads to a non-exhaustive pattern match
warning because only when we pattern match on the second argument GHC learns
that the pattern is inaccessible.</p>
<p>Using <code class="sourceCode haskell"><span class="fu">error</span></code> as a way around is dangerous because we might prove a
lemma, tweak it slightly, and not realise that the inaccessible case is now
perfectly accessible. It would type check because we have <code class="sourceCode haskell"><span class="fu">error</span> <span class="st">&quot;Inaccessible case&quot;</span></code>. This makes the proof incomplete at best.</p>
<h4 id="getting-back-to-the-merge-again">Getting back to the merge again</h4>
<p>Focusing on the <code class="sourceCode haskell"><span class="dt">Left</span></code> branch only, we make it known to the compiler
that <code class="sourceCode haskell">a <span class="op">&lt;=</span> b</code> implies <code class="sourceCode haskell"><span class="dt">Max</span> a b <span class="op">~</span> b</code> using
<code class="sourceCode haskell">lemMaxOfLEQ</code>.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>merge' (<span class="dt">ASSH</span> hA<span class="op">@</span>(<span class="dt">Node''</span> vA<span class="op">@</span>(<span class="dt">Label</span> sA) _ aLeft aRight _ lLEQa rLEQa))</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>       (<span class="dt">ASSH</span> hB<span class="op">@</span>(<span class="dt">Node''</span> vB<span class="op">@</span>(<span class="dt">Label</span> sB) _ bLeft bRight _ lLEQb rLEQb)) <span class="ot">=</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> lemConnexity sA sB <span class="kw">of</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  aLEQb <span class="op">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ aLEQb <span class="ot">-&gt;</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> child1 <span class="ot">=</span> <span class="dt">ASSH</span> bLeft</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>          c1LEQp <span class="ot">=</span> _</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>          child2 <span class="ot">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>          c2LEQp <span class="ot">=</span> _</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> bLEQa <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>This gets rid of the type error due to the application of <code class="sourceCode haskell">mkNode</code>.</p>
<p>Inspecting the errors for the holes should inform us about the terms we need.
Well, according to GHC, both holes demand type <code class="sourceCode haskell">t</code> (distinct rigid
<code class="sourceCode haskell">t</code>s). This is incredibly unhelpful and I don’t know why we get
<code class="sourceCode haskell">t</code>.</p>
<p>Inlining the <code class="sourceCode haskell"><span class="kw">let</span></code> binding improves the situation.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>mkNode vB (<span class="dt">ASSH</span> bLeft) (merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)) _ _</span></code></pre></div>
<p>The first hole needs a term of type <code class="sourceCode haskell">l <span class="op">&lt;=</span> b</code> and that’s exactly the
type of <code class="sourceCode haskell">lLEQb</code>. The second hole needs <code class="sourceCode haskell"><span class="dt">Max</span> r a <span class="op">&lt;=</span> b</code>, but
we do not yet have a term corresponding to this type. However, we have <code class="sourceCode haskell"><span class="ot">rLEQb ::</span> r <span class="op">&lt;=</span> b</code> and <code class="sourceCode haskell"><span class="ot">aLEQb ::</span> a <span class="op">&lt;=</span> b</code>. Since <code class="sourceCode haskell"><span class="dt">Max</span></code> is a
selective function (one that returns one of its arguments), the required result
holds we just need to turn it into a lemma.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lemDoubleLEQMax ::</span> n <span class="op">&lt;=</span> l <span class="ot">-&gt;</span> m <span class="op">&lt;=</span> l <span class="ot">-&gt;</span> <span class="dt">Max</span> n m <span class="op">&lt;=</span> l</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="ot">lemMaxSelective ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Max</span> n m <span class="op">:~:</span> n) (<span class="dt">Max</span> n m <span class="op">:~:</span> m)</span></code></pre></div>
<p>The proofs are left as exercises and the solutions are in the source code.</p>
<p>We can now give the full definition of the <code class="sourceCode haskell"><span class="dt">Left</span></code> branch.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span>  aLEQb <span class="op">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ aLEQb <span class="ot">-&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> child1 <span class="ot">=</span> <span class="dt">ASSH</span> bLeft</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>      c1LEQp <span class="ot">=</span> lLEQb</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>      child2 <span class="ot">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>      c2LEQp <span class="ot">=</span> lemDoubleLEQMax rLEQb aLEQb</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</span></code></pre></div>
<p>The right branch is analogous to the left one, so you should be able to fill it
yourself. There is going to be a technicality requiring a simple lemma that is
not required in the <code class="sourceCode haskell"><span class="dt">Left</span></code> branch because of the way we set things up.
If you write the <code class="sourceCode haskell"><span class="dt">Right</span></code> as we did <code class="sourceCode haskell"><span class="dt">Left</span></code>, the type error
should give you a clue about what is needed. If you can’t figure it out, that
too is in the source.</p>
<h4 id="other-operations">Other operations?</h4>
<p>We could implement the other methods, but they are all too simple. We are done!
No more verification.</p>
<h1 id="simulating-heap-operations">Simulating heap operations</h1>
<p>So after going through all this trouble to prove properties of our code, why
bother testing?</p>
<ol type="1">
<li><p>We didn’t verify everything. Earlier we gave the example of implementing
<code class="sourceCode haskell">singleton</code> with the wrong rank by ignoring the input. A common theme
is to accidentally discard a subpart of a data structure or an input and use
another part twice.</p></li>
<li><p>Haskell’s type system is unsound. So we might have a fallacious proof
somewhere that makes it look like the property holds while being buggy.</p></li>
<li><p>It gives me a chance to talk about another type-level feature: visible type
applications.</p></li>
<li><p>I really want to use QuickCheck to run simulations on the heap.</p></li>
</ol>
<p>It is worth noting that if Haskell had <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems">linear
types</a>
(<a href="https://gitlab.haskell.org/ghc/ghc/wikis/linear-types">it soon will!</a>), we
could have addressed (1) by forcing inputs to be used.</p>
<h2 id="generating-actions">Generating actions</h2>
<p>We’re only going to simulate insertion and deleting the min. Here’s the initial
encoding of the actions.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Action</span> a <span class="ot">=</span> <span class="dt">Insert</span> a <span class="op">|</span> <span class="dt">DeleteMax</span> <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Let’s give <code class="sourceCode haskell"><span class="dt">Arbitrary</span></code> instances for <code class="sourceCode haskell"><span class="dt">Nat</span></code> and
<code class="sourceCode haskell"><span class="dt">Action</span></code> to randomly generate sequences of <code class="sourceCode haskell"><span class="dt">Action</span></code>s.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="fu">fromInt</span> <span class="op">.</span> getNonNegative <span class="op">&lt;$&gt;</span> arbitrary <span class="op">@</span>(<span class="dt">NonNegative</span> <span class="dt">Int</span>)</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fromInt</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fromInt</span> n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInt</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Action</span> a) <span class="kw">where</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>    shouldAddInsert <span class="ot">&lt;-</span> arbitrary <span class="op">@</span><span class="dt">Bool</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> shouldAddInsert</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="dt">Insert</span> <span class="op">&lt;$&gt;</span> arbitrary</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">pure</span> <span class="dt">DeleteMax</span></span></code></pre></div>
<p>Somewhat arbitrarily we choose between a deletion and an insertion with <span class="math inline">\(50\%\)</span>
probability. This may or may not be a realistic simulation, but it is something
easy to adjust. We can have multiple wrappers over <code class="sourceCode haskell"><span class="dt">Action</span> a</code> such as
<code class="sourceCode haskell"><span class="dt">DeleteHeavy</span> a</code> and <code class="sourceCode haskell"><span class="dt">InsertionHeavy</span> a</code> to simulate different
scenarios.</p>
<p>We haven’t seen the <code class="sourceCode haskell"><span class="op">@</span></code> symbols in the <code class="sourceCode haskell"><span class="dt">Arbitrary</span></code> instances
before. They are visible type applications enabled by <code>TypeApplications</code>
extension. In addition to drastically improving handling ambiguous types, they
allow us to learn more about type variables.</p>
<h3 id="there-is-lambda-then-there-is-lambda">There is <span class="math inline">\(\Lambda\)</span> then there is <span class="math inline">\(\lambda\)</span></h3>
<p>If someone asks for the explicitly-typed polymorphic lambda term for the
identity function (as one does), we’d probably write <span class="math inline">\(\lambda x : \alpha. x\)</span>,
where <span class="math inline">\(\alpha\)</span> is a polymorphic type variable. We’d expect this function to be
closed, that is to say it shouldn’t depend on the context. Indeed, our identity
function looks unaffected by the term-level context because the only variable
<span class="math inline">\(x\)</span> is <span class="math inline">\(\lambda\)</span>-bound. However, <span class="math inline">\(\alpha\)</span> doesn’t seem to be bound by anything,
hence it looks dependent on the context.</p>
<p>Appearances can be deceiving. If this term should be interpreted as Haskell
interprets terms and their signatures, it just abbreviates <span class="math inline">\(\Lambda \alpha : \mathit{Type}. \lambda x : \alpha. x\)</span>. All free type variables in signatures are
implicitly <span class="math inline">\(\Lambda\)</span>-bound. The Haskell syntax is <code>forall</code> and is only allowed
in signatures (with <code>ExplicitForAll</code> enabled).</p>
<p>The following is the same identity function in Haskell but with explicit
quantification.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="dt">Type</span>)<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>Just as the binders are hidden behind the scenes, so are the applications. When
we apply <code class="sourceCode haskell"><span class="fu">id</span></code> to <code class="sourceCode haskell"><span class="dv">42</span></code>, the <code class="sourceCode haskell"><span class="dt">Int</span></code> gets passed to
the type-level function first. <code>TypeApplications</code> enables syntax to do this
explicitly. We just pass the type with a <code class="sourceCode haskell"><span class="op">@</span></code> prefix. For example in
<code>ghci</code>, <code>:t id @Int</code> yields <code class="sourceCode haskell"><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code>.</p>
<p>This works as an alternative to using <code class="sourceCode haskell"><span class="ot">::</span></code> when a type is ambiguous.
Often it lets us get away with fewer parentheses and looks cleaner in general.</p>
<p>What happens if there are multiple type variables? The applied type is unified
with the first type variable. This is how term-level application works as well.
This raises the question of type-variable ordering.</p>
<p>In the absence of an explicit <code class="sourceCode haskell"><span class="kw">forall</span></code>, the ordering of type variables
is up to GHC. We can query the order of type variables used by GHC via <code>:type +v</code> and <code>-fprint-explicit-foralls</code> flag. However, I think placing explicit
<code class="sourceCode haskell"><span class="kw">forall</span></code>s is good practice.</p>
<p>We look at type applications more interesting than those in the
<code class="sourceCode haskell"><span class="dt">Arbitrary</span></code> instances momentarily.</p>
<h2 id="executing-actions">Executing actions</h2>
<p>We can now interpret the initial representation of our actions. Nothing exciting
here.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="ot">execAction ::</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> <span class="dt">Action</span> (<span class="dt">Elem</span> heap) <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>execAction (<span class="dt">Insert</span> x) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">.</span> (x <span class="ot">`insert`</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>execAction <span class="dt">DeleteMax</span>  <span class="ot">=</span> deleteMax</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="ot">carryOutActions ::</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> heap) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>carryOutActions <span class="ot">=</span> foldlM (<span class="fu">flip</span> execAction) empty</span></code></pre></div>
<h2 id="quickchecking-functional-equivalence">QuickChecking functional equivalence</h2>
<p>It’s time to use QuickCheck. The desired property: given two data types
implementing <code class="sourceCode haskell"><span class="dt">Heap</span></code> and a series of actions, executing these actions
on the <code class="sourceCode haskell">empty</code> of each should yield the same maximum.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sameMaxAfterActions ::</span> <span class="kw">forall</span> heap heap'</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>                     <span class="op">.</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> <span class="dt">Heap</span> heap'</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">Elem</span> heap <span class="op">~</span> <span class="dt">Elem</span> heap'</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Elem</span> heap)</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> heap) ] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>sameMaxAfterActions acts <span class="ot">=</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>  maxOfActions <span class="op">@</span>heap acts <span class="op">==</span> maxOfActions <span class="op">@</span>heap' acts</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  maxOfActions ::</span> <span class="kw">forall</span> h <span class="op">.</span> <span class="dt">Heap</span> h</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>               <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> h) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Elem</span> h))</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>  maxOfActions <span class="ot">=</span> <span class="fu">fmap</span> findMax <span class="op">.</span> carryOutActions <span class="op">@</span>h</span></code></pre></div>
<p>The computation is not very interesting, but the way we direct it is. We use an
explicit <code class="sourceCode haskell"><span class="kw">forall</span></code>. This is not to fix the type variable ordering.
Since both <code class="sourceCode haskell">heap</code> and <code class="sourceCode haskell">heap'</code> are passed to the same
function, the ordering is irrelevant. <code>ScopedTypeVariables</code> extension allows
<code class="sourceCode haskell"><span class="kw">forall</span></code> quantified type variables to be referenced in the function
body which we need to pick the implementation <code class="sourceCode haskell">maxOfActions</code> should
use.</p>
<p>The type applications <code class="sourceCode haskell"><span class="op">@</span>heap</code> and <code class="sourceCode haskell"><span class="op">@</span>heap'</code> determine the
computation. This is not just disambiguation. If both <code>maxOfActions</code> were
applied to <code class="sourceCode haskell">heap</code> instead, we’d create a property that is trivially
satisfied.</p>
<p>We use another type application in the body of <code class="sourceCode haskell">maxOfActions</code>. This is
for disambiguation. Without it, all <code>carryOutActions</code> sees is <code class="sourceCode haskell"><span class="dt">Elem</span> h</code> and <code class="sourceCode haskell"><span class="dt">Elem</span></code> isn’t injective. This means given <code class="sourceCode haskell"><span class="dt">Elem</span> h</code>, we can’t know what <code>h</code> is. For example, if I told you <code class="sourceCode haskell"><span class="dt">Elem</span> h</code> was <code class="sourceCode haskell"><span class="dt">Int</span></code>, <code>h</code> could be <code class="sourceCode haskell"><span class="dt">LeftistHeap</span></code> or
<code class="sourceCode haskell"><span class="dt">SomeSafeHeap</span></code> as both can have <code class="sourceCode haskell"><span class="dt">Int</span></code> labels. Hence, we use
a type application to tell <code class="sourceCode haskell">carryOutActions</code> what <code>h</code> is.</p>
<p>All there remains is to actually check the property between different
implementations.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>  quickCheck (sameMaxAfterActions <span class="op">@</span>(<span class="dt">LeftistHeap</span> <span class="dt">Int</span>)  <span class="op">@</span>[ <span class="dt">Int</span> ])</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  quickCheck (sameMaxAfterActions <span class="op">@</span>(<span class="dt">SomeSafeHeap</span> <span class="dt">Int</span>) <span class="op">@</span>[ <span class="dt">Int</span> ])</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>  quickCheck (sameMaxAfterActions <span class="op">@</span><span class="dt">SomeSaferHeap</span>      <span class="op">@</span>[ <span class="dt">Nat</span> ])</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  sampleActions <span class="ot">&lt;-</span> sample' (arbitrary <span class="op">@</span>(<span class="dt">Action</span> <span class="dt">Int</span>))</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> sampleActions</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> carryOutActions <span class="op">@</span>[ <span class="dt">Int</span> ] sampleActions</span></code></pre></div>
<p>Remember that the list-based heap implementation was our reference
implementation. Using type applications, we test functional equivalence between
the reference implementation and the untyped leftist heap, the leftist
property verified leftist heap, and the leftist and heap property verified
leftist heap.</p>
<p>Then I just sample some actions and see the result of carrying them out on the
terminal because I’m paranoid like that (the <code class="sourceCode haskell"><span class="dt">Arbitrary</span></code> instance
could also be buggy 🙃).</p>
<p>At this point, we can be reasonably sure that these implementations work (for
insertion and deletion).</p>
<h1 id="conclusion">Conclusion</h1>
<p>After such a long post, I’ll keep the conclusion short and sweet. Here’s what we
did in a gist:</p>
<ul>
<li>learnt about leftist heaps a purely functional replacement to array-based
binary heaps;</li>
<li>looked at major parts of Haskell’s type-level computation features;</li>
<li>ran simulations to test functional equivalence of various implementations;</li>
<li>did a commentary on Haskell as an interactive theorem prover.</li>
</ul>
<p>What is the overall verdict on that last point? It’s not ideal at all, but it
works for simple data structures and properties. If we had used the <code>singletons</code>
library and type-checker plugins, we could have gone further quicker.</p>
<p>The often overlooked point is this: if we want to do verification natively in a
language that is designed to build programs with an optimising compiler and a
massive ecosystem, Haskell is the singular choice. I for one am looking forward
to Haskell’s typed and bright future.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>I’d like to thank Dr Dominic Orchard and Lex van der Stoep for their comments on
the drafts of this post and I appreciate Vilem Liepelt’s post-publication
corrections and suggestions.</p>
<p>This post wouldn’t be possible without the heroic work of a vibrant research
community and GHC implementers. They are too many to name exhaustively, but the
following deserves a special round of applause: <a href="https://richarde.dev/index.html">Dr Richard
Eisenberg</a> and <a href="https://www.cis.upenn.edu/~sweirich/">Prof. Stephanie
Weirich</a> (<a href="https://dl.acm.org/citation.cfm?id=2535856">closed type
families</a>,
<a href="https://dl.acm.org/citation.cfm?id=2364522">singletons</a>), <a href="https://homepages.inf.ed.ac.uk/jcheney/">Dr James
Cheney</a>
(<a href="https://ecommons.cornell.edu/handle/1813/5614">GADTs</a>), and <a href="https://www.cs.bu.edu/~hwxi/">Dr Hongwei
Xi</a> (<a href="https://dl.acm.org/citation.cfm?id=604150">also
GADTs</a>).</p>
<p>The code wouldn’t be as slick if it wasn’t for Prof. Weirich’s presentations on
<a href="https://www.youtube.com/watch?v=n-b1PYbRUOY">verifying red-black trees</a>
(<a href="https://www.youtube.com/watch?v=rhWMhTjQzsU">alternative</a>).</p></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
