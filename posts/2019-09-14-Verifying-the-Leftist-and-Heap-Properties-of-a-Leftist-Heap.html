<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Verifying Leftist and Heap Properties of a Leftist Heap</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on September 14, 2019
  
  
</div>

<h1>Verifying Leftist and Heap Properties of a Leftist Heap</h1>


<p class="in-which">In which my job search leads me to verify the titular properties of a leftist heap using Haskell's type-level features and to test it by way of simulation using QuickCheck. We also cover much of Haskell's type-level computation features from scratch.</p>


<div class="post"><h2 id="the-story">The story</h2>
<p>I’ve made it to the final stage of my computer science PhD, you know the one where you start looking for jobs, get yourself a copy of <a href="https://amzn.to/2Q74ckU">Cracking the Coding Interview</a> (affiliate link), and realise that you haven’t done much of the kind of programming that about half of the companies expect you to do at their job interviews (and at their job interviews only).</p>
<p>At some point in the book, it says “know how to implement these data structures by heart: dynamically sized arrays, hash tables, […], <strong>binary heaps</strong>, […]”. It downed on me that I remember the heap property and heap interface, but not how to implement it. I was horrified when I remembered despite conceptually being a tree, binary heaps are implemented using arrays. Despite having used Haskell as my primary language, decided to implement it in Ruby—my prior primary language. After some time and indexing errors later, I got it working. Then ported it to Haskell’s using the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-ST.html"><code>ST</code> monad</a>. After writing <code>STRef</code> one too many times, I got that working too, but it left much to be desired. “Save the trees” yelled my terminal!</p>
<p>Finally, I consulted Dr Chris Okasaki’s <a href="https://amzn.to/34ICTAM">Purely Functional Data Structures</a> (affiliate link). A leftist heap is one of the first data structures discussed in the book. It has better worst-case asymptotic complexity than the binary heap, is represented as a tree, and doesn’t need mutation. Great! I was pleased to have a heap under my belt that was much easier to remember and much more difficult to get its implementation wrong.</p>
<p>Staring at it for a while (and being bored while trying to find various substrings with various properties in linear time and constant space under an hour over the phone), I got a burning desire to encode the titular properties of a leftist heap using fancy types. Having listened to hundreds of people complain about the state of type-level programming in Haskell, I found the process to be rough around the edges, but functional (see what I did there) that I wanted to share it.</p>
<h2 id="the-spiel">The spiel</h2>
<p>This brings us to the post at hand. This post is a bit long, but the upside is there is something for everybody. Hopefully, some of the following piques your interest:</p>
<ul>
<li>leftist heaps as a purely functional alternative to array-based binary heaps,</li>
<li>complexity analysis of operations on leftist heaps,</li>
<li>a case study on the internalist approach to verifying data structures,</li>
<li>a tutorial on most major features of type-level programming in Haskell,</li>
<li>a commentary on the ergonomics of verification using fancy types in Haskell,</li>
<li>and practical advice on avoiding pitfalls when using fancy types.</li>
</ul>
<p>Beginners beware! Type-level programming can be daunting. It certainly was for me for a long time. I’ll attempt to explain fancy types from scratch. If you find yourself getting confused, it’s almost certainly my fault. Just let me know (contact details on my <a href="../">homepage</a>) and I’ll clarify the post.</p>
<h2 id="the-itinerary">The itinerary</h2>
<p>Here are the sections and what to expect from them.</p>
<ul>
<li><a href="#a-simple-heap">A simple heap</a> covers the generic heap interface through a typeclass and a trivial instance for it. Type-level features: associated type families;</li>
<li><a href="#a-leftist-heap">A leftist heap</a> describes a data type for leftist heaps without using fancy types and discusses the asymptotic complexities of its operations;</li>
<li><a href="#terms-types-and-kinds">Terms, types, and kinds</a> covers the basic entities in modern Haskell and how they relate to each other. Type-level features: <a href="#data-type-promotion">data type promotion</a>, <a href="#kind-polymorphism">kind polymorphism</a>, and <a href="#levity-polymorphism">levity-polymorhpsim</a>;</li>
<li><a href="#verifying-the-leftist-property">Verifying the leftist property</a> explains the data type encoding the leftist property and the implementation of its property preserving operations. Type-level features: generalised algebraic data types, singletons, kind signatures through the example of <a href="#natural-numbers">natural numbers</a>, and existential types through <a href="#heap-instance-for-safeheap">the heap instance for our data type</a>. We also introduce <a href="#comparing-without-forgetting">theorem proving</a> in Haskell.</li>
<li><a href="#verifying-the-heap-property">Verifying the heap property</a> encodes both the leftist and the heap properties into a data type. Most of this section is on the property preserving merge. Type-level features: <a href="#type-families">closed type families</a> and <a href="#propositional%20equality">propositional equality</a>. Additionally, it extends on theorem proving and use of existential types.</li>
<li><a href="#simulating-heap-operations">Simulating heap operations</a> tests the functional equivalence of the heap implementations in this post. We use QuickCheck to simulate evaluation of <em>arbitrary</em> sequence of insertions and deletions. Type-level features: <a href="#there-is-lambda-then-there-is-lambda">visible type-applications, explicit foralls</a>, and <a href="#quickchecking-functional-equivalence">scoped type variables</a>.</li>
<li><a href="#conclusion">Conclusion</a> acknowledges people who made this post possible and reminds some take aways.</li>
</ul>
<p>The exposition of the code is fragmented and out of order, but I provide the well-organised source code at <a href="#full-program">the very end of the post</a>. We won’t use any libraries except <a href="http://hackage.haskell.org/package/QuickCheck-2.13.2">QuickCheck</a>.</p>
<h1 id="a-simple-heap">A simple heap</h1>
<p>A heap is a (conceptually) tree-based data structure used to quickly access and maintain access to the maximum or the minimum of a collection of values. It satisfies the <em>heap property</em>, that is (for a maximum heap) the label of a node is bigger than or equal to that of its children. The following typeclass summarises its common operations.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> <span class="dt">Heap</span> heap <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="ot">{-# MINIMAL</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">    isEmpty, empty,</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">    (singleton | insert),</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">    (merge | insert),</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">    (decompose | (findMax, deleteMax))</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="ot">    #-}</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="kw">type</span> <span class="dt">Elem</span> heap</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="co">-- Predicates</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="ot">  isEmpty ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14">  <span class="co">-- Access</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="ot">  findMax ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Elem</span> heap)</a>
<a class="sourceLine" id="cb1-16" title="16">  findMax <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">fst</span> <span class="fu">&lt;$&gt;</span> decompose</a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="co">-- Creation</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="ot">  empty ::</span> heap</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="ot">  singleton ::</span> <span class="dt">Elem</span> heap <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb1-22" title="22">  singleton <span class="fu">=</span> (<span class="ot">`insert`</span> empty)</a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="ot">  fromList ::</span> [ <span class="dt">Elem</span> heap ] <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb1-25" title="25">  fromList xs <span class="fu">=</span> <span class="co">-- O(n) for leftist heaps</span></a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="kw">case</span> go (<span class="fu">map</span> singleton xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-27" title="27">      [ heap ] <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb1-28" title="28">      [ ]      <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb1-29" title="29">      _        <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Fatal error. Did not converge to a single heap.&quot;</span></a>
<a class="sourceLine" id="cb1-30" title="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-31" title="31">    go [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-32" title="32">    go [ x ] <span class="fu">=</span> [ x ]</a>
<a class="sourceLine" id="cb1-33" title="33">    go (x <span class="fu">:</span> y <span class="fu">:</span> rest) <span class="fu">=</span> go (merge x y <span class="fu">:</span> go rest)</a>
<a class="sourceLine" id="cb1-34" title="34"></a>
<a class="sourceLine" id="cb1-35" title="35">  <span class="co">-- Motification</span></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="ot">  insert ::</span> <span class="dt">Elem</span> heap <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb1-37" title="37">  insert x <span class="fu">=</span> merge (singleton x)</a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="ot">  merge ::</span> heap <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb1-40" title="40">  heap1 <span class="ot">`merge`</span> heap2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="kw">case</span> decompose heap1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-42" title="42">      <span class="dt">Just</span> (heapMax, heapRest) <span class="ot">-&gt;</span> heapRest <span class="ot">`merge`</span> (heapMax <span class="ot">`insert`</span> heap2)</a>
<a class="sourceLine" id="cb1-43" title="43">      <span class="dt">Nothing</span>                  <span class="ot">-&gt;</span> heap2</a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="ot">  decompose ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Elem</span> heap, heap)</a>
<a class="sourceLine" id="cb1-46" title="46">  decompose heap <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="kw">case</span> (findMax heap, deleteMax heap) <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-48" title="48">      (<span class="dt">Just</span> heapMax, <span class="dt">Just</span> heapRest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (heapMax, heapRest)</a>
<a class="sourceLine" id="cb1-49" title="49">      (<span class="dt">Nothing</span>     , <span class="dt">Nothing</span>      ) <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb1-50" title="50">      (<span class="dt">Just</span> _      , <span class="dt">Nothing</span>      ) <span class="ot">-&gt;</span> <span class="fu">error</span></a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="st">&quot;Impossible happened. There is a max but the heap is empty.&quot;</span></a>
<a class="sourceLine" id="cb1-52" title="52">      (<span class="dt">Nothing</span>     , <span class="dt">Just</span> _       ) <span class="ot">-&gt;</span> <span class="fu">error</span></a>
<a class="sourceLine" id="cb1-53" title="53">        <span class="st">&quot;Impossible happened. Heap is non-empty but there is a max.&quot;</span></a>
<a class="sourceLine" id="cb1-54" title="54"></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="ot">  deleteMax ::</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</a>
<a class="sourceLine" id="cb1-56" title="56">  deleteMax <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">snd</span> <span class="fu">&lt;$&gt;</span> decompose</a></code></pre></div>
<p>This is a bit mouthful because many operations are interdefinable as reflected by the <code class="sourceCode haskell"><span class="dt">MINIMAL</span></code> pragma.</p>
<p>The <code class="sourceCode haskell"><span class="dt">Elem</span></code> <em>type family</em> (enabled by <code>TypeFamilies</code> extension) associated with <code class="sourceCode haskell"><span class="dt">Heap</span></code> gives the type of elements for a particular instance. This is nothing but a function from types of containers to types of their elements. We could have equally used <code>MultiParamTypeClasses</code> and <code>FunctionalDependencies</code> extensions to establish the same container-element relationship. I chose a type family here because we will use type families in a moment anyway and because I think <code class="sourceCode haskell"><span class="dt">Elem</span> heap</code> has less cognitive overhead than remembering functional dependencies between type variables.</p>
<p>Although <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">findMax</code> and <code class="sourceCode haskell">deleteMax</code> are the most commonly used operations of <code class="sourceCode haskell"><span class="dt">Heap</span></code>, <code class="sourceCode haskell">merge</code> is the one that we care the most about. For all data structures we’ll use as heaps today, implementing <code class="sourceCode haskell">isEmpty</code>, <code class="sourceCode haskell">findMax</code>, <code class="sourceCode haskell">singleton</code>, and <code class="sourceCode haskell">empty</code> are trivial. Then with <code class="sourceCode haskell">merge</code>, we can implement <code class="sourceCode haskell">insert</code>, <code class="sourceCode haskell">fromList</code>, <code class="sourceCode haskell">decompose</code>, and <code class="sourceCode haskell">deleteMax</code>. As we see in the next section, implementing <code class="sourceCode haskell">merge</code> and deriving the rest is not only optimal in terms of productivity but also in terms of performance for leftist heaps.</p>
<p>Before implementing this interface for a leftist heap, let’s look at a much simpler instance.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> [ a ] <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">type</span> <span class="dt">Elem</span> [ a ] <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">  isEmpty <span class="fu">=</span> <span class="fu">null</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">  empty <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">  fromList xs <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">  insert <span class="fu">=</span> (<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12">  merge <span class="fu">=</span> (<span class="fu">&lt;&gt;</span>)</a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">  decompose [] <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-15" title="15">  decompose xs <span class="fu">=</span> <span class="dt">Just</span> (heapMax, left <span class="fu">++</span> <span class="fu">tail</span> right)</a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-17" title="17">    heapMax       <span class="fu">=</span> <span class="fu">maximum</span> xs</a>
<a class="sourceLine" id="cb2-18" title="18">    (left, right) <span class="fu">=</span> <span class="fu">span</span> (<span class="fu">/=</span> heapMax) xs</a></code></pre></div>
<p>This may be the easiest heap implementation. Insertion is <span class="math inline">\(O(1)\)</span>, merging is <span class="math inline">\(O(n)\)</span>, conversion from a list is <span class="math inline">\(O(1)\)</span>, and decomposing (and subsequently finding and deleting the maximum) is <span class="math inline">\(O(n)\)</span>. If it wasn’t for that last <span class="math inline">\(O(n)\)</span>, this would have been a perfectly fine heap implementation, alas here we are.</p>
<p>This implementation is obviously correct, thus any other correct heap implementation should be <em>functionally equivalent</em> to it. This means performing the same operations on two empty heaps of different implementations should result in two heaps with the same maximum. Hence, this simple heap implementation is perfect for <a href="#simulating-heap-operations">testing other implementations’ correctness</a>.</p>
<h1 id="a-leftist-heap">A leftist heap</h1>
<p>Since we’ll go through the trouble of implementing leftist heaps multiple times, let’s spend a second on comparing it to array-based binary heaps.</p>
<p>Why bother with the leftist heap? It is persistent (hence better suited for multi-threaded computation), purely functional, both conceptually and implementation-wise a tree, and more resilient against off-by-one errors. Why bother with the array-based binary heap? Better average case complexity of insertions; its operations are in place; and it probably performs better in practice because of good locality of reference (this is a hunch and I’d like to be proven wrong).</p>
<p>We can also look at their complexities more concretely. Leftist heaps have <span class="math inline">\(O(\lg{n})\)</span> worst-case complexity for insertion and deleting the maximum, while maintaining <span class="math inline">\(O(1)\)</span> complexity for finding the maximum. Building a heap out of a <code class="sourceCode haskell"><span class="dt">Foldable</span></code> collection is <span class="math inline">\(O(n)\)</span>. So far we’re on par with binary heaps. But we can do one better. While merging binary heaps is <span class="math inline">\(O(n)\)</span>, it’s only <span class="math inline">\(O(\lg{n})\)</span> for leftist heaps. In fact, this is why insertion and deletion are <span class="math inline">\(O(\lg{n})\)</span>.</p>
<h2 id="the-data-structure-and-its-properties">The data structure and its properties</h2>
<p>A leftist heap is as a tree and we implement it as such.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">LeftistHeap</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a <span class="dt">Int</span> (<span class="dt">LeftistHeap</span> a) (<span class="dt">LeftistHeap</span> a)</a></code></pre></div>
<p>The tree is standard except for the <code class="sourceCode haskell"><span class="dt">Int</span></code> parameter. This is the <em>rank</em> of the <code class="sourceCode haskell"><span class="dt">Node</span></code>, which is the least distance to a <code class="sourceCode haskell"><span class="dt">Leaf</span></code>. The rank of a <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is 0 and the rank of a <code class="sourceCode haskell"><span class="dt">Node</span></code> is one more than the minimum of its children’s ranks.</p>
<p>Let’s briefly look at the relationship between the size of a tree and its rank.</p>
<p>A first question is how many elements there needs to be in the tree if its rank is <span class="math inline">\(R\)</span>? If the rank of a tree is <span class="math inline">\(R\)</span>, then it must be the case that each path from the root has <span class="math inline">\(R\)</span> <code class="sourceCode haskell"><span class="dt">Node</span></code>s, otherwise the rank of the tree would be fewer. This means the tree has at least <span class="math inline">\(2^{R} - 1\)</span> elements.</p>
<p>Then the followup question is, if a tree has <span class="math inline">\(N\)</span> elements, what is its maximum rank? Well, we know that the rank imposes a lower bound on the tree size, so conversely, the tree size should impose a maximum on the rank. If <span class="math inline">\(R\)</span> is the maximum rank, we have <span class="math inline">\(2^{R} - 1 \leq N \lt 2^{R + 1} - 1\)</span>, so <span class="math inline">\(R \leq \lg{(N + 1)} &lt; R + 1\)</span>. Hence, <span class="math inline">\(\left\lfloor{\lg{(N + 1)}} \right\rfloor\)</span> is the desired maximum.</p>
<p>The leftist heap has the <em>leftist property</em>. In short, the shortest path from any node to a <code class="sourceCode haskell"><span class="dt">Leaf</span></code> must be the right-most one. Since each subtree in a leftist heap is also a leftist heap, the rank of any left child is at least as big as that of the right, hence the name.</p>
<p>How can we refine the earlier calculation about the maximum rank for leftist heaps? The distance between the root and the right-most <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is at most <span class="math inline">\(\left\lfloor{\lg{(N + 1)}} \right\rfloor\)</span>, if the leftist heap has <span class="math inline">\(N\)</span> elements in it. This is the critical information we’ll use to derive the complexity of the <code class="sourceCode haskell">merge</code> operation.</p>
<p>Accessing the rank is handy, so let’s create a typeclass for it.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="dt">HasRank</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">type</span> <span class="dt">RankType</span> a</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">  rank ::</span> a <span class="ot">-&gt;</span> <span class="dt">RankType</span> a</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">instance</span> <span class="dt">HasRank</span> (<span class="dt">LeftistHeap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">type</span> <span class="dt">RankType</span> (<span class="dt">LeftistHeap</span> a) <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8">  rank <span class="dt">Leaf</span>           <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-9" title="9">  rank (<span class="dt">Node</span> _ r _ _) <span class="fu">=</span> r</a></code></pre></div>
<p>Here is the <code class="sourceCode haskell"><span class="dt">Heap</span></code> instance for the <code class="sourceCode haskell"><span class="dt">LeftistHeap</span></code>. The <code class="sourceCode haskell"><span class="dt">Ord</span></code> constraint is for the heap property. The element of a <code class="sourceCode haskell"><span class="dt">LeftistHeap</span> a</code> is <code class="sourceCode haskell">a</code>. Its operations are implemented over the next two sections.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">LeftistHeap</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">LeftistHeap</span> a) <span class="fu">=</span> a</a></code></pre></div>
<h2 id="merging-two-heaps">Merging two heaps</h2>
<p>Let’s tackle the most important operation head-on.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">merge <span class="dt">Leaf</span> heap <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb6-2" title="2">merge heap <span class="dt">Leaf</span> <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb6-3" title="3">merge h1<span class="fu">@</span>(<span class="dt">Node</span> x _ left1 right1)</a>
<a class="sourceLine" id="cb6-4" title="4">      h2<span class="fu">@</span>(<span class="dt">Node</span> y _ left2 right2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="kw">if</span> x <span class="fu">&gt;</span> y</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">then</span> mkNode x left1 (merge right1 h2)</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">else</span> mkNode y left2 (merge right2 h1)</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="ot">  mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a <span class="ot">-&gt;</span> <span class="dt">LeftistHeap</span> a</a>
<a class="sourceLine" id="cb6-10" title="10">  mkNode a heap1 heap2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="kw">if</span> rank heap1 <span class="fu">&lt;=</span> rank heap2</a>
<a class="sourceLine" id="cb6-12" title="12">      <span class="kw">then</span> <span class="dt">Node</span> a (rank heap1 <span class="fu">+</span> <span class="dv">1</span>) heap2 heap1</a>
<a class="sourceLine" id="cb6-13" title="13">      <span class="kw">else</span> <span class="dt">Node</span> a (rank heap2 <span class="fu">+</span> <span class="dv">1</span>) heap1 heap2</a></code></pre></div>
<p>The base cases are simple as <code class="sourceCode haskell"><span class="dt">Leaf</span></code> acts as the identity element for <code class="sourceCode haskell">merge</code>.</p>
<p>In the recursive case, we walk over the right-most paths of the input heaps. You can see this in the recursive calls; they never touch the left children.</p>
<p>To preserve the heap property, we recurse on the right child of the argument heap with the bigger label.</p>
<p>To build a new node, we use <code class="sourceCode haskell">mkNode</code> helper rather than <code class="sourceCode haskell"><span class="dt">Node</span></code> constructor directly. The helper does two things. First, it makes the child with the lowest rank the right child. Since the arguments to <code class="sourceCode haskell">mkNode</code> are leftist heaps themselves, this flip ensures the right-most path to <code class="sourceCode haskell"><span class="dt">Leaf</span></code> is still the shortest. Second, it calculates the new rank which is one more than the rank of the right child.</p>
<p>Now what is the complexity of this? At each recursive call we potentially do a flip, increase the rank, and construct a tree node, these are all constant time operations. So the question is how many recursive calls there are. If the leftist heaps being merged have <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> elements inside, we know their right spines are at most length <span class="math inline">\(\left\lfloor lg{(L + 1)}\right\rfloor\)</span> and <span class="math inline">\(\left\lfloor lg{(R + 1)}\right\rfloor\)</span> respectively. Hence, we at most do <span class="math inline">\(\left\lfloor\lg{(L + 1)} + \lg{(R + 1)}\right\rfloor\)</span> calls. So the overall complexity is <span class="math inline">\(O(\lg{(L \times R)})\)</span> which is a subset of <span class="math inline">\(O(\lg{(L + R)})\)</span> (can you see why?). In short, the merge operation is logarithmic in the size of the output.</p>
<p>This is not where the beauty of <code class="sourceCode haskell">merge</code> ends. Recall that most leftist heap elements live outside the right-most path. Then since we only recurse over the right-most path, we never touch the trees where most elements live. We just move them around. In a purely functional language, this means the output tree does not have to allocate new memory for those trees, it can just share them with the input heaps.</p>
<h2 id="every-other-operation">Every other operation</h2>
<p>The remaining operations needed to satisfy the typeclass are as follows.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">isEmpty <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-2" title="2">isEmpty _    <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4">empty <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">singleton x <span class="fu">=</span> <span class="dt">Node</span> x <span class="dv">1</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8">decompose <span class="dt">Leaf</span>                  <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-9" title="9">decompose (<span class="dt">Node</span> x _ left right) <span class="fu">=</span> <span class="dt">Just</span> (x, merge left right)</a></code></pre></div>
<p>From <code class="sourceCode haskell">merge</code> follows everything else. Maximum is maintained at the root, so accessing it is easy. The <code class="sourceCode haskell">decompose</code> operation returns the maximum along with the rest of the heap with the maximum removed by merging the two children of the root. Insertion (the default implementation) creates a singleton heap out of the inserted label and merges it into the heap.</p>
<p>Since <code class="sourceCode haskell">merge</code> has logarithmic complexity, so does <code class="sourceCode haskell">insert</code> and <code class="sourceCode haskell">deleteMax</code>. Since we store the maximum at the root, <code class="sourceCode haskell">findMax</code> runs in constant time.</p>
<p>Conversion from a list is more interesting. The obvious implementation is to fold over the list of elements and insert them into the heap, this turns out not to be the most efficient way. If we instead turn each element into a singleton heap and repeatedly merge two heaps at a time (with multiple passes) until one heap is left, conversion happens in linear time. The following default implementation does exactly that.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">fromList ::</span> [ <span class="dt">Elem</span> heap ] <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb8-2" title="2">fromList xs <span class="fu">=</span> <span class="co">-- O(n) for leftist heaps</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="kw">case</span> go (<span class="fu">map</span> singleton xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-4" title="4">    [ heap ] <span class="ot">-&gt;</span> heap</a>
<a class="sourceLine" id="cb8-5" title="5">    [ ]      <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb8-6" title="6">    _        <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Impossible. Did not converge to a single heap.&quot;</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" title="8">  go [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb8-9" title="9">  go [ x ] <span class="fu">=</span> [ x ]</a>
<a class="sourceLine" id="cb8-10" title="10">  go (x <span class="fu">:</span> y <span class="fu">:</span> rest) <span class="fu">=</span> go (merge x y <span class="fu">:</span> go rest)</a></code></pre></div>
<p>Why does this run in linear time? Assume for simplicity that there are <span class="math inline">\(2^R\)</span> elements. Then in the first pass, we do <span class="math inline">\(2^{R-1}\)</span> <span class="math inline">\(O(\lg{2})\)</span> operations. In the next pass, we do <span class="math inline">\(2^{R-2}\)</span> <span class="math inline">\(O(\lg{4})\)</span>, then <span class="math inline">\(2^{R-3}\)</span> <span class="math inline">\(O(\lg{8})\)</span> operations and so on. So the overall complexity is <span class="math inline">\(O(\sum^{R}_{i = 1}{(\lg{2^i}) 2^{R-i}}\,)\)</span> which is <span class="math inline">\(O(\sum^{R}_{i = 1}{i \; 2^{R-i}}\,)\)</span> and that is <span class="math inline">\(O(2^{R})\)</span>. That is the number of elements we started with, so conversion from a list is done in linear time.</p>
<h1 id="terms-types-and-kinds">Terms, types, and kinds</h1>
<p>Before doing verification with fancy types, we need to understand terms, types, and kinds. Here’s the gist: all terms have types, all types have kinds, and there is no distinction between types and kinds since GHC 8.0, but terms and types (for now) occupy different realms.</p>
<p>For example, just as you can say <code class="sourceCode haskell"><span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span></code>, you can also say <code class="sourceCode haskell"><span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> (<code class="sourceCode haskell"><span class="fu">*</span></code> is a deprecated synonym of <code class="sourceCode haskell"><span class="dt">Type</span></code>; import <code class="sourceCode haskell"><span class="dt">Data.Kind</span></code> for <code class="sourceCode haskell"><span class="dt">Type</span></code>). We can read these as “<code class="sourceCode haskell"><span class="dv">42</span></code> is an <code class="sourceCode haskell"><span class="dt">Int</span></code>”, “<code class="sourceCode haskell"><span class="dt">Int</span></code> is a <code class="sourceCode haskell"><span class="dt">Type</span></code>”, and “<code class="sourceCode haskell"><span class="dt">Type</span></code> is a <code class="sourceCode haskell"><span class="dt">Type</span></code>” (yup, not a typo).</p>
<p>Just as you can use <code>:type</code> or <code>:t</code> learn the type of a term in <code>ghci</code>, you can use <code>:k</code> or <code>:kind</code> to learn the kind of a type.</p>
<p>We now look at types and kinds in more detail. It may be too much information to soak in at once, but the broad-strokes should be enough for this post. For more detailed and broad overview of the subject, see Diogo Castro’s amazing <a href="https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/">blog post</a>. More generally, one can get away without an in-depth understanding of these and still be able to verify data structures. But then we’d be relying on GHC to yell at us when certain extensions are missing and not understand why we’re being yelled at.</p>
<h2 id="proofs-and-contradictions">Proofs and contradictions</h2>
<p>Famously, Ludwig Wittgenstein wasn’t terribly concerned about inconsistencies in mathematics as most were, including Alan Turing. They even have a <a href="https://www.britishwittgensteinsociety.org/wp-content/uploads/documents/lectures/Turing-and-Wittgenstein-on-Logic-and-Mathematics.pdf">direct exchange</a> on this subject. Surprisingly, Haskell’s type system seems to agree more with Wittgenstein than with Turing.</p>
<p>If <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> makes you uncomfortable, you’re right, it is problematic and it leads to <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russel’s paradox</a>. This is one reason people don’t like type-level programming in Haskell. It means as a proof system, Haskell’s type system is inconsistent. What that means is that <em>we don’t have the ability to tell the truth</em>. The expectation due to the <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard correspondance</a> is that if we have a type corresponding to some logical statement, a term for that type (if it exists) is a proof. Inconsistency means, we can have terms that are not valid proofs of the statement, but satisfy the type checker. In particular, <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> leads to diverging terms that can satisfy any proposition.</p>
<p>That said, since Haskell already has <code class="sourceCode haskell"><span class="kw">let</span> x <span class="fu">=</span> x <span class="kw">in</span> x</code>, <code class="sourceCode haskell"><span class="fu">undefined</span></code>, and <code class="sourceCode haskell"><span class="fu">error</span> <span class="st">&quot;QED&quot;</span></code> satisfying types of propositions, we didn’t have the ability to tell the truth to start with. Hence, we are not worse off. At least, this is the argument in Prof. Stephanie Weirich’s <a href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a> as well as <a href="https://downloads.haskell.org/~ghc/8.8.1/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type">the GHC documentation</a>.</p>
<p>One might think existing flaws don’t justify adding new ways to break a system. Ordinarily, that’s right, but contradictions are are infectious. As soon as there is a little crack, it is difficult to contain. So the marginal harm done by <code class="sourceCode haskell"><span class="dt">Type</span><span class="ot"> ::</span> <span class="dt">Type</span></code> is less than expected.</p>
<p>There are such things as <a href="https://en.wikipedia.org/wiki/Paraconsistent_logic"><em>paraconsistent logics</em></a> that try to limit the harm done by contradiction, but they are not employed in type systems as far as I know.</p>
<p>To sum up, Haskell proofs are partial. If a term (proof) corresponding to a type (proposition) compiles, one of two things happened. The term is a valid proof or its evaluation will diverge. In contrast, Agda and Idris proofs are always terminating and are thus valid proofs as long as the type checker says so (up to compiler bugs). Hence, despite the syntactic similarity, you should have more faith in the latter.</p>
<h2 id="why-is-type-a-misnomer">Why is <code class="sourceCode haskell"><span class="dt">Type</span></code> a misnomer?</h2>
<p>The kind <code class="sourceCode haskell"><span class="dt">Type</span></code> has a very confusing name. It should really be named <code class="sourceCode haskell"><span class="dt">LiftedType</span></code>. Let’s understand why.</p>
<p>It has two important features. The term <code class="sourceCode haskell"><span class="fu">undefined</span></code> (or <span class="math inline">\(\bot\)</span> in academic papers) is a valid term for any type with kind <code class="sourceCode haskell"><span class="dt">Type</span></code>. This makes it <em>lifted</em>. Consequently, every type of kind <code class="sourceCode haskell"><span class="dt">Type</span></code> is <em>inhabited</em> by some values.</p>
<p>GHC manual (until recently) called <code class="sourceCode haskell"><span class="dt">Type</span></code> “the kind of types with values”. This is not true. If we enable <code>MagicHash</code> extension, we get access to unlifted types such as <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code>. <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> definitely has values as witnessed by <code class="sourceCode haskell"><span class="dv">42</span><span class="fu">#</span><span class="ot"> ::</span> <span class="dt">Int</span><span class="fu">#</span></code>, but when we query <code class="sourceCode haskell"><span class="fu">:</span>k <span class="dt">Int</span><span class="fu">#</span><span class="ot"> ::</span> <span class="dt">Type</span></code>, we get an error saying “Expecting a lifted type, but <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> is unlifted”. So there are inhabited types without kind <code class="sourceCode haskell"><span class="dt">Type</span></code>.</p>
<p>It is also wrong to say that <code class="sourceCode haskell"><span class="dt">Type</span></code> is the kind of types that definitely has inhabitants. Once again the kind of <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> is <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> and <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> is the only type of that kind. We already know it has inhabitants. In fact, in a sense <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> is superior because <code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Void</span></code> creates a type <code class="sourceCode haskell"><span class="dt">Void</span><span class="ot"> ::</span> <span class="dt">Type</span></code> where the only inhabitants are the degenerate ones such as <code class="sourceCode haskell"><span class="fu">error</span> <span class="st">&quot;Oops!&quot;</span></code> and <code class="sourceCode haskell"><span class="fu">undefined</span></code>. <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code> can claim to be <em>a</em> kind of types that has non-degenerate inhabitants.</p>
<p>As a final piece of evidence about why <code class="sourceCode haskell"><span class="dt">Type</span></code> is a bad name, you can consult <code class="sourceCode haskell"><span class="dt">GHC.Types</span></code> which defines the kind <code class="sourceCode haskell"><span class="dt">Type</span></code> as <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'LiftedRep</span></code>. Even GHC admits that <code class="sourceCode haskell"><span class="dt">Type</span></code> is more specific than what the name implies.</p>
<p>So <code class="sourceCode haskell"><span class="dt">Type</span></code> is a bad name because of non-<code class="sourceCode haskell"><span class="dt">Type</span></code> types! We’ve already seen <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code>, let’s find some more.</p>
<h2 id="type-constructors"><code class="sourceCode haskell"><span class="dt">Type</span></code> constructors</h2>
<p><code class="sourceCode haskell"><span class="dt">Maybe</span></code> takes a <code class="sourceCode haskell"><span class="dt">Type</span></code> and returns a <code class="sourceCode haskell"><span class="dt">Type</span></code>. How about <code class="sourceCode haskell"><span class="dt">Either</span></code>? It takes two <code class="sourceCode haskell"><span class="dt">Type</span></code>s and returns a <code class="sourceCode haskell"><span class="dt">Type</span></code>. You can say they are type-level functions and you wouldn’t be wrong, but we can be more specific. We can say that <code class="sourceCode haskell"><span class="dt">Maybe</span></code> and <code class="sourceCode haskell"><span class="dt">Either</span></code> construct <code class="sourceCode haskell"><span class="dt">Type</span></code>s just like <code class="sourceCode haskell">(<span class="fu">:</span>)</code> and <code class="sourceCode haskell">[]</code> at the term level.</p>
<p>Are <code class="sourceCode haskell"><span class="dt">Maybe</span></code> and <code class="sourceCode haskell"><span class="dt">Either</span></code> types themselves? They are types but not <code class="sourceCode haskell"><span class="dt">Type</span></code>s. Asking <code>ghci</code> reveals that <code class="sourceCode haskell"><span class="dt">Maybe</span></code> has kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">Either</span></code> has kind <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code>.</p>
<p><code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> is not the same thing as <code class="sourceCode haskell"><span class="dt">Type</span></code>, but (here is the confusing part) <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> has the kind <code class="sourceCode haskell"><span class="dt">Type</span></code>. Get your head around that!</p>
<p>We have <code class="sourceCode haskell"><span class="dt">Type</span></code>s; we have things that construct <code class="sourceCode haskell"><span class="dt">Type</span></code>s; and we have unlifted types such as <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code>. What else?</p>
<h2 id="data-type-promotion">Data type promotion</h2>
<p>So far, we’ve only seen inhabited types. <code class="sourceCode haskell"><span class="dt">Int</span></code> and <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> are obviously examples, but <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> is also inhabited since that too has kind <code class="sourceCode haskell"><span class="dt">Type</span></code>. For example, <code class="sourceCode haskell"><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> type checks.</p>
<p>Emphasising inhabitation as a property implies that there must be some uninhabited kinds. In fact, these are the pillars of theorem proving and property encoding in Haskell.</p>
<p>Consider the following <code class="sourceCode haskell"><span class="dt">List</span></code> declaration.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<p>In vanilla Haskell, this generates a type <code class="sourceCode haskell"><span class="dt">List</span></code> and two data constructors <code class="sourceCode haskell"><span class="dt">Nil</span></code> and <code class="sourceCode haskell"><span class="dt">Cons</span></code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="dt">List</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a></code></pre></div>
<p>With <code>DataKinds</code> extension, you also get following.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="dt">'Nil</span><span class="ot">  ::</span> <span class="dt">List</span> a</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="dt">'Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</a></code></pre></div>
<p>Despite looking pretty similar, these are different beasts. Since there is no distinction between types and kinds, the type constructor <code class="sourceCode haskell"><span class="dt">List</span></code> is also a kind constructor. Then, <code class="sourceCode haskell"><span class="dt">'Nil</span></code> and <code class="sourceCode haskell"><span class="dt">'Cons</span></code> are type constructors, but they are not <code class="sourceCode haskell"><span class="dt">Type</span></code> constructors, they are <code class="sourceCode haskell"><span class="dt">List</span> a</code> constructors! All promoted types are automatically uninhabited. So there is no term <code class="sourceCode haskell">t</code> with <code class="sourceCode haskell"><span class="ot">t ::</span> <span class="dt">'Cons</span> <span class="dt">Int</span> <span class="dt">'Nil</span></code>.</p>
<p>This promotion feature alone spawns multiple reasons why people do not like fancy types in Haskell:</p>
<ol type="1">
<li><p>The <code>'</code> prefix of promoted type-constructors is optional, but terms and types are completely separate. So when I type <code class="sourceCode haskell"><span class="dt">Nil</span></code>, GHC figures out whether it is a term or a type constructor depending on the context. In the absence of <code>'</code>, we need to disambiguate ourselves.</p></li>
<li><p>The built-in list type <code class="sourceCode haskell">[a]</code> is automatically promoted. This means there is <code class="sourceCode haskell">[]</code>, the equivalent of <code class="sourceCode haskell"><span class="dt">Nil</span></code>. There is <code class="sourceCode haskell">[]</code>, the type and kind constructor equivalent to <code class="sourceCode haskell"><span class="dt">List</span></code>. Then there is <code class="sourceCode haskell">'[]</code>, the type constructor equivalent to <code class="sourceCode haskell"><span class="dt">'Nil</span></code>. Remember that <code>'</code> is optional. So when I use <code class="sourceCode haskell">[]</code>, we don’t know, if it is the type constructor <code class="sourceCode haskell"><span class="dt">List</span></code> or the type constructor <code class="sourceCode haskell"><span class="dt">Nil</span></code>. Similar situation occurs with tuples, where the term and the type share similar syntax.</p></li>
</ol>
<p>Note that this is the improved state of affairs. Kinds and types used to be separated and there was also a separate kind <code class="sourceCode haskell">[]</code> with sort (the classification of kind) <code class="sourceCode haskell"><span class="dt">BOX</span></code>.</p>
<p>Nevertheless, their existence in GHC is a blessing. They have structure that normal types lack and are good indices to data types. We come back to this when we introduces GADTs.</p>
<h2 id="kind-polymorphism">Kind polymorphism</h2>
<p>Just as there are polymorphic types such as <code class="sourceCode haskell">[a] <span class="ot">-&gt;</span> [a]</code>, there are also polymorphic kinds. In fact, <code class="sourceCode haskell"><span class="dt">'Cons</span></code> has kind <code class="sourceCode haskell">a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</code> where <code class="sourceCode haskell">a</code> is a kind variable. We can see this in <code>ghci</code>.</p>
<p>We kind <code class="sourceCode haskell">a</code> can be <code class="sourceCode haskell"><span class="dt">Type</span></code>,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">'Cons</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="dt">'Cons</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Type</span></a></code></pre></div>
<p>Or it can be the kind of a type constructor such as <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">'Cons</span> <span class="dt">Maybe</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="dt">'Cons</span> <span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">List</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>)'</a></code></pre></div>
<p>We can also use a promoted kind such as <code class="sourceCode haskell"><span class="dt">List</span> a</code>, which results in another kind polymorphic type.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">'Cons</span> <span class="dt">'Nil</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">'Cons</span> <span class="dt">'Nil</span><span class="ot"> ::</span> <span class="dt">List</span> (<span class="dt">List</span> a) <span class="ot">-&gt;</span> <span class="dt">List</span> (<span class="dt">List</span> a)</a></code></pre></div>
<h2 id="levity-polymorphism">Levity polymorphism</h2>
<p>How about the kind of the <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor <code class="sourceCode haskell"><span class="dt">List</span></code>?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">List</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></a></code></pre></div>
<p>The return kind makes sense, it’s a <code class="sourceCode haskell"><span class="dt">Type</span></code> constructor after all, but why the input kind <code class="sourceCode haskell"><span class="dt">Type</span></code>? Since <code class="sourceCode haskell"><span class="dt">Cons</span></code>’s first parameter has type <code class="sourceCode haskell">a</code>, constructing a term <code class="sourceCode haskell"><span class="dt">Cons</span> x xs</code> necessitates a term <code class="sourceCode haskell"><span class="ot">x ::</span> a</code>, hence <code class="sourceCode haskell">a</code> must be a type with kind <code class="sourceCode haskell"><span class="dt">Type</span></code>.</p>
<p>Hopefully, my rant about <code class="sourceCode haskell"><span class="dt">Type</span></code> being a misnomer made you doubt my last statement. What about <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code>? That has inhabitants, so it can equally be <code class="sourceCode haskell">a</code>. More generally, we want <code class="sourceCode haskell">a</code> to be a type that has a runtime representation.</p>
<p>You remember <code class="sourceCode haskell"><span class="dt">TYPE</span></code>? The kind that spawns <code class="sourceCode haskell"><span class="dt">Type</span></code> and <code class="sourceCode haskell"><span class="dt">TYPE</span> <span class="dt">'IntRep</span></code>. Let see what kind it has.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="fu">&gt;</span> <span class="fu">:</span>k <span class="dt">TYPE</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="dt">TYPE</span><span class="ot"> ::</span> <span class="dt">RuntimeRep</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></a></code></pre></div>
<p>Aha! <code class="sourceCode haskell"><span class="dt">TYPE</span></code> constructs things that have runtime representations. So we want the type variable of <code class="sourceCode haskell"><span class="dt">List</span></code> to have kind <code class="sourceCode haskell"><span class="dt">TYPE</span> rep</code>, so that it ranges over everything that has a runtime representation. This idea of abstracting over runtime representations is called <em>levity polymorphism</em>.</p>
<p>But why doesn’t GHC infer that as the kind of <code class="sourceCode haskell">a</code>? Let’s try declaring a levity polymorphic <code>List</code> explicitly.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">List</span> (<span class="ot">a ::</span> <span class="dt">TYPE</span> rep) <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<pre><code>A levity-polymorphic type is not allowed here:
  Type: a
  Kind: TYPE rep</code></pre>
<p>The reason this doesn’t work and why GHC defaults <code class="sourceCode haskell">a</code> to <code class="sourceCode haskell"><span class="dt">Type</span></code> is because if you want to create data type, you need to know the runtime representation in advance so you can lay down the data when generating code. For example, <code class="sourceCode haskell"><span class="dt">Int</span><span class="fu">#</span></code> requires 32 bits but <code class="sourceCode haskell"><span class="dt">Int</span></code> requires a pointer to a thunk, hence 64 bits. Unless you know how big the data is you can’t generate the code (at least not without introducing runtime code generation or indirection which defeats the purpose of unlifted types).</p>
<p>More generally, <a href="https://cs.brynmawr.edu/~rae/papers/2017/levity/levity.pdf">the paper introducing levity polymorphism</a> has the following maxim for its usage:</p>
<blockquote>
<p>Never move or store a levity-polymorphic value.</p>
</blockquote>
<p>This rules out making a function as simple as <code class="sourceCode haskell"><span class="fu">id</span></code> levity polymorphic as well because it moves values.</p>
<p>This raises the question, what can be levity polymorphic then? The classic example is <code class="sourceCode haskell"><span class="fu">error</span></code>. It has type <code class="sourceCode haskell"><span class="dt">String</span> <span class="ot">-&gt;</span> a</code>, so <code>a</code> needs to be runtime representable. It neither stores nor moves a value and <code class="sourceCode haskell">a</code>. Hence, it can be and is levity polymorphic in GHC:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="fu">error</span><span class="ot"> ::</span> <span class="kw">forall</span> (<span class="ot">rep ::</span> <span class="dt">RuntimeRep</span>) (<span class="ot">a ::</span> <span class="dt">TYPE</span> rep)<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>You need <code>-fprint-explicit-runtime-reps</code> flag and the <code>+v</code> option to <code>:t</code> to get the signature.</p>
<pre><code>&gt; :set -fprint-explicit-runtime-reps
&gt; :t +v error</code></pre>
<h2 id="inhabitable-out-of-uninhabitable">Inhabitable out of uninhabitable</h2>
<p>What is the kind of the following data type?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">data</span> <span class="dt">MyProxy</span> a <span class="fu">=</span> <span class="dt">MkMyProxy</span></a></code></pre></div>
<p>If we ask <code>ghci</code>, we get <code class="sourceCode haskell"><span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></code> again. However, this time <code class="sourceCode haskell">a</code> does not appear as a type parameter to the the sole constructor of <code class="sourceCode haskell"><span class="dt">MyProxy</span></code>, so there is no reason for it to have a runtime representation. In principle, the type argument to <code class="sourceCode haskell"><span class="dt">MyProxy</span></code> can be <em>anything</em>. This sounds kind polymorphic.</p>
<p>GHC, by default, assumes that the type variables of a type constructor have the kind <code class="sourceCode haskell"><span class="dt">Type</span></code> even if they can be more generic. If you turn on the <code>PolyKinds</code> extension, GHC correctly infers the kind <code class="sourceCode haskell">k <span class="ot">-&gt;</span> <span class="dt">Type</span></code> to <code class="sourceCode haskell"><span class="dt">Proxy</span></code>, where <code class="sourceCode haskell">k</code> is a kind variable.</p>
<p>This is nice because it is general, but also unmotivated at the moment because we haven’t yet made any use of poly-kindedness. <a href="#propositional-equality">Later</a>, we define a poly-kinded equality type illustrating the utility of kind polymorphism.</p>
<p>With this, you have a good bird’s-eye view of Haskell types and kinds.</p>
<h1 id="verifying-the-leftist-property">Verifying the leftist property</h1>
<p>Let’s encode the leftist property at the type level. That is, we will ensure that each the rank of each right child of a node is less than or equal to the rank of its left child. Clearly, for this we need ranks at the type-level. Our previous implementation used <code class="sourceCode haskell"><span class="dt">Int</span></code>, but we really just need natural numbers. If what we need is type-level natural numbers, we have two options:</p>
<ol type="1">
<li>Import <code class="sourceCode haskell"><span class="dt">GHC.TypeLits</span></code>, which uses compiler magic to define a <code class="sourceCode haskell"><span class="dt">Nat</span></code> <em>kind</em> where integer literals can be used at type-level.</li>
<li>Define a <code class="sourceCode haskell"><span class="dt">Nat</span></code> kind inductively.</li>
</ol>
<p>The advantage of (1) is it is efficient and most things we need are already proved for us. The advantage of (2) is that it is not compiler magic and we get to see how theorem proving and faking dependent types in Haskell work in action. Hence, we’ll do (2).</p>
<p>Note that if you try to reproduce this implementation using (1), you should probably use the <a href="http://hackage.haskell.org/package/singletons"><code>singletons</code> library</a> to fake dependent types and the fantastic GHC type checker plugin <a href="http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.7"><code>ghc-typelits-natnormalise</code></a> to prove theorems about natural numbers. The cost of using efficient natural numbers is to give up the inductive definition which means proving things by hand is difficult.</p>
<p>Here’s the plan. We first invent natural numbers and <span class="math inline">\(\leq\)</span>. Then we forget about the operations on heaps and try to represent the data structure adequately. Then we attempt to define <code>merge</code> on our instance and fail. At which point we provde some lemmas about natural numbers, then try to implement <code>merge</code> again and succeed.</p>
<h2 id="natural-numbers">Natural numbers</h2>
<p>We need the type-level natural numbers and <span class="math inline">\(\leq\)</span> relation between them. So let’s define them.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>This gives us a type and a kind <code>Nat</code>, data constructors <code>Z :: Nat</code> and <code>S :: Nat -&gt; Nat</code> and type constructors <code>'Z :: Nat -&gt; Nat</code> and <code>'S :: Nat -&gt; Nat</code>.</p>
<h3 id="gadts">GADTs</h3>
<p>Good, we have type level natural numbers, now we need the <code>&lt;=</code> relation. To define that, we’ll need Generalised Algebraic Data Types (GADTs) enabled via <code>GADTs</code> extension. This gives us an alternative syntax for declaring data types and the ability to discriminate types based on constructors. The <code>Nat</code> data type above can be translated to the GADT syntax with exactly the same semantics. You’d need also need the <code>KindSignatures</code> extension to make the optional kind annotation next to <code>Nat</code> work.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">AnotherNat</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="dt">AZ</span><span class="ot"> ::</span>               <span class="dt">AnotherNat</span></a>
<a class="sourceLine" id="cb23-3" title="3">  <span class="dt">AS</span><span class="ot"> ::</span> <span class="dt">AnotherNat</span> <span class="ot">-&gt;</span> <span class="dt">AnotherNat</span></a></code></pre></div>
<p>This is just a more verbose way of defining <code>Nat</code>. GADTs flex their muscles, when they encode useful information in a type. Consider the following variant on natural numbers which encode whether the number is zero or not at the type-level.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">data</span> <span class="dt">Zeroness</span> <span class="fu">=</span> <span class="dt">DefinitelyZero</span> <span class="fu">|</span> <span class="dt">NonZero</span></a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="kw">data</span> <span class="dt">TaggedNat</span><span class="ot"> ::</span> <span class="dt">Zeroness</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-4" title="4">  <span class="dt">TZ</span><span class="ot"> ::</span>          <span class="dt">TaggedNat</span> <span class="dt">'DefinitelyZero</span></a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="dt">TS</span><span class="ot"> ::</span> <span class="dt">Nat</span> a <span class="ot">-&gt;</span> <span class="dt">TaggedNat</span> <span class="dt">'NonZero</span></a></code></pre></div>
<p>What this says is that if you choose the constructor <code>TZ</code>, you’ll get a natural number tagget with <code>DefinitelyZero</code>, if you use the <code>TS</code> constructor regardless what kind of natural is passed to it, you get a <code>NonZero</code> natural number.</p>
<p>This is useful because then we can write a total function a <code>div :: TaggedNat a -&gt; TaggedNat NonZero -&gt; TaggedNat a</code> and types ensure that you won’t divide by zero.</p>
<p>For the purposes of this post, we don’t actually need naturals keeping track of whether their “zeroness”. The vanilla data type declaration works fine, but introducing <code>(&lt;=)</code> as a first <code>GADT</code> is just mean.</p>
<h3 id="less-than-or-equal-to-relation">Less than or equal to relation</h3>
<p>With <code>TypeOperators</code> enabled to use infix operators at type level, we can define <code>(&lt;=)</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">data</span><span class="ot"> (&lt;=) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="dt">Base</span><span class="ot">   ::</span>             <span class="dt">'Z</span> <span class="fu">&lt;=</span> <span class="dt">'Z</span></a>
<a class="sourceLine" id="cb25-3" title="3">  <span class="dt">Single</span><span class="ot"> ::</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span>    n <span class="fu">&lt;=</span> <span class="dt">'S</span> m</a>
<a class="sourceLine" id="cb25-4" title="4">  <span class="dt">Double</span><span class="ot"> ::</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="fu">&lt;=</span> <span class="dt">'S</span> m</a></code></pre></div>
<p>What does this say? We are defining a relation that takes two <code>Nat</code>s, so far so good, and it produces a data type, which might sound a bit weird. Isn’t it more natural to produce a type of kind <code>Bool</code> to say whether it holds or not? Well, we could do that using type families (a similar example will follow later on). But this GADT encoding of the relation (which has to produce kind <code>Type</code>) records a series of steps that gets us to the desired <span class="math inline">\(n \leq m\)</span> from an indisputable fact.</p>
<p>The indisputable fact is <span class="math inline">\(0 \leq 0\)</span> encoded by the <code>Base</code> constructor, then by wrapping it with a series of <code>Single</code>s and <code>Double</code>s, we try to produce the desired inequality <span class="math inline">\(n \leq m\)</span>. <code>Single</code> and <code>Double</code> encodes the following mathematical statements <span class="math inline">\(n \leq m \implies n \leq m + 1\)</span>, and <span class="math inline">\(n \leq m \implies n + 1 \leq m + 1\)</span>. Hopefully, neither are controversial as our verification claims hinge on these being sound.</p>
<p>For example, to establish <span class="math inline">\(1 \leq 2\)</span> we need to give a term of the type <code>'S 'Z &lt;= 'S ('S 'Z)</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="ot">oneLEQtwo ::</span> <span class="dt">'S</span> <span class="dt">'Z</span> <span class="fu">&lt;=</span> <span class="dt">'S</span> (<span class="dt">'S</span> <span class="dt">'Z</span>)</a>
<a class="sourceLine" id="cb26-2" title="2">oneLEQtwo <span class="fu">=</span> <span class="dt">Single</span> <span class="fu">$</span> <span class="dt">Double</span> <span class="fu">$</span> <span class="dt">Base</span></a></code></pre></div>
<p>that is to say from <span class="math inline">\(0 \leq 0\)</span>, we can get to <span class="math inline">\(1 \leq 1\)</span>, and from there we can get to <span class="math inline">\(1 \leq 2\)</span>.</p>
<p>Soundness is one question and <em>completeness</em> is another. Is it the case that by applying <code>Single</code> and <code>Double</code> to <code>Base</code>, you can get to any <span class="math inline">\(n \leq m\)</span> that holds? The answer is yes, but we won’t prove it in this post. In fact there are multitude of ways of proving a valid <span class="math inline">\(n \leq m\)</span>. Just as an example, we’ll give another proof of <code>oneLEQtwo</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="ot">oneLEQtwo' ::</span> <span class="dt">'S</span> <span class="dt">'Z</span> <span class="fu">&lt;=</span> <span class="dt">'S</span> (<span class="dt">'S</span> <span class="dt">'Z</span>)</a>
<a class="sourceLine" id="cb27-2" title="2">oneLEQtwo' <span class="fu">=</span> <span class="dt">Double</span> <span class="fu">$</span> <span class="dt">Single</span> <span class="fu">$</span> <span class="dt">Base</span></a></code></pre></div>
<p>You might have noticed that, the order at which we apply <code>Double</code> and <code>Single</code> does not matter. So to produce a valid <span class="math inline">\(n \leq m\)</span>, we can start with <code>Base</code> that is <span class="math inline">\(0 \leq 0\)</span>, we need to apply <span class="math inline">\(m - n\)</span> <code>Single</code>s and <span class="math inline">\(n\)</span> <code>Double</code>s in any order to produce <span class="math inline">\(n \leq m\)</span>.</p>
<h3 id="singletons-faking-dependent-types">Singletons: faking dependent types</h3>
<p>We can use the algorithm for reaching to any valid <span class="math inline">\(n \leq m\)</span> to recover <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> out of a given inequality. What would be the type of a function doing that? We could try the following.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">recoverAttempt ::</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> (n,m)</a>
<a class="sourceLine" id="cb28-2" title="2">recoverAttempt <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>This doesn’t work because <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> have kind <code>Nat</code> but we need them to be <code>Type</code>s if we are going to produce a term at the value level. That is we need dependent typing.</p>
<p>Sadly, Haskell is not there yet, so we need to fake it using <em>singletons</em>. The idea is to create an indexed data type (via GADTs), so that there is exactly one term for each indexing type. That is all a bit vague, let’s just do it for natural numbers.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">data</span> <span class="dt">SNat</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">'Z</span></a>
<a class="sourceLine" id="cb29-3" title="3">  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n)</a></code></pre></div>
<p>You see while the type <code>'Z</code> has kind <code>Nat</code>, the type <code>SNat 'Z</code> has kind <code>Type</code> and it has exactly one inhabitant that is <code>SZ</code>. This is true for all types of kind <code>Nat</code>. Hence, we can use the singleton type <code>SNat n :: Type</code> as the term-level representatives of <code>n :: Nat</code>.</p>
<p>Now, we can write the recovery function.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="ot">recover ::</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n, <span class="dt">SNat</span> m)</a>
<a class="sourceLine" id="cb30-2" title="2">recover <span class="dt">Base</span> <span class="fu">=</span> (<span class="dt">SZ</span>, <span class="dt">SZ</span>)</a>
<a class="sourceLine" id="cb30-3" title="3">recover (<span class="dt">Single</span> nLEQsm) <span class="fu">|</span> (x,y) <span class="ot">&lt;-</span> recover nLEQsm <span class="fu">=</span> (   x, <span class="dt">SS</span> y)</a>
<a class="sourceLine" id="cb30-4" title="4">recover (<span class="dt">Double</span> nLEQm)  <span class="fu">|</span> (x,y) <span class="ot">&lt;-</span> recover nLEQm  <span class="fu">=</span> (<span class="dt">SS</span> x, <span class="dt">SS</span> y)</a></code></pre></div>
<p>We are already using the inductive structure of <code>n &lt;= m</code>. The <code>Single</code> constructor increments the right side of <code>&lt;=</code> and <code>Double</code> increments both sides, so we turn these constructors on explicit increments to recover the singletons corresponding to <code>n</code> and <code>m</code>.</p>
<h2 id="rank-encoded-leftist-heaps">Rank encoded leftist heaps</h2>
<p>We have everything needed to encode the leftist property of a leftist heap into data type. Since the leftist property relates the ranks of subheaps and the current heap, we first create <code>Rank</code> data type that encodes the rank using a type-level <code>Nat</code>. We also define a helper to increment the rank for later use.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">newtype</span> <span class="dt">Rank</span> n <span class="fu">=</span> <span class="dt">Rank</span> {<span class="ot"> _unRank ::</span> <span class="dt">SNat</span> n }</a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="ot">inc ::</span> <span class="dt">Rank</span> rank <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> rank)</a>
<a class="sourceLine" id="cb31-4" title="4">inc (<span class="dt">Rank</span> snat) <span class="fu">=</span> <span class="dt">Rank</span> (<span class="dt">SS</span> snat)</a></code></pre></div>
<p>Since the heaps will be indexed by the heap rank, we need to use GADTs again.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">data</span> <span class="dt">SafeHeap</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="dt">Leaf'</span><span class="ot"> ::</span> <span class="dt">SafeHeap</span> <span class="dt">'Z</span> a</a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="dt">Node'</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> m)             <span class="co">-- Node' data</span></a>
<a class="sourceLine" id="cb32-4" title="4">        <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> n a <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> m a <span class="co">-- Children</span></a>
<a class="sourceLine" id="cb32-5" title="5">        <span class="ot">-&gt;</span> m <span class="fu">&lt;=</span> n                       <span class="co">-- Leftist invariant</span></a>
<a class="sourceLine" id="cb32-6" title="6">        <span class="ot">-&gt;</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> m) a</a></code></pre></div>
<p>After all this work, the data type declaration does not look so bad. The <code>Leaf'</code> constructor creates a <code>SafeHeap</code> of rank 0. The <code>Node'</code> constructor grows the heap only when we can show that the rank of the right subheap is less than or equal to that of the left subheap. Further, the resulting heap has rank one more than that of the right subheap.</p>
<p>What did we just do? We created a data type whose inhabitants are either vacuous (infinite loop, <code>undefined</code>, etc.) or that it is a tree satisfying the leftist property. Let’s try some examples.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="ot">heap1 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></a>
<a class="sourceLine" id="cb33-2" title="2">heap1 <span class="fu">=</span> <span class="dt">Leaf'</span></a></code></pre></div>
<p>This fails because the <code>Leaf'</code> constructor forces the rank to be <code>'Z</code> instead of <code>'S 'Z</code> as given in the type signature.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">heap2 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></a>
<a class="sourceLine" id="cb34-2" title="2">heap2 <span class="fu">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) <span class="dt">Leaf'</span> <span class="dt">Leaf'</span> <span class="dt">Base</span></a></code></pre></div>
<p>This type checks because <code>Leaf'</code>s have rank <code>'Z</code> and <code>Base</code> proves <code>'Z &lt;= 'Z</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="ot">heap3 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></a>
<a class="sourceLine" id="cb35-2" title="2">heap3 <span class="fu">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) heap2' <span class="dt">Leaf'</span> (<span class="dt">Single</span> <span class="dt">Base</span>)</a></code></pre></div>
<p>This also type checks because the right child still has a lower rank (<code>'Z</code>) than the left child (<code>'S 'Z</code>) and we can prove <code>'Z &lt;= 'S 'Z</code> via <code>Single Base</code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="ot">heap4 ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) <span class="dt">Int</span></a>
<a class="sourceLine" id="cb36-2" title="2">heap4 <span class="fu">=</span> <span class="dt">Node'</span> <span class="dv">42</span> (<span class="dt">'SS</span> <span class="dt">'SZ</span>) <span class="dt">Leaf'</span> heap2' <span class="fu">???</span></a></code></pre></div>
<p>Unless we replace <code>???</code> with a fallacious term such as <code>undefined</code>, we won’t be able to find a proof for <code>'S 'Z &lt;= 'Z</code>, hence whatever we put won’t type check. This is precisely how the data type prevents us from violating the leftist property.</p>
<p>We just made terms that violate the leftist property illegal. Pretty cool, huh?</p>
<h2 id="heap-instance-for-safeheap">Heap instance for SafeHeap</h2>
<p>So most people who read up on type-level programming gets to the previous stage of making property violating terms illegal. The next step is to operate on the data structure, which is where things get complicated. Say that we tried to make <code>SafeHeap rank a</code> an instance of <code>Heap</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">SafeHeap</span> rank a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-2" title="2">  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">SafeHeap</span> rank a) <span class="fu">=</span> a</a></code></pre></div>
<p>We’re already in a bad place. This forces the type of <code>merge</code> to be <code>SafeHeap rank a -&gt; SafeHeap rank a -&gt; SafeHeap rank a</code>. This is not at all what we want. We want to be able to merge heaps of different ranks as we did in the untyped implementation. Further, this signature requires us to produce a heap of rank identical to the input heaps. This is clearly not going to fly.</p>
<p>Let’s say that we gave up on the type class and decided to define all the operations at the top-level. Then we could give <code>merge</code> the type <code>SafeHeap rank1 a -&gt; SafeHeap rank2 a -&gt; SafeHeap (Fx rank1 rank2) a</code>. Here <code>Fx</code> is some type level function on <code>rank1</code> and <code>rank2</code>. This allows inputting heaps of different ranks, but we still need to figure out the rank of the output. This signature presupposes that to be a function of <code>rank1</code> and <code>rank2</code>, but in fact it <em>depends</em> on the whole input heaps. The word “depend” should raise a red flag. Do we need to create singletons for <code>SafeHeap</code>s as well now? Normally, you get to this question and give up on the whole approach and revert back to vanilla types (at least I used to). Clearly, this line of thinking is not productive.</p>
<p>The question we should be asking is what was our original goal? It was to preserve the leftist property. Does that really require establishing the effect of operations on the rank of the heap at type level? No, not really. If we are talking about the <code>merge</code> operation what we want is to input two <code>SafeHeap</code>s of whatever rank and produce some <code>SafeHeap</code> of whatever rank. The fact that the output is <code>SafeHeap</code> is enough to ensure the leftist property is preserved, which is our goal.</p>
<p>The way to do that is to hide the rank. This can be done using the <code>ExistentialQuantification</code> extension which gives us existential types. Let’s do that for <code>SafeHeap</code>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">data</span> <span class="dt">SomeSafeHeap</span> label <span class="fu">=</span> <span class="kw">forall</span> rank<span class="fu">.</span> <span class="dt">SSH</span> (<span class="dt">SafeHeap</span> rank label)</a></code></pre></div>
<p>Although it uses the keyword <code>forall</code> what we really mean is “within <code>SomeSafeHeap a</code> there exists a <code>rank</code> such that <code>SafeHeap rank a</code>”. Hence, the name existential types. So the type instance we are after is the following:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">instance</span> <span class="dt">Ord</span> label <span class="ot">=&gt;</span> <span class="dt">Heap</span> (<span class="dt">SomeSafeHeap</span> label) <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-2" title="2">  <span class="kw">type</span> <span class="dt">Elem</span> (<span class="dt">SomeSafeHeap</span> label) <span class="fu">=</span> label</a></code></pre></div>
<p>The type of <code>merge</code> now is <code>SomeSafeHeap a -&gt; SomeSafeHeap a -&gt; SomeSafeHeap a</code> which makes no assertion about the ranks of the input or the output, yet everything involved is a leftist heap. This is exactly what we want.</p>
<p><strong>The key take away:</strong> if you use fancy types, reach for the existential as soon as possible.</p>
<p>This is not to say that you shouldn’t try to implement operations that requires relating ranks of inputs and outputs. If it is straightforward, it will give you more guarantees, which is yey! The question is whether it is worth it.</p>
<p>The <code>singleton</code> function for <code>SomeSafeHeap a</code> is a trivial example of this. We know that the singleton heap should have rank 1 at compile time. Since rank information is hidden behind an existential, there is nothing preventing us from defining <code>singleton x</code> to be <code>empty</code>, which type checks fine. However, if we extract the <code>SafeHeap ('S 'Z) a</code> into its own definition, we can reduce the likelihood of such a mistake.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1">singleton x <span class="fu">=</span> <span class="dt">SSH</span> singleton'</a>
<a class="sourceLine" id="cb40-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="ot">  singleton' ::</span> <span class="dt">SafeHeap</span> (<span class="dt">'S</span> <span class="dt">'Z</span>) a</a>
<a class="sourceLine" id="cb40-4" title="4">  singleton' <span class="fu">=</span> <span class="dt">Node'</span> x (<span class="dt">Rank</span> (<span class="dt">SS</span> <span class="dt">SZ</span>)) <span class="dt">Leaf'</span> <span class="dt">Leaf'</span> <span class="dt">Base</span></a></code></pre></div>
<h2 id="merging-safe-heaps">Merging safe heaps</h2>
<p>Here’s the partial code for the <code>merge</code> operation on safe heaps.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1">merge (<span class="dt">SSH</span> <span class="dt">Leaf'</span>) heap <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb41-2" title="2">merge heap (<span class="dt">SSH</span> <span class="dt">Leaf'</span>) <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb41-3" title="3">merge heap1<span class="fu">@</span>(<span class="dt">SSH</span> (<span class="dt">Node'</span> x _ left1 right1 _))</a>
<a class="sourceLine" id="cb41-4" title="4">      heap2<span class="fu">@</span>(<span class="dt">SSH</span> (<span class="dt">Node'</span> y _ left2 right2 _)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-5" title="5">  <span class="kw">if</span> x <span class="fu">&gt;</span> y</a>
<a class="sourceLine" id="cb41-6" title="6">    <span class="kw">then</span> mkNode x (<span class="dt">SSH</span> left1) (merge (<span class="dt">SSH</span> right1) heap2)</a>
<a class="sourceLine" id="cb41-7" title="7">    <span class="kw">else</span> mkNode y (<span class="dt">SSH</span> left2) (merge (<span class="dt">SSH</span> right2) heap1)</a>
<a class="sourceLine" id="cb41-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-9" title="9"><span class="ot">  mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a</a>
<a class="sourceLine" id="cb41-10" title="10">  mkNode a (<span class="dt">SSH</span> h1) (<span class="dt">SSH</span> h2) <span class="fu">=</span> _</a></code></pre></div>
<p>This bit is almost identical to the unverified version except for some unwrapping and wrapping with <code>SSH</code>. This makes sense because as we pointed in the unverified version, <code>mkNode</code> is where the leftist property is preserved by placing the heap with the smaller rank to the right.</p>
<h3 id="comparing-without-forgetting">Comparing without forgetting</h3>
<p>We used to do it using the term-level <code>(&lt;=)</code> operator on the rank which was an <code>Int</code>. So it seems all we need is to provide an analogous operator for <code>SNat</code>s. However, this omits the fact that we also need the proof that the rank of the right child is less than the rank of the left child and a <code>compare</code> or <code>(&lt;=)</code> like operator despite determening that at term-level forgets about it immediately returning an <code>Ordering</code> or a <code>Bool</code> only.</p>
<p>What we want here is <em>connexity</em>, that is given any <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span>, either <span class="math inline">\(n \leq m\)</span> or <span class="math inline">\(m \leq n\)</span>. This is the case as <span class="math inline">\(\leq\)</span> on natural numbers is a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a>. It is also the case that this property is very natural to express as a function.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">lemConnexity ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Either</span> (n <span class="fu">&lt;=</span> m) (m <span class="fu">&lt;=</span> n)</a>
<a class="sourceLine" id="cb42-2" title="2">lemConnexity <span class="dt">SZ</span> y <span class="fu">=</span> <span class="dt">Left</span>  (lemZLEQAll y)</a>
<a class="sourceLine" id="cb42-3" title="3">lemConnexity x <span class="dt">SZ</span> <span class="fu">=</span> <span class="dt">Right</span> (lemZLEQAll x)</a></code></pre></div>
<p>The base cases are simple, we need to show <span class="math inline">\(0 \leq m\)</span> and <span class="math inline">\(0 \leq n\)</span>. Since <span class="math inline">\(0 \leq x\)</span> holds for all <span class="math inline">\(x\)</span>, we can prove a lemma to handle both. We imagine for the moment that <code>lemZLEQAll :: SNat n -&gt; Z' &lt;= n</code> exists. This make-believe with lemmas is basically how top-down proofs work. As you focus on the proof at hand, you postulate reasonable looking statements.</p>
<p>The inductive case is equally simple and gives a good opportunity to introduce <em>typed holes</em>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1">lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="fu">=</span> _</a></code></pre></div>
<p>So the way you work with GADTs is that you pattern match and see what you got. At this point the type for the type hole <code>_</code> is <code>Either ('S n1 &lt;= 'S n2) ('S n2 &lt;= 'S n1)</code> where <code>x</code> is <code>'SNat n2</code> and <code>y</code> is <code>SNat n1</code>. So we can recursively call <code>lemConnexity</code> to obtain a proof of <code>Either (n1 &lt;= n2) (n2 &lt;= n1)</code> and pattern match.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1">lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-2" title="2"> <span class="kw">case</span> lemConnexity x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-3" title="3">   <span class="dt">Left</span>  xLEQy <span class="ot">-&gt;</span> _</a>
<a class="sourceLine" id="cb44-4" title="4">   <span class="dt">Right</span> yLEQx <span class="ot">-&gt;</span> _</a></code></pre></div>
<p>Now we have two typed holes. We are trying to get to <code>Either ('S n1 &lt;= 'S n2) ('S n2 &lt;= 'S n1)</code> from <code>xLEQy :: n1 &lt;= n2</code> and <code>yLEQX :: n2 &lt;= n1</code> respectively. The <code>Double</code> constructor produces a new inequality from a valid inequality by incrementing both sides. Combined with <code>Left</code> or <code>Right</code> depending on the case, we can provide a term for the desired type in both cases.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1">lemConnexity (<span class="dt">SS</span> x) (<span class="dt">SS</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-2" title="2"> <span class="kw">case</span> lemConnexity x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-3" title="3">   <span class="dt">Left</span>  xLEQy <span class="ot">-&gt;</span> <span class="dt">Left</span>  (<span class="dt">Double</span> xLEQy)</a>
<a class="sourceLine" id="cb45-4" title="4">   <span class="dt">Right</span> yLEQx <span class="ot">-&gt;</span> <span class="dt">Right</span> (<span class="dt">Double</span> yLEQx)</a></code></pre></div>
<p>We are now almost done with <code>lemConnexity</code>. Earlier we postulated <code>lemZLEQAll</code> for the base cases, we still need to prove that. That is proven by induction over the natural numbers.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="ot">lemZLEQAll ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">'Z</span> <span class="fu">&lt;=</span> n</a>
<a class="sourceLine" id="cb46-2" title="2">lemZLEQAll <span class="dt">SZ</span>     <span class="fu">=</span> <span class="dt">Base</span></a>
<a class="sourceLine" id="cb46-3" title="3">lemZLEQAll (<span class="dt">SS</span> x) <span class="fu">=</span> <span class="dt">Single</span> (lemZLEQAll x)</a></code></pre></div>
<p>That’s it. We have proved some facts about natural numbers. It does not feel so bad, mostly, it’s just induction and looking at typed holes. The ergonomics of doing that compared to Agda, Idris, or any other proof asistant is really lacking. When we leave a hole, the output is cluttered, it is not easy to see what is available in the context which is usually how you figure out how to prove things. So beyond these basic facts life can be challenging, but I feel for most data structures, you can get good mileage out of basic facts. If anything Haskell forces you to make your lemmas as granular as possible.</p>
<h3 id="making-nodes-with-proofs">Making nodes with proofs</h3>
<p>By harnessing <code>lemConnexity</code>, implementing <code>mkNode</code> is a breeze.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="ot">mkNode ::</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a <span class="ot">-&gt;</span> <span class="dt">SomeSafeHeap</span> a</a>
<a class="sourceLine" id="cb47-2" title="2">mkNode a (<span class="dt">SSH</span> h1) (<span class="dt">SSH</span> h2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb47-3" title="3">  <span class="kw">case</span> lemConnexity (_unRank <span class="fu">.</span> rank <span class="fu">$</span> h1) (_unRank <span class="fu">.</span> rank <span class="fu">$</span> h2) <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-4" title="4">    <span class="dt">Left</span>  r1LEQr2 <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node'</span> a (inc <span class="fu">$</span> rank h1) h2 h1 r1LEQr2</a>
<a class="sourceLine" id="cb47-5" title="5">    <span class="dt">Right</span> r2LEQr1 <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node'</span> a (inc <span class="fu">$</span> rank h2) h1 h2 r2LEQr1</a></code></pre></div>
<p>The lemma tells us which heap has the lower rank (hence needs to be the right child) as well as giving us a proof for it which is all that is needed to construct a <code>Node'</code>.</p>
<h1 id="verifying-the-heap-property">Verifying the heap property</h1>
<p>Let’s do it one last time, but this time with both the heap and the leftist property.</p>
<p>So what is the heap property mathematically? For a node <span class="math inline">\(n\)</span> and its children <span class="math inline">\(l\)</span> and <span class="math inline">\(r\)</span>, we have <span class="math inline">\(\mathit{label}(l) \leq \mathit{label}(n)\)</span> and <span class="math inline">\(\mathit{label}(r) \leq \mathit{label}(n)\)</span>.</p>
<p>You can immediately see that in addition to having the rank available at the type level, we now also need the label. So far we allowed labels to be of an arbitrary <code>Type</code>. To simplify the situation, we now decree that the labels are based off of <code>SNat</code>s, allowing us to build on the existing theory of natural numbers.</p>
<h2 id="rank-and-label-encoded-leftist-heaps">Rank and label encoded leftist heaps</h2>
<p>To avoid confusion we wrap the label <code>SNat</code>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">newtype</span> <span class="dt">Label</span> n <span class="fu">=</span> <span class="dt">Label</span> {<span class="ot"> _unLabel ::</span> <span class="dt">SNat</span> n }</a></code></pre></div>
<p>All the machinery needed to create a data type that makes heap property violating terms illegal is already built. So here is the data type.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="kw">data</span> <span class="dt">SaferHeap</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" title="2">  <span class="dt">Leaf''</span><span class="ot"> ::</span> <span class="dt">SaferHeap</span> <span class="dt">'Z</span> <span class="dt">'Z</span></a>
<a class="sourceLine" id="cb49-3" title="3">  <span class="dt">Node''</span><span class="ot"> ::</span> <span class="dt">Label</span> a <span class="ot">-&gt;</span> <span class="dt">Rank</span> (<span class="dt">'S</span> m)         <span class="co">-- Node' data</span></a>
<a class="sourceLine" id="cb49-4" title="4">         <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> n b <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> m c <span class="co">-- Children</span></a>
<a class="sourceLine" id="cb49-5" title="5">         <span class="ot">-&gt;</span> m <span class="fu">&lt;=</span> n                         <span class="co">-- Leftist property</span></a>
<a class="sourceLine" id="cb49-6" title="6">         <span class="ot">-&gt;</span> b <span class="fu">&lt;=</span> a <span class="ot">-&gt;</span> c <span class="fu">&lt;=</span> a               <span class="co">-- Heap property</span></a>
<a class="sourceLine" id="cb49-7" title="7">         <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> (<span class="dt">'S</span> m) a</a></code></pre></div>
<p><code>SaferHeap</code> looks a lot like <code>SafeHeap</code>, except for the fancy-typed label and two more inequalities to ensure the heap property is satisfied in <code>Node''</code>.</p>
<p><code>Leaf''</code> carries a type-level label of <code>'Z</code> now. Every <code>SaferHeap</code> needs a type-level label to form the type. Using <code>'Z</code> is a nice work around because it is the least natural number, hence it doesn’t inhibit construction of a <code>Node''</code> with any label.</p>
<p>There are two immediate alternatives to this:</p>
<ol type="1">
<li><p>Use <code>Maybe Nat</code> rather than <code>Nat</code> for the <code>SafeHeap</code> label, but that requires us to change the heap property to so that rather than requiring <code>b &lt;=  a</code>, we require “given <code>b</code> is <code>'Just b'</code>, <code>b' &lt;= a</code>” and similarly for <code>c &lt;= a</code>.</p></li>
<li><p>Use <code>Maybe Nat</code> again, but instead of changing the heap property in <code>Node''</code>, we have three <code>Node''</code> like constructors: one with both children having <code>'Just</code> labels, one with only the left child having a <code>'Just</code> label, and one with neither having <code>'Just</code> labels (why don’t we need the fourth case?). This way the heap property remains as simple inequalities.</p></li>
</ol>
<p>In a way, (1) and (2) are equivalent solutions. One might say they are cleaner than exploiting <code>'Z</code> being the least element in a total order. Both, however, especially (2) complicates every function that needs to scrutinise a <code>SaferHeap</code>.</p>
<p>The next step is to wrap the wrap the data type in an existential like the last time.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">data</span> <span class="dt">SomeSaferHeap</span> <span class="fu">=</span> <span class="kw">forall</span> rank label<span class="fu">.</span> <span class="dt">SSH'</span> (<span class="dt">SaferHeap</span> rank label)</a></code></pre></div>
<p>At this point, you might like to construct some <code>SaferHeap</code>s to see the ergonomics of constructing this type by hand as well as get the satisfaction of type errors due to heap property violation. I think you’ll agree that constructing nested <code>Node''</code>s is tedious, but luckily we use the nice interface <code>Heap</code> instead.</p>
<h2 id="heap-instance-for-saferheap">Heap instance for SaferHeap</h2>
<p>Just as before the instance is for the existentially wrapped type.</p>
<pre><code>instance Heap SomeSaferHeap where
  type Elem SomeSaferHeap = Nat</code></pre>
<p>The <code>Elem</code> instance for <code>SomeSaferHeap</code> is interesting because, we don’t actually store <code>Nat</code>s anywhere in the nodes, we only store <code>SNat</code>s. Then <code>insert</code> will require conversion from <code>SNat</code> to <code>Nat</code> and <code>findMax</code> from <code>Nat</code> to <code>SNat</code>. The <code>SNat</code> to <code>Nat</code> direction is easy.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1"><span class="ot">demote ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb52-2" title="2">demote <span class="dt">SZ</span>     <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb52-3" title="3">demote (<span class="dt">SS</span> n) <span class="fu">=</span> <span class="dt">S</span> (demote n)</a></code></pre></div>
<p>But the opposite direction would have a signature <code>Nat -&gt; SNat n</code>. Let’s try to write that.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="ot">promoteAttempt ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</a>
<a class="sourceLine" id="cb53-2" title="2">promoteAttempt <span class="dt">Z</span>                                <span class="fu">=</span> <span class="dt">SZ</span></a>
<a class="sourceLine" id="cb53-3" title="3">promoteAttempt (<span class="dt">S</span> n) <span class="fu">|</span> snat <span class="ot">&lt;-</span> promoteAttempt n <span class="fu">=</span> <span class="dt">SS</span> snat</a></code></pre></div>
<p>Well, this does not type check, because one branch returns <code>SNat 'Z</code> and the other <code>SNat ('S m)</code> for some <code>m</code>. Neither <code>'Z</code> nor <code>'S</code> unifies with the free variable <code>n</code>.</p>
<p>Since our heap operations are on existentially wrapped types, we know that we only need the promoted type-level <code>n</code> during the course of a function definition only. So we do not really care what <code>n</code> is going to be so long as there is <em>some</em> n that we can embed in the heap. This smells like an existential. So the <code>promote</code> should return an existentially wrapped <code>Nat</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">data</span> <span class="dt">SomeNat</span> <span class="fu">=</span> <span class="kw">forall</span> n<span class="fu">.</span> <span class="dt">SomeNat</span> (<span class="dt">SNat</span> n)</a>
<a class="sourceLine" id="cb54-2" title="2"></a>
<a class="sourceLine" id="cb54-3" title="3"><span class="ot">promote ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">SomeNat</span></a>
<a class="sourceLine" id="cb54-4" title="4">promote <span class="dt">Z</span>                                 <span class="fu">=</span> <span class="dt">SomeNat</span> <span class="dt">SZ</span></a>
<a class="sourceLine" id="cb54-5" title="5">promote (<span class="dt">S</span> n) <span class="fu">|</span> <span class="dt">SomeNat</span> snat <span class="ot">&lt;-</span> promote n <span class="fu">=</span> <span class="dt">SomeNat</span> <span class="fu">$</span> <span class="dt">SS</span> snat</a></code></pre></div>
<p>A good exercise at this point is to try to implement <code>singleton</code> for <code>SomeSaferHeap</code>. It is very similar to the implementation for <code>SomeSafeHeap</code> except you need to use <code>promote</code> and provide evidence for the heap property. The answer is in <a href="#full-program">the full source code</a>.</p>
<h2 id="merging-safer-heaps">Merging safer heaps</h2>
<p>The merge operation is, once again, all we care about. The overall structure is going to be the same, but we’ll need more plumming and lemmas.</p>
<h3 id="making-nodes">Making nodes</h3>
<p>This time let’s start from <code>mkNode</code>. Here’s an attempt analogous to the previous <code>mkNode</code>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1"><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</a>
<a class="sourceLine" id="cb55-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span> <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></a>
<a class="sourceLine" id="cb55-3" title="3">       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></a>
<a class="sourceLine" id="cb55-4" title="4">mkNode vc (<span class="dt">SSH</span> hA) (<span class="dt">SSH</span> hB)</a>
<a class="sourceLine" id="cb55-5" title="5">  <span class="fu">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="fu">=</span></a>
<a class="sourceLine" id="cb55-6" title="6">  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-7" title="7">    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr <span class="fu">???</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb55-8" title="8">    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar <span class="fu">???</span> <span class="fu">???</span></a></code></pre></div>
<p>This attempt fails because we do not have the necessary inequalities to provide evidence for the heap property. We do have access to the parent label and and the children labels, so we could decide on whether they hold. But this approach would require us to give the signature to <code>mkNode</code> because we need to handle the case <code>vc</code> is smaller than one of the labels of the children. Besides, this information is already computed if we follow the structure of the previous merge implementation. So let’s assume that the necessary inequalities are passed down by <code>merge</code>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1"><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</a>
<a class="sourceLine" id="cb56-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span> <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></a>
<a class="sourceLine" id="cb56-3" title="3">       <span class="ot">-&gt;</span> a <span class="fu">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="fu">&lt;=</span> c</a>
<a class="sourceLine" id="cb56-4" title="4">       <span class="ot">-&gt;</span> <span class="dt">SomeSaferHeap</span></a>
<a class="sourceLine" id="cb56-5" title="5">mkNode vc (<span class="dt">SSH</span> hA) (<span class="dt">SSH</span> hB) aLEQc bLEQc</a>
<a class="sourceLine" id="cb56-6" title="6">  <span class="fu">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="fu">=</span></a>
<a class="sourceLine" id="cb56-7" title="7">  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></a>
<a class="sourceLine" id="cb56-8" title="8">    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr bLEQc aLEQc</a>
<a class="sourceLine" id="cb56-9" title="9">    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">SSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar aLEQc bLEQc</a></code></pre></div>
<p>This doesn’t work either because we have an <code>a &lt;= c</code> for the first <code>SomeSaferHeap</code>, but that type hides <code>a</code>, so as far as the type-checker is concerned the rank of <code>hA</code> has nothing to do with <code>Rank a</code>.</p>
<p>It looks like we’re hiding too much. Since <code>mkNode</code> is not part of the <code>Heap</code> typeclass, perhaps we can use <code>SaferHeap</code> instead of <code>SomeSaferHeap</code> in the signature of <code>mkNode</code>. Then one possible signature for <code>mkNode</code> would be the following.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1"><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</a>
<a class="sourceLine" id="cb57-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> r1 a <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> r2 b</a>
<a class="sourceLine" id="cb57-3" title="3">       <span class="ot">-&gt;</span> a <span class="fu">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="fu">&lt;=</span> c</a>
<a class="sourceLine" id="cb57-4" title="4">       <span class="ot">-&gt;</span> <span class="dt">SaferHeap</span> <span class="fu">???</span> c</a></code></pre></div>
<p>This type signature relates the type-level labels of the heaps to the inequalities, but it also requires handling ranks. There are three viable choices for <code>???</code>: <code>r3</code>, <code>'S r1</code>, and <code>'S r2</code>. The first one runs into the same problem as <code>promote</code>, the calculated node rank won’t unify with the free type variable <code>r3</code>. The last two can be made the work but it presupposes that the caller already knows which heap is going to be the right child, hence <code>mkNode</code> would be pointless.</p>
<p>It looks like <code>SomeSaferHeap</code> hides too much and <code>SaferHeap</code> reveals too much. What we need is something in the middle. We want to hide the rank, but leave the type-level value visible. Once again existential types come to the rescue.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">data</span> <span class="dt">AlmostSomeSaferHeap</span> label <span class="fu">=</span> <span class="kw">forall</span> rank<span class="fu">.</span> <span class="dt">ASSH</span> (<span class="dt">SaferHeap</span> rank label)</a></code></pre></div>
<p>We can now proceed to write a <code>mkNode</code> that looks a lot like the implementation for <code>SomeSafeHeap</code>.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1"><span class="ot">mkNode ::</span> <span class="dt">Label</span> c</a>
<a class="sourceLine" id="cb59-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</a>
<a class="sourceLine" id="cb59-3" title="3">       <span class="ot">-&gt;</span> a <span class="fu">&lt;=</span> c <span class="ot">-&gt;</span> b <span class="fu">&lt;=</span> c</a>
<a class="sourceLine" id="cb59-4" title="4">       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> c</a>
<a class="sourceLine" id="cb59-5" title="5">mkNode vc (<span class="dt">ASSH</span> hA) (<span class="dt">ASSH</span> hB) aLEQc bLEQc</a>
<a class="sourceLine" id="cb59-6" title="6">  <span class="fu">|</span> rA <span class="ot">&lt;-</span> rank hA, rB <span class="ot">&lt;-</span> rank hB <span class="fu">=</span></a>
<a class="sourceLine" id="cb59-7" title="7">  <span class="kw">case</span> lemConnexity (_unRank rA) (_unRank rB) <span class="kw">of</span></a>
<a class="sourceLine" id="cb59-8" title="8">    <span class="dt">Left</span>  arLEQbr <span class="ot">-&gt;</span> <span class="dt">ASSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rA) hB hA arLEQbr bLEQc aLEQc</a>
<a class="sourceLine" id="cb59-9" title="9">    <span class="dt">Right</span> brLEQar <span class="ot">-&gt;</span> <span class="dt">ASSH</span> <span class="fu">$</span> <span class="dt">Node''</span> vc (inc rB) hA hB brLEQar aLEQc bLEQc</a></code></pre></div>
<h3 id="merging-nodes">Merging nodes</h3>
<p>We can tackle <code>merge</code> now. At the top-level interface we’re using <code>SomeSaferHeap</code>, but the actualy merge is going to happen in <code>AlmostSomeSaferHeap</code>. The reason for that will become clear later.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" title="1">merge (<span class="dt">SSH'</span> h1) (<span class="dt">SSH'</span> h2) <span class="fu">|</span> <span class="dt">ASSH</span> mergedHeap <span class="ot">&lt;-</span> merge' (<span class="dt">ASSH</span> h1) (<span class="dt">ASSH</span> h2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb60-2" title="2">  <span class="dt">SSH'</span> mergedHeap</a></code></pre></div>
<p>Then the signature and the base cases of <code>merge'</code> are as follows</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" title="1"><span class="ot">merge' ::</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</a>
<a class="sourceLine" id="cb61-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> (<span class="dt">Max</span> a b)</a>
<a class="sourceLine" id="cb61-3" title="3">merge' (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) heap <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb61-4" title="4">merge' heap (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) <span class="fu">=</span> heap</a></code></pre></div>
<p>This brings me to the penultimate corner stone of type-level programming in Haskell that I’ll cover in this post: type-level functions. We have already used associated type families within the <code>Heap</code> and <code>HasRank</code> type classes which are technically type-level functions, but they are too trivial. <code>Max</code> on the other hand does recursion and everything!</p>
<h4 id="type-families">Type families</h4>
<p>The type-level <code>Max</code> function is defined using a closed type family enabled by the <code>TypeFamilies</code> extension.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Max</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb62-2" title="2">  <span class="dt">Max</span> <span class="dt">'Z</span> m          <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb62-3" title="3">  <span class="dt">Max</span> n <span class="dt">'Z</span>          <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb62-4" title="4">  <span class="dt">Max</span> (<span class="dt">'S</span> n) (<span class="dt">'S</span> m) <span class="fu">=</span> <span class="dt">'S</span> (<span class="dt">Max</span> n m)</a></code></pre></div>
<p>This is analogous to the following term level <code>max</code> function on <code>Nat</code>s.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" title="1"><span class="fu">max</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb63-2" title="2"><span class="fu">max</span> <span class="dt">Z</span> m <span class="fu">=</span> m</a>
<a class="sourceLine" id="cb63-3" title="3"><span class="fu">max</span> n <span class="dt">Z</span> <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb63-4" title="4"><span class="fu">max</span> (<span class="dt">S</span> n) (<span class="dt">S</span> m) <span class="fu">=</span> <span class="dt">S</span> (<span class="fu">max</span> n m)</a></code></pre></div>
<p>You might be wondering why not just write that and get a promoted version of <code>max</code> just as we did with data types and kinds? It’s an excellent question and this syntactic dicothomy is another reason why people don’t like type-level programming in Haskell. In Idris or Agda, that is exactly how it works.</p>
<p>This problem stems from multiple reasons. For one thing type families existed in GHC since 2007, whereas data type promotion was added in 2012, and the mandate for moving term and type levels closer is fairly recent. Further, adding type level computation into Haskell is an after-thought, so you need to retrofit the syntax. On top of that the behaviour of type families is different than functions, the patterns of a type family can do unification whereas pattern matches of a function can’t.</p>
<p>For example, the following returns the type <code>Int</code> if its arguments unify and <code>Char</code> otherwise.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Same</span> a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb64-2" title="2">  <span class="dt">Same</span> a a <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb64-3" title="3">  <span class="dt">Same</span> _ _ <span class="fu">=</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb64-4" title="4"></a>
<a class="sourceLine" id="cb64-5" title="5"><span class="ot">sameInt ::</span> <span class="dt">Same</span> [ a ] [ a ]</a>
<a class="sourceLine" id="cb64-6" title="6">sameInt <span class="fu">=</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb64-7" title="7"></a>
<a class="sourceLine" id="cb64-8" title="8"><span class="ot">sameChar ::</span> <span class="dt">Same</span> (<span class="dt">Maybe</span> a) [ a ]</a>
<a class="sourceLine" id="cb64-9" title="9">sameChar <span class="fu">=</span> <span class="ch">'c'</span></a></code></pre></div>
<p>So although we can promote term-level functions to the type-level (<code>singletons</code> library allows this via Template Haskell), they are still not equivalent in behaviour because term-level variables act differently compared to type-level variables.</p>
<p>As a result using the same syntax for both would not be possible in general as we’d need unification at the term level as well.</p>
<h4 id="type-families-vs-gadts">Type families vs GADTs</h4>
<p>We could have encoded <code>Max</code> as a GADT as well and similarly we could have encoded <code>&lt;=</code> as a type family.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" title="1"><span class="kw">data</span> <span class="dt">AltMax</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-2" title="2">  <span class="dt">L</span><span class="ot"> ::</span>                 <span class="dt">AltMax</span> n <span class="dt">'Z</span> n</a>
<a class="sourceLine" id="cb65-3" title="3">  <span class="dt">R</span><span class="ot"> ::</span>                 <span class="dt">AltMax</span> <span class="dt">'Z</span> m m</a>
<a class="sourceLine" id="cb65-4" title="4">  <span class="dt">B</span><span class="ot"> ::</span> <span class="dt">AltMax</span> m n r <span class="ot">-&gt;</span> <span class="dt">AltMax</span> (<span class="dt">'S</span> m) (<span class="dt">'S</span> n) (<span class="dt">'S</span> r)</a>
<a class="sourceLine" id="cb65-5" title="5"></a>
<a class="sourceLine" id="cb65-6" title="6"><span class="kw">type</span> <span class="kw">family</span> n <span class="fu">&lt;==</span><span class="ot"> m ::</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb65-7" title="7">  <span class="dt">'Z</span>     <span class="fu">&lt;==</span> m      <span class="fu">=</span> <span class="dt">'True</span></a>
<a class="sourceLine" id="cb65-8" title="8">  n      <span class="fu">&lt;==</span> <span class="dt">'Z</span>     <span class="fu">=</span> <span class="dt">'False</span></a>
<a class="sourceLine" id="cb65-9" title="9">  (<span class="dt">'S</span> n) <span class="fu">&lt;==</span> (<span class="dt">'S</span> m) <span class="fu">=</span> n <span class="fu">&lt;==</span> m</a></code></pre></div>
<p>These would have also worked. The proofs would have looked different and maybe we would have used different lemmas, but they would have worked. However, there are still reasons to choose one encoding over the other.</p>
<ol type="1">
<li><p>If you intend to do induction over your relation, then constructors are helpful, so GADTs get a point.</p></li>
<li><p>If what you have is a function, then the GADT encoding forces you to add another type variable for the result and the functional dependency between the result and the arguments get lost.</p></li>
<li><p>Conversely, if you have a relation that is not a function and you choose to use a type family, since there is no clear result variable, you need to return a type of kind <code>Bool</code> or something equivalent.</p></li>
<li><p>With type families when you learn more information about the type, the reduction happens automatically, whereas with GADTs you need to modify and pass the relation around.</p></li>
<li><p>More practically, you might already have some type level relations/functions in your codebase and you might want to stay consistent with semantically related relations. Beyond consistency, this might allow you to reuse some lemmas via duality or generalisation.</p></li>
</ol>
<p>My choices in this post embody the first three principles. Also, I wanted to show one of each.</p>
<h4 id="getting-back-to-the-merge">Getting back to the merge</h4>
<p>We can now understand why the base case type checked at all.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" title="1"><span class="ot">merge' ::</span> <span class="dt">AlmostSomeSaferHeap</span> a <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> b</a>
<a class="sourceLine" id="cb66-2" title="2">       <span class="ot">-&gt;</span> <span class="dt">AlmostSomeSaferHeap</span> (<span class="dt">Max</span> a b)</a>
<a class="sourceLine" id="cb66-3" title="3">merge' (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) heap <span class="fu">=</span> heap</a>
<a class="sourceLine" id="cb66-4" title="4">merge' heap (<span class="dt">ASSH</span> <span class="dt">Leaf''</span>) <span class="fu">=</span> heap</a></code></pre></div>
<p>In the first base case, we have <code>Max 0 b</code> which is <code>b</code> by definition and <code>b</code> is exactly the value of <code>heap</code>. It works similarly for the other base case.</p>
<p>In the previous version, we needed the term-level <code>(&lt;=)</code> to see which label to keep on top and which spine to recurse on. We have already seen while verifying the leftist property that <code>lemConnexity</code> is the replacement we need for comparing <code>SNat</code>s. By following the unverified implementation, we can provide a partial implementation that doesn’t type check.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" title="1">merge' (<span class="dt">ASSH</span> hA<span class="fu">@</span>(<span class="dt">Node''</span> vA<span class="fu">@</span>(<span class="dt">Label</span> sA) _ aLeft aRight _ lLEQa rLEQa))</a>
<a class="sourceLine" id="cb67-2" title="2">       (<span class="dt">ASSH</span> hB<span class="fu">@</span>(<span class="dt">Node''</span> vB<span class="fu">@</span>(<span class="dt">Label</span> sB) _ bLeft bRight _ lLEQb rLEQb)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb67-3" title="3">  <span class="kw">case</span> lemConnexity sA sB <span class="kw">of</span></a>
<a class="sourceLine" id="cb67-4" title="4">    <span class="dt">Left</span>  aLEQb <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb67-5" title="5">      <span class="kw">let</span> child1 <span class="fu">=</span> <span class="dt">ASSH</span> bLeft</a>
<a class="sourceLine" id="cb67-6" title="6">          c1LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb67-7" title="7">          child2 <span class="fu">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</a>
<a class="sourceLine" id="cb67-8" title="8">          c2LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb67-9" title="9">      <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</a>
<a class="sourceLine" id="cb67-10" title="10">    <span class="dt">Right</span> bLEQa <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb67-11" title="11">      <span class="kw">let</span> child1 <span class="fu">=</span> <span class="dt">ASSH</span> aLeft</a>
<a class="sourceLine" id="cb67-12" title="12">          c1LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb67-13" title="13">          child2 <span class="fu">=</span> merge' (<span class="dt">ASSH</span> aRight) (<span class="dt">ASSH</span> hB)</a>
<a class="sourceLine" id="cb67-14" title="14">          c2LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb67-15" title="15">      <span class="kw">in</span> mkNode vA child1 child2 c1LEQp c2LEQp</a></code></pre></div>
<p>Let’s focus on the <code>Left</code> branch first. The type checker at this point complains about the holes, but more importantly it complains about the terms involving applications of <code>mkNode</code> even with the assumption that <code>c1LEQp</code> and <code>c2LEQp</code> have appropriate types. The exact complaint is “<code>Could not deduce: Max a b ~ b</code>”. Here <code>~</code> means types are equal.</p>
<p>But of course! We have <code>aLEQb</code> of type <code>a &lt;= b</code>, but the type checker is too stupid to know that this implies <code>Max a b</code> is just <code>b</code>. So we need to prove this. That brings us to <em>propositional equality</em>.</p>
<h4 id="propositional-equality">Propositional equality</h4>
<p>The following is arguably the data type that took me longest to get my head around. So if you have trouble with it, just keep using it until it clicks.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" title="1"><span class="kw">data</span><span class="ot"> (:~:) ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span> <span class="co">-- Same as that in Data.Type.Equality</span></a>
<a class="sourceLine" id="cb68-2" title="2">  <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="fu">:~:</span> a</a></code></pre></div>
<p>This <code>(:~:)</code> takes two types of the same kind and is poly-kinded. When you think about it, it has to be. If it was restricted to <code>Type</code> or <code>Nat</code> that would make it a type equality suitable only for proving two <code>Type</code>s equal or two <code>Nat</code>s equal. This version makes no assumptions.</p>
<p>This type allows us to prove two types in Haskell are equal and can be replace with one another. The idea is if you have a term with type <code>a :~: b</code> and you pattern match on it, the only case is the <code>Refl</code> constructor. Just like previous pattern matches on GADTs, this refines the type in context. In this case, it reveals that <code>a</code> and <code>b</code> are one and the same, that is the type checker learns <code>a ~ b</code>.</p>
<p>We need <code>Max n m ~ m</code> given <code>n &lt;= m</code>. So we are trying to show <code>Max n m :~: m</code>. We can do this by induction on <code>n &lt;= m</code>.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" title="1"><span class="ot">lemMaxOfLEQ ::</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> <span class="dt">Max</span> n m <span class="fu">:~:</span> m</a>
<a class="sourceLine" id="cb69-2" title="2">lemMaxOfLEQ <span class="dt">Base</span> <span class="fu">=</span> <span class="dt">Refl</span></a></code></pre></div>
<p>In the base case, we pattern match on <code>Base</code> which reveals both <code>n</code> and <code>m</code> to be ’Z. So we need to show <code>'Z :~: 'Z</code>. Since <code>Refl</code> has type <code>a :~: a</code>, we can trivially instantiate <code>a</code> to <code>'Z</code> to get the desired equality.</p>
<p>Then comes the first inductive case with <code>Double</code> constructor.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" title="1">lemMaxOfLEQ (<span class="dt">Double</span> xLEQy) <span class="fu">|</span> <span class="dt">Refl</span>  <span class="ot">&lt;-</span> lemMaxOfLEQ xLEQy <span class="fu">=</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Here, <code>xLEQy</code> has type <code>n &lt;= m</code> and we need to show <code>Max ('S n) ('S m) :~: 'S m</code>. By definition of <code>Max</code>, the type checker already reduces the goal to <code>'S (Max n m) :~: 'S m</code>. Since, <code>xLEQy</code> is smaller than the original argument, we can recursively call <code>lemMaxOfLEQ</code> to get a term of type <code>Max n m :~: m</code>. Pattern matching on that tells the compiler <code>Max n m ~ m</code>, so the overall goal reduces to <code>m ~ m</code>. Once again <code>Refl</code> constructor trivially proves this. The process as you can see is fairly mechanical.</p>
<p>The final inductive case is only a tiny bit more complicated, but still managable.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" title="1">lemMaxOfLEQ (<span class="dt">Single</span> xLEQy) <span class="fu">=</span></a>
<a class="sourceLine" id="cb71-2" title="2">  <span class="kw">case</span> <span class="fu">fst</span> <span class="fu">$</span> recover xLEQy <span class="kw">of</span></a>
<a class="sourceLine" id="cb71-3" title="3">    <span class="dt">SZ</span>                                           <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb71-4" title="4">    <span class="dt">SS</span> _ <span class="fu">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ (lemDecLEQ xLEQy) <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>The term <code>xLEQy</code> has type <code>n &lt;= m</code> and we need to prove <code>Max n ('S m) :~: 'S m</code>. Since we don’t know if <code>n</code> is built with <code>'S</code> constructor (it could be <code>'Z</code>), we don’t get an automatic reduction of our goal like last time. We still have <code>xLEQy</code>, so we could apply <code>lemMaxOfLEQ</code> recursively. That would get us <code>Max n m :~: m</code>, but pattern matching on that doesn’t get us to <code>Max n ('S m) :~: 'S m</code>.</p>
<p>The mechanical process got stuck. It’s time to take a step back and think. Taking inspiration from the previous case, if we knew that <code>n</code> was of the form <code>'S k</code>, our goal would reduce to <code>'S (Max k m) :~: 'S m</code>. Then we could show <code>Mak k m :~: m</code> and that would reduce the overall goal to a trivial proof obligation. To obtain <code>Max k m :~: m</code>, we need a recursive call to <code>lemMaxOfLEQ</code> with <code>k &lt;= m</code>, but we only have <code>'S k &lt;= m</code>. Our grade school maths intuition tells us <span class="math inline">\(k + 1 \leq m \implies k \leq m\)</span>. So all we need is a lemma. In our implementation that is <code>lemDecLEQ</code> of type <code>'S n &lt;= m -&gt; n &lt;= m</code>.</p>
<p>But we forgot something! This all hinges on <code>n</code> being of the form <code>'S k</code>, what if it isn’t? Well, the only other thing it could be is <code>'Z</code>, but then <code>Max 'Z m :~: m</code> trivially reduces to <code>m :~: m</code>, so we are good.</p>
<p>Alright, we can prove our final lemma. I’m only showing this one because it will allow me to complain about Haskell.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" title="1"><span class="ot">lemDecLEQ ::</span> <span class="dt">'S</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="fu">&lt;=</span> m</a>
<a class="sourceLine" id="cb72-2" title="2">lemDecLEQ snLEQm <span class="fu">=</span> <span class="fu">uncurry</span> go (recover snLEQm) snLEQm</a>
<a class="sourceLine" id="cb72-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb72-4" title="4"><span class="ot">  go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="fu">&lt;=</span> m</a>
<a class="sourceLine" id="cb72-5" title="5">  go _            <span class="dt">SZ</span>     _            <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;Impossible case.&quot;</span></a>
<a class="sourceLine" id="cb72-6" title="6">  go _            (<span class="dt">SS</span> _) (<span class="dt">Single</span> leq) <span class="fu">=</span> <span class="dt">Single</span> (lemDecLEQ leq)</a>
<a class="sourceLine" id="cb72-7" title="7">  go (<span class="dt">SS</span> <span class="dt">SZ</span>)      y      (<span class="dt">Double</span> _)   <span class="fu">=</span> lemZLEQAll y</a>
<a class="sourceLine" id="cb72-8" title="8">  go (<span class="dt">SS</span> (<span class="dt">SS</span> _))  (<span class="dt">SS</span> _) (<span class="dt">Double</span> leq) <span class="fu">=</span> <span class="dt">Double</span> (lemDecLEQ leq)</a></code></pre></div>
<p>There is nothing particularly difficult about this lemma apart from doing induction on (&lt;=) and its constituents together. It is not particularly difficult given all we have seen so far. But it does contain some lessons.</p>
<p>Haskell doesn’t have a termination checker. This is a feature, but it sure feels like walking barefoot after you break a glass when you are trying to prove things. You could accidentally create an infinite loop that type checks but does not constitute a valid proof. This lemma’s proof is particularly vulnerable because we are pattern matching on three different variables which makes it easy to construct an infinite loop.</p>
<p>We remedy this in <code>lemDecLEQ</code> by making the recursive calls in the body of <code>go</code> to <code>lemDecLEQ</code> rather than <code>go</code> itself. This is less efficient but it makes it easy to see that each recursive call is to something strictly smaller than what we started with.</p>
<p>The other interested bit is the base case of <code>go</code>.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" title="1"><span class="ot">go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="fu">&lt;=</span> m</a>
<a class="sourceLine" id="cb73-2" title="2">go _ <span class="dt">SZ</span> _ <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;Inaccessible case.&quot;</span></a></code></pre></div>
<p>The reason we use <code>error</code> is not because there is an error but because of a syntactic deficiency of <code>Haskell</code>. If the second argument is <code>SZ</code>, then there are no constructors of <code>(&lt;=)</code> that can make <code>'S n &lt;= m</code> which we have a proof for, namely the third argument. We can see this easily by pattern matching on the third argument.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb74-1" title="1"><span class="ot">go ::</span> <span class="dt">SNat</span> (<span class="dt">'S</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">'S</span> n <span class="fu">&lt;=</span> m <span class="ot">-&gt;</span> n <span class="fu">&lt;=</span> m</a>
<a class="sourceLine" id="cb74-2" title="2">go _ <span class="dt">SZ</span> <span class="dt">Base</span>     <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb74-3" title="3">go _ <span class="dt">SZ</span> <span class="dt">Single</span>{} <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb74-4" title="4">go _ <span class="dt">SZ</span> <span class="dt">Double</span>{} <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>If you compile this, GHC will give you pattern match inaccessible warnings combined with type errors about why these arguments can’t coexist together. It can’t be a problem with our output because undefined can take any desired type.</p>
<p>In languages like Agda and Idris, you’d make this an inaccessible case. For example, in <code>Idris</code> it looks like the following.</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb75-1" title="1">go _ <span class="dt">SZ</span> _ impossible</a></code></pre></div>
<p>Then the compiler can confirm or deny that is the case. Since we don’t have this snytax in Haskell (there was a <a href="https://gitlab.haskell.org/ghc/ghc/issues/10756#comment:4">proposal</a>). What if we omit this case altogether? The problem with that is because in an omitted case we don’t pattern match on the second argument, GHC doesn’t know that the pattern is inaccessible, hence it reports a non-exhaustive pattern match warning.</p>
<p>This is very dangerous if you are theorem proving because you might prove a lemma, then tweak it slightly and not realise that the inaccessible case is now perfectly accessible. Because we have <code>error &quot;Inaccessible case&quot;</code> in the body of that case, it type checks just fine making the proof incomplete at best, wrong at worst (if there was no way of handling that particular case). We get no warnings about it either.</p>
<p>How about the rest of the process, is explaining facts to the type checker also Haskell’s fault? Yes and no.</p>
<p>Fundamentally, it’s the grand challange of interactive theorem proving to elide tedious details, so we can work on the big insights. We are not there yet. There is a lot of <a href="https://www.cl.cam.ac.uk/~lp15/Grants/Alexandria/">ongoing research</a> especially focusing on combining machine learning techniques with proof search to automatically find little facts that would make the process more smooth. However, you need to recognise that this is a very general program synthesis problem which is undecidable in general and very difficult even in particular cases.</p>
<p>That said, Haskell lacks the most basic facilities to this end. For example, basic proof search in Agda and Idris would allow you to automatically fill in the proof of basic propositions and even accepts hints (lemma names to use) to do some rudimentary search. It allows you to leave some terms implicit and tries to fill in the details on its own. The closes Haskell has is valid type holes, which are suggestions to fill typed holes in the error messages. The ability to interact with the compiler by pattern matching and typed hole refinements is also mostly missing (with the exception of <code>ghc-mod</code> without reliable editor support).</p>
<h4 id="getting-back-to-the-merge-again">Getting back to the merge again</h4>
<p>Focusing on the <code>Left</code> branch only, we make it known to the compiler that <code>a &lt;= b</code> implies <code>Max a b ~ b</code> using <code>lemMaxOfLEQ</code> that we have just proved.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb76-1" title="1">merge' (<span class="dt">ASSH</span> hA<span class="fu">@</span>(<span class="dt">Node''</span> vA<span class="fu">@</span>(<span class="dt">Label</span> sA) _ aLeft aRight _ lLEQa rLEQa))</a>
<a class="sourceLine" id="cb76-2" title="2">       (<span class="dt">ASSH</span> hB<span class="fu">@</span>(<span class="dt">Node''</span> vB<span class="fu">@</span>(<span class="dt">Label</span> sB) _ bLeft bRight _ lLEQb rLEQb)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb76-3" title="3">  <span class="kw">case</span> lemConnexity sA sB <span class="kw">of</span></a>
<a class="sourceLine" id="cb76-4" title="4">    <span class="dt">Left</span>  aLEQb <span class="fu">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ aLEQb <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb76-5" title="5">      <span class="kw">let</span> child1 <span class="fu">=</span> <span class="dt">ASSH</span> bLeft</a>
<a class="sourceLine" id="cb76-6" title="6">          c1LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb76-7" title="7">          child2 <span class="fu">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</a>
<a class="sourceLine" id="cb76-8" title="8">          c2LEQp <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb76-9" title="9">      <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</a></code></pre></div>
<p>This definition still doesn’t type check because we have holes, but we no longer have a type error because of <code>mkNode</code> function application.</p>
<p>At this point, what we want to do is to inspect the error messages for the typed holes to see what the types the terms we need to construct have. Well, according to GHC they both need type <code>t</code> (distinct rigid <code>t</code>s). Incredibly unhelpful. Honestly, I don’t know what’s going on there. However, if you inline the <code>let</code> binding, we get better results.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb77-1" title="1">mkNode vB (<span class="dt">ASSH</span> bLeft) (merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)) _ _</a></code></pre></div>
<p>The first hole needs a type <code>l &lt;= b</code> and that’s exactly the type of <code>lLEQb</code>. The second hole needs <code>Max r a &lt;= b</code>, we do not yet have a term corresponding to this type, but we have <code>rLEQb :: r &lt;= b</code> and <code>aLEQb :: a &lt;= b</code>. <code>Max</code> is a selective function, and it doesn’t matter which choice it makes, we got it covered. We just need a lemma to prove that. The types for the required lemma and the selectivity lemma needed to prove that are as follows.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb78-1" title="1"><span class="ot">lemDoubleLEQMax ::</span> n <span class="fu">&lt;=</span> l <span class="ot">-&gt;</span> m <span class="fu">&lt;=</span> l <span class="ot">-&gt;</span> <span class="dt">Max</span> n m <span class="fu">&lt;=</span> l</a>
<a class="sourceLine" id="cb78-2" title="2"><span class="ot">lemMaxSelective ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">Max</span> n m <span class="fu">:~:</span> n) (<span class="dt">Max</span> n m <span class="fu">:~:</span> m)</a></code></pre></div>
<p>I won’t prove these. I think you are in a great position to do it yourself at this point. If you get stuck, the proofs are at the end of the post.</p>
<p>We can now give the full definition of the <code>Left</code> branch.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb79-1" title="1"><span class="dt">Left</span>  aLEQb <span class="fu">|</span> <span class="dt">Refl</span> <span class="ot">&lt;-</span> lemMaxOfLEQ aLEQb <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb79-2" title="2">  <span class="kw">let</span> child1 <span class="fu">=</span> <span class="dt">ASSH</span> bLeft</a>
<a class="sourceLine" id="cb79-3" title="3">      c1LEQp <span class="fu">=</span> lLEQb</a>
<a class="sourceLine" id="cb79-4" title="4">      child2 <span class="fu">=</span> merge' (<span class="dt">ASSH</span> bRight) (<span class="dt">ASSH</span> hA)</a>
<a class="sourceLine" id="cb79-5" title="5">      c2LEQp <span class="fu">=</span> lemDoubleLEQMax rLEQb aLEQb</a>
<a class="sourceLine" id="cb79-6" title="6">  <span class="kw">in</span> mkNode vB child1 child2 c1LEQp c2LEQp</a></code></pre></div>
<p>The right branch is analogous to the left one, so you should be able to fill it yourself. There is going to be a technicality requiring a simple lemma that is not required in the <code>Left</code> branch because of the ways we set things up. If you write the <code>Right</code> as we did <code>Left</code>, the type error should give you a clue what lemma is needed. If you can’t figure it out that too is at the end of the post.</p>
<h4 id="other-operations">Other operations?</h4>
<p>We are done! No more verification. We could implement the other methods but just as in the previous implementation, there is nothing interesting there.</p>
<h1 id="simulating-heap-operations">Simulating heap operations</h1>
<p>So after going through all this trouble to prove properties of our code, why bother testing? The answer is multifaceted.</p>
<ol type="1">
<li><p>We didn’t verify everything. Earlier we gave the example that we could satisfy type of the <code>singleton</code> function by discarding its argument and placing empty. Another common theme is to discard a subpart of the data structure and accidentally use the other part twice. In the case of heap property, if one subtree satisfies the heap property, we could use it in the other branch as well and the proof would go throug even though we discarded elements. If we had linear types, we could have guarded ourselves against this.</p></li>
<li><p>Haskell’s proof system is unsound due to non-termination, <code>Type : Type</code>, and other reasons. We might have a fallacious proof somewhere that makes it look like a property is verified to the type checker while being incorrect.</p></li>
<li><p>It gives me a chance to talk about another type-level computation feature: visible type applications.</p></li>
<li><p>I really want to use QuickCheck to run simulations on the heap. It’s super neat. I won’t lie, this might be the reason why this section exists.</p></li>
</ol>
<h2 id="generating-actions">Generating actions</h2>
<p>We’re only going to simulate insertion and deleting the min. Here’s the initial encoding of the actions.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb80-1" title="1"><span class="kw">data</span> <span class="dt">Action</span> a <span class="fu">=</span> <span class="dt">Insert</span> a <span class="fu">|</span> <span class="dt">DeleteMax</span> <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Let’s give <code>Arbitrary</code> instances for <code>Nat</code> and <code>Action</code>, so that we can randomly generate them.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb81-1" title="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Nat</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb81-2" title="2">  arbitrary <span class="fu">=</span> <span class="fu">fromInt</span> <span class="fu">.</span> getPositive <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">@</span>(<span class="dt">Positive</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb81-3" title="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb81-4" title="4">    <span class="fu">fromInt</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb81-5" title="5">    <span class="fu">fromInt</span> n <span class="fu">=</span> <span class="dt">S</span> (<span class="fu">fromInt</span> (n <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb81-6" title="6"></a>
<a class="sourceLine" id="cb81-7" title="7"><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Action</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb81-8" title="8">  arbitrary <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb81-9" title="9">    n <span class="ot">&lt;-</span> arbitrary <span class="fu">@</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb81-10" title="10">    <span class="kw">if</span> n <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb81-11" title="11">      <span class="kw">then</span> <span class="dt">Insert</span> <span class="fu">&lt;$&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb81-12" title="12">      <span class="kw">else</span> <span class="fu">pure</span> <span class="dt">DeleteMax</span></a></code></pre></div>
<p>Somewhat arbitrarily we choose between a deletion and an insertion with <span class="math inline">\(50%\)</span> probability. This may or may not be a realistic simulation, but it is something easy to adjust. You could have multiple wrappers over <code>Action a</code> such as <code>DeleteHeavy a</code> and <code>InsertionHeavy a</code> so that you can simulate different scenarios, but we don’t bother with it today.</p>
<p>There is one type-level computation related feature in these instances that we haven’t discussed yet. That is the <code>TypeApplications</code> extension.</p>
<h3 id="there-is-lambda-then-there-is-lambda">There is <span class="math inline">\(\Lambda\)</span> then there is <span class="math inline">\(\lambda\)</span></h3>
<p>If someone asks for the explicitly typed lambda term for the polymorphic identity function (as they do), we’d probably write <span class="math inline">\(\lambda x : \alpha. x\)</span>, where <span class="math inline">\(\alpha\)</span> is a polymorphic type variable. We’d expect this function to be a closed term that is to say it should be independent of the context. That term looks like it is independent of the term-level variables, but <span class="math inline">\(\alpha\)</span> looks like it is very much depends on whatever <span class="math inline">\(\alpha\)</span> is in the context. That is because there is nothing binding <span class="math inline">\(\alpha\)</span>.</p>
<p>Luckily, in Haskell this is not true although we write the equivalent of the term above syntactically (or even less thanks to type inference), what Haskell interprets that as is <span class="math inline">\(\Lambda \alpha : \mathit{Type}. \lambda x : \alpha. x\)</span>. The syntax for this in Haskell is the following. Although you can’t write a term like this in Haskell, you can explicitly put <span class="math inline">\(\alpha\)</span> in the type signature with <code>ExplicitForAll</code> extension.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb82-1" title="1"><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="fu">.</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb82-2" title="2"><span class="fu">id</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>The <code>forall a</code> corresponds to <span class="math inline">\(\Lambda \alpha\)</span>, where the kind <code>Type</code> is inferred.</p>
<p>If we have type level functions with explicit type variables, then why do we never see type level applications? Well, it happens all the time, it is just behind the scenes. When you apply <code>id</code> to 42, the first thing that happens is that <code>Int</code> gets passed to the the type-level function. GHC relatively recently intorduced <code>TypeApplications</code>, which gives a syntax to do this explicitly. You just pass the type with a <code>@</code> prefix. For example in <code>ghci</code>, we can query <code>:t id @Int</code> and we get <code>Int -&gt; Int</code>.</p>
<p>This works as an alternative to using <code>::</code> when the type is ambiguous. Often it lets us get away with fewer parantheses and looks cleaner in general.</p>
<p>What happens if there are multiple type variables? Well, the type application unifies the type with the first type-variable which is how term-level application works as well.</p>
<p>The problem is if we don’t use <code>ExplicitForAll</code> the ordering of type variables is determined implcitly. You can use <code>:type +v</code> to query the order of type variables used by GHC. I suggest you explicitly put <code>forall</code>s when it matters if you’re going to use type applications.</p>
<p>The type applications in the arbitrary instances are somewhat trivial uses of it. We’ll see something more exciting momentarily.</p>
<h2 id="executing-actions">Executing actions</h2>
<p>We can now interpret the initial representation of the actions. Nothing exciting here.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb83-1" title="1"><span class="ot">execAction ::</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> <span class="dt">Action</span> (<span class="dt">Elem</span> heap) <span class="ot">-&gt;</span> heap <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</a>
<a class="sourceLine" id="cb83-2" title="2">execAction (<span class="dt">Insert</span> x) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">.</span> (x <span class="ot">`insert`</span>)</a>
<a class="sourceLine" id="cb83-3" title="3">execAction <span class="dt">DeleteMax</span>  <span class="fu">=</span> deleteMax</a>
<a class="sourceLine" id="cb83-4" title="4"></a>
<a class="sourceLine" id="cb83-5" title="5"><span class="ot">carryOutActions ::</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> heap) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> heap</a>
<a class="sourceLine" id="cb83-6" title="6">carryOutActions <span class="fu">=</span> foldlM (<span class="fu">flip</span> execAction) empty</a></code></pre></div>
<h2 id="quickchecking-functional-equivalence">QuickChecking functional equivalence</h2>
<p>It’s time to use QuickCheck. The desired property: given two data types implementing <code>Heap</code> and a series of actions, executing these actions on both in order starting from each implementation’s <code>empty</code> heaps should result in the same maximum.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb84-1" title="1"><span class="ot">sameMaxAfterActions ::</span> <span class="kw">forall</span> heap heap'</a>
<a class="sourceLine" id="cb84-2" title="2">                     <span class="fu">.</span> <span class="dt">Heap</span> heap <span class="ot">=&gt;</span> <span class="dt">Heap</span> heap'</a>
<a class="sourceLine" id="cb84-3" title="3">                    <span class="ot">=&gt;</span> <span class="dt">Elem</span> heap <span class="fu">~</span> <span class="dt">Elem</span> heap'</a>
<a class="sourceLine" id="cb84-4" title="4">                    <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Elem</span> heap)</a>
<a class="sourceLine" id="cb84-5" title="5">                    <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> heap) ] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb84-6" title="6">sameMaxAfterActions acts <span class="fu">=</span></a>
<a class="sourceLine" id="cb84-7" title="7">  maxOfActions <span class="fu">@</span>heap acts <span class="fu">==</span> maxOfActions <span class="fu">@</span>heap' acts</a>
<a class="sourceLine" id="cb84-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb84-9" title="9"><span class="ot">  maxOfActions ::</span> <span class="kw">forall</span> h <span class="fu">.</span> <span class="dt">Heap</span> h</a>
<a class="sourceLine" id="cb84-10" title="10">               <span class="ot">=&gt;</span> [ <span class="dt">Action</span> (<span class="dt">Elem</span> h) ] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Elem</span> h))</a>
<a class="sourceLine" id="cb84-11" title="11">  maxOfActions <span class="fu">=</span> <span class="fu">fmap</span> findMax <span class="fu">.</span> carryOutActions <span class="fu">@</span>h</a></code></pre></div>
<p>The actual computation is not very interesting, but the way we direct it is. First, we use an explicit <code>forall</code>, you might think this is to fix the ordering of heap implementations, but in this function it doesn’t matter which order they are in since both <code>heap</code> and <code>heap'</code> are passed to the same function. The reason we enable it is so that we can use <code>ScopedTypeVariables</code> extension which allows us to refer to the type variables in the signature within the body of the function.</p>
<p>The type applications <code>@heap</code> and <code>@heap'</code> determine the computation. This is not just disambiguation. If both <code>maxOfActions</code> were applied to <code>heap</code> instead, we’d create a property that is trivially satisfied since we apply the actions to the same implementation and not do anything with <code>heap'</code>.</p>
<p>Then we use a type application again in the body of <code>maxOfActions</code>. Without it, the list of actions would only give <code>Elem h</code> which in our case will be <code>Nat</code> or <code>Int</code>, but this says nothing about which implementation of <code>heap</code> to do (another way of phrasing this is the <code>Elem</code> type family is not injective, so we can’t go back from <code>Elem h</code> to <code>h</code>). Hence, we use a type application again to clarify which implementation <code>carryOutActions</code> should use.</p>
<p>All there remains is to actually check the property between different implementations.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb85-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb85-2" title="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb85-3" title="3">  quickCheck (sameMaxAfterActions <span class="fu">@</span>(<span class="dt">LeftistHeap</span> <span class="dt">Int</span>)  <span class="fu">@</span>[ <span class="dt">Int</span> ])</a>
<a class="sourceLine" id="cb85-4" title="4">  quickCheck (sameMaxAfterActions <span class="fu">@</span>(<span class="dt">SomeSafeHeap</span> <span class="dt">Int</span>) <span class="fu">@</span>[ <span class="dt">Int</span> ])</a>
<a class="sourceLine" id="cb85-5" title="5">  quickCheck (sameMaxAfterActions <span class="fu">@</span><span class="dt">SomeSaferHeap</span>      <span class="fu">@</span>[ <span class="dt">Nat</span> ])</a>
<a class="sourceLine" id="cb85-6" title="6"></a>
<a class="sourceLine" id="cb85-7" title="7">  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb85-8" title="8">  sampleActions <span class="ot">&lt;-</span> sample' (arbitrary <span class="fu">@</span>(<span class="dt">Action</span> <span class="dt">Int</span>))</a>
<a class="sourceLine" id="cb85-9" title="9">  <span class="fu">print</span> sampleActions</a>
<a class="sourceLine" id="cb85-10" title="10">  <span class="fu">print</span> <span class="fu">$</span> carryOutActions <span class="fu">@</span>[ <span class="dt">Int</span> ] sampleActions</a></code></pre></div>
<p>Remember that the list based heap implementation was our reference implementation. Using type applications, we test functional equivalence between the reference implementation and the untyped leftist heaped, leftist property verified leftist heap, and the leftist and heap property verified leftist heap in that order.</p>
<p>Then I just sample some actions and see the result of carrying them out on the terminal because I’m paranoid like that (the <code>Arbitrary</code> instance could also be buggy =)).</p>
<p>At this point, we can be reasonable sure that these implementations are correct (at least for insertion and deletion and probably for merge).</p>
<h1 id="conclusion">Conclusion</h1>
<p>After such a long post, I’ll keep the conclusion short and sweet. Here’s what we did in a gist:</p>
<ul>
<li>learnt about leftist heaps a purely functional replacement to array-based binary heaps;</li>
<li>looked at all major parts of Haskell’s type-level computation features;</li>
<li>ran simulations to test functional equivalence of various implementations;</li>
<li>gave a commentary of Haskell as an interactive theorem prover.</li>
</ul>
<p>What is the overall verdict on that last point? It’s not ideal at all, but it works at least for simple data structures and properties. If we had used the <code>singletons</code> library and type checker plugins, we could have gone farther and get there quicker. I think the point that is overlooked in these discussions is that GHC provides the means for doing verification natively and also produces highly optimised code and has a huge ecosystem. Neither Agda nor Idris nor ATS can claim this. I for one am looking forward to Haskell’s journey in this direction.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>This implementation wouldn’t be possible without the heroic work by <a href="https://richarde.dev/index.html">Dr Richard Eisenberg</a> and <a href="https://www.cis.upenn.edu/~sweirich/">Prof. Stephanie Weirich</a> (<a href="https://dl.acm.org/citation.cfm?id=2535856">closed type families</a>, <a href="https://dl.acm.org/citation.cfm?id=2364522">singletons</a>), <a href="https://homepages.inf.ed.ac.uk/jcheney/">Dr James Cheney</a>, <a href="https://www.cs.ox.ac.uk/ralf.hinze/">Prof. Ralf Hinze</a>, <a href="https://www.cs.bu.edu/~hwxi/">Dr Hongwei Xi</a> (<a href="https://ecommons.cornell.edu/handle/1813/5614">GADTs 1</a> and <a href="https://dl.acm.org/citation.cfm?id=604150">GADTs 2</a>), and many GHC implementors. It also wouldn’t have been as slick if it wasn’t for the wonderful presentations by Prof. Weirich on <a href="https://www.youtube.com/watch?v=n-b1PYbRUOY">verifying red-black trees</a> (<a href="https://www.youtube.com/watch?v=rhWMhTjQzsU">alternative</a>).</p>
<h1 id="full-program">Full program</h1></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
