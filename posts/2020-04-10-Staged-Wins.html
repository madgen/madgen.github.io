<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Staged Wins</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on April 10, 2020
  
  
    and last updated on September  1, 2020
  
  by Mistral Contrastin
</div>

<h1>Staged Wins</h1>


<p class="in-which">In which we look at how effortless and profitable staged programming is in Haskell by (micro)benchmarking a regular expression interpreter and a staged compiler.</p>


<div class="post"><p>As Haskell programmers, we live and die by the maxim “never do at runtime what
could be done at compile time”. However, we (or at least me) almost exclusively
understand this as doing safety checks before runtime and do not appreciate the
full generality of this maxim. Although an optimising compiler will do much
computation before runtime, as a programmer we hardly ever have a say on the
matter.</p>
<p>The singular exception to this in many languages compiled or otherwise is
<em>metaprogramming</em> where the purpose of our code is to generate code. If you
think about it, the concept is remarkably prevalent in many languages from C
preprocessor macros to abuses of C++ template system, from Ruby’s highly
maleable object model to Java’s class loader API. In fact, in Haskell alone, it
comes at least in three flavours: datatype-generic programming, Template
Haskell (henceforth TH), Typed-Template Haskell (henceforth TTH). The first is
convenient but comes at a runtime cost. The second one is performed at compile
time, but is unprincipled, potentially unhygienic, and effectively untyped. The
third restricts Template Haskell, but it achieves principled and well-typed
metaprograms with decent error messages!</p>
<p>As you might guess, TTH is the topic of this post. In particular, I take a naïve
regular expression recogniser and mindlessly apply TTH’s quotations and splices
to answer two questions:</p>
<ol type="1">
<li>Is it a pain to use TTH?</li>
<li>What do I get out of going through this exercise?</li>
</ol>
<p>The short answers are “not really” and “5x performance improvement in time”.
However, the justification for the first answer is my highly subjective value
judgements with caveats and that for the second answer is backed only by
microbenchmarks on a few examples. So if your reputation is on the line, I
suggest you don’t cite this blog post to support your argument. For that, I’d go
read articles, posts, and libraries by <a href="https://mpickering.github.io">Matthew
Pickering</a>, <a href="https://www.cl.cam.ac.uk/~jdy22/">Jeremy
Yallop</a>, and <a href="https://namin.seas.harvard.edu/people/nada-amin">Nada
Amin</a>.</p>
<p>In the rest of this post, we first quickly look at the regular expression
recogniser in question. We then stage it. Having these interpreted and staged
versions at hand, we quantitatively compare them using microbenchmarks and look
at the generated code to try to understand the performance difference. Finally,
we remark on the convenience of staging this program and conclude.</p>
<h2 id="a-simple-regular-expression-interpreter">A simple regular expression interpreter</h2>
<p>We implement an interpreter just sophisticated enough to represent some
fictional phone number regular expression:
<code>0?\d\d\d\d(\w|-)*\d\d\d(\w|-)*\d\d\d</code>. This would recognise <code>01234 567 890</code>
without the leading zero and with or without spaces at the designated places and
optionally with hyphens.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RegExp</span> <span class="ot">=</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Null</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Char</span> <span class="dt">Char</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RegExp</span> <span class="op">:|:</span> <span class="dt">RegExp</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">RegExp</span> <span class="op">:.:</span> <span class="dt">RegExp</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Star</span> <span class="dt">RegExp</span></span></code></pre></div>
<p>A number of useful regular expressions and primitives can be defined right away.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">digit ::</span> <span class="dt">RegExp</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>digit <span class="ot">=</span> <span class="fu">foldr1</span> (<span class="op">:|:</span>) (<span class="fu">map</span> <span class="dt">Char</span> [<span class="ch">'0'</span><span class="op">..</span><span class="ch">'9'</span>])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">whitespace ::</span> <span class="dt">RegExp</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>whitespace <span class="ot">=</span> <span class="dt">Char</span> <span class="ch">' '</span> <span class="op">:|:</span> <span class="dt">Char</span> <span class="ch">'\t'</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- r+</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">plus ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>plus re <span class="ot">=</span> re <span class="op">:.:</span> <span class="dt">Star</span> re</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- r?</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ot">optional ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>optional re <span class="ot">=</span> re <span class="op">:|:</span> <span class="dt">Null</span></span></code></pre></div>
<p>This is enough to represent our target regular expression.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">phoneNumber ::</span> <span class="dt">RegExp</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>phoneNumber <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  optional <span class="st">&quot;0&quot;</span> <span class="op">:.:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  digit <span class="op">:.:</span> digit <span class="op">:.:</span> digit <span class="op">:.:</span> digit <span class="op">:.:</span> (<span class="dt">Star</span> whitespace <span class="op">:|:</span> <span class="st">&quot;-&quot;</span>) <span class="op">:.:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  digit <span class="op">:.:</span> digit <span class="op">:.:</span> digit <span class="op">:.:</span> (<span class="dt">Star</span> whitespace <span class="op">:|:</span> <span class="st">&quot;-&quot;</span>) <span class="op">:.:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  digit <span class="op">:.:</span> digit <span class="op">:.:</span> digit</span></code></pre></div>
<p>All there remains is to interpret these regular expressions. We interpret
regular expressions as <code>Matcher</code>s which are functions that takes a string input,
matches the regular expression to the longest prefix, and returns whatever
remains. If the string could not be matched at all, it returns nothing.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Matcher</span> <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">matchStar ::</span> <span class="dt">Matcher</span> <span class="ot">-&gt;</span> <span class="dt">Matcher</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>matchStar matcher str <span class="ot">=</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> matcher str <span class="kw">of</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> rest <span class="ot">-&gt;</span> matchStar matcher rest</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> str</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ot">interpret ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Matcher</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Null</span> <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Char</span> c) <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>interpret (re1 <span class="op">:|:</span> re2) <span class="ot">=</span> (<span class="op">&lt;|&gt;</span>) <span class="op">&lt;$&gt;</span> interpret re1 <span class="op">&lt;*&gt;</span> interpret re2</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>interpret (re1 <span class="op">:.:</span> re2) <span class="ot">=</span> interpret re1 <span class="op">&gt;=&gt;</span> interpret re2</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Star</span> re)     <span class="ot">=</span> matchStar (interpret re)</span></code></pre></div>
<p>The interpreter does not try to be clever. It compositionally interprets regular
expressions and combines them using monadic or applicative combinators.</p>
<p>A matcher defined by the interpreter is not quite what we are after as we want
exact matches. It is easy enough to make one of those out of a matcher.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Recogniser</span> <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">toRecogniser ::</span> <span class="dt">Matcher</span> <span class="ot">-&gt;</span> <span class="dt">Recogniser</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>toRecogniser m str <span class="ot">=</span> m str <span class="op">==</span> <span class="dt">Just</span> []</span></code></pre></div>
<p>This is all there is to our regular expression interpreter.</p>
<h2 id="staging-the-interpreter">Staging the interpreter</h2>
<p>So what treacherous road to optimisation is ahead of us? As it turns out, it is
a short and painless one. You only need to be aware of three things if you want
to use TTH: <code>TExpQ</code>, the quotation operator <code>[|| exp ||]</code>, and
and the splice operator <code>$$code</code>.</p>
<p><code>TExpQ a</code> is the typed equivalent of TH’s <code>Q Exp</code>. This already gives away that
we can only generate expressions with TTH. The type parameter <code>a</code> is the type of
the expression the generated code will evaluate to. This is entirely missing in
<code>Q Exp</code>, hence the “Typed” in TTH. This <code>TExpQ</code> constructor is, however, does
not have a terribly informative name, so I alias it with <code>Code</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Code</span> a <span class="ot">=</span> <span class="dt">TExpQ</span> a</span></code></pre></div>
<p>The quotation operator (<code>[|| exp ||]</code>) takes an expression of type <code>a</code> and turns
it into <code>Code a</code>. The splice (<code>$$code</code>) operator goes the other way. In other
words, the former produces the code for some expression and the latter <em>in the
right context</em> evaluates that code.</p>
<p>If you then have something you want evaluated at compile time for sure, you just
write a function of the form <code>a -&gt; Code b</code>. The <code>a</code> is what you want to get rid
of at runtime and the <code>Code b</code> is what you end up with as a result.</p>
<p>In our case, we had an interpreter with type <code>RegExp -&gt; Matcher</code> and we want to
compile the regular expression away, so we’d like a function <code>RegExp -&gt; Code Matcher</code> instead. Well, how are we going to get there? Mechanically and
mindlessly!</p>
<p>Let’s take the first case:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Null</span> <span class="ot">=</span> <span class="fu">pure</span></span></code></pre></div>
<p>The <code>Matcher</code> is just <code>pure</code> and we want <code>Code Matcher</code>, so we just do <code>[|| pure ||]</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>compile <span class="dt">Null</span> <span class="ot">=</span> [<span class="op">||</span> <span class="fu">pure</span> <span class="op">||</span>]</span></code></pre></div>
<p>Okay, maybe we got lucky with that one. Let’s try the second case.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Char</span> c) <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Remember that <code>Matcher</code> is a lambda, so that forces us to place the quotation
outside the lambda case expression and we are done.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>compile (<span class="dt">Char</span> c) <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  [<span class="op">||</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    \<span class="kw">case</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">||</span>]</span></code></pre></div>
<p>Now, you’re thinking that base cases are always easy, so let’s try a recursive
one.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>interpret (re1 <span class="op">:|:</span> re2) <span class="ot">=</span> (<span class="op">&lt;|&gt;</span>) <span class="op">&lt;$&gt;</span> interpret re1 <span class="op">&lt;*&gt;</span> interpret re2</span></code></pre></div>
<p>We know the result is going to be <code>Code Matcher</code>, so we place the quotation
outsite the body once more.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:|:</span> re2) <span class="ot">=</span> [<span class="op">||</span> (<span class="op">&lt;|&gt;</span>) <span class="op">&lt;$&gt;</span> compile re1 <span class="op">&lt;*&gt;</span> compile re2 <span class="op">||</span>]</span></code></pre></div>
<p>However, this won’t compile because <code>compile</code> has type <code>RegExp -&gt; Code Matcher</code>.
Then, the expression inside the quotation needs to have the type <code>Matcher</code>.
This makes the recursive calls are ill-typed. They have type <code>Code Matcher</code>
instead of <code>Matcher</code>, but we already know how to go in this direction with a
splice. So, all we need is to wrap these recursive calls with it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:|:</span> re2) <span class="ot">=</span> [<span class="op">||</span> (<span class="op">&lt;|&gt;</span>) <span class="op">&lt;$&gt;</span> <span class="op">$$</span>(compile re1) <span class="op">&lt;*&gt;</span> <span class="op">$$</span>(compile re2) <span class="op">||</span>]</span></code></pre></div>
<p>We are done once more. The next two recursive cases are treated similarly. So
overall, we end up with a compiler strikingly similar to the interpreter. Most
surprisingly, we exercised almost no brain cells along the way.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compile ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Code</span> <span class="dt">Matcher</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>compile <span class="dt">Null</span> <span class="ot">=</span> [<span class="op">||</span> <span class="fu">pure</span> <span class="op">||</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>compile (<span class="dt">Char</span> c) <span class="ot">=</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  [<span class="op">||</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    \<span class="kw">case</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">||</span>]</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:|:</span> re2) <span class="ot">=</span> [<span class="op">||</span> (<span class="op">&lt;|&gt;</span>) <span class="op">&lt;$&gt;</span> <span class="op">$$</span>(compile re1) <span class="op">&lt;*&gt;</span> <span class="op">$$</span>(compile re2) <span class="op">||</span>]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:.:</span> re2) <span class="ot">=</span> [<span class="op">||</span> <span class="op">$$</span>(compile re1) <span class="op">&gt;=&gt;</span> <span class="op">$$</span>(compile re2) <span class="op">||</span>]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>compile (<span class="dt">Star</span> re)     <span class="ot">=</span> [<span class="op">||</span> matchStar <span class="op">$$</span>(compile re) <span class="op">||</span>]</span></code></pre></div>
<p>Let’s use it on an example. We first start a new file with a new module (this
bit is important and <a href="#qualitative-remarks">an explanation will follow</a>). Then,
we see if the regular expression <code>"ab"</code> recognises the string <code>"ababababab"</code> in
the module.</p>
<pre><code>resInterpreted = toRecogniser $ interpret $ Star &quot;ab&quot;
resCompiled    = toRecogniser $$(compile $ Star &quot;ab&quot;)</code></pre>
<h2 id="microbenchmarks">Microbenchmarks</h2>
<p>Staging was easy enough, but what does it buy us? A general answer is difficult,
but here’s one microbenchmark. We look at the speed at which the interpreted and
staged regular expression recognisers match
<code>0?\d\d\d\d(\w|-)*\d\d\d(\w|-)*\d\d\d</code> against the following:</p>
<pre><code>04207999163
0420799916
04207 999 163
04207-999-163
04207 a99 163
04207    999    163
04207  0 999    163
4207    999    163</code></pre>
<p>The <code>criterion</code> benchmarking results indicate a convincing ~5x win when compiled
with <code>-O1</code> and a ~%5 improvement with <code>-O0</code>.</p>
<figure>
<img src="../images/staged-wins/microbenchmarks-O0.png" alt="Microbenchmark results for -O0" />
<figcaption aria-hidden="true">Microbenchmark results for -O0</figcaption>
</figure>
<figure>
<img src="../images/staged-wins/microbenchmarks-O1.png" alt="Microbenchmark results for -O1" />
<figcaption aria-hidden="true">Microbenchmark results for -O1</figcaption>
</figure>
<h3 id="but-why">But why?</h3>
<p>We have three questions to answer:</p>
<ol type="1">
<li>why does the compiled version un faster than the interpreted one even without
optimisations?</li>
<li>why does the compiled version benefit so much from optimisations, unlike the
interpreted version?</li>
</ol>
<p>To understand the compiled version’s success without optimisations, it is enough
to inspect the partially evaluated code. Passing the <code>-ddump-splices</code> and
<code>-ddump-to-file</code> GHC options yields a file with <code>Foo.dump-splices</code> extension
that contains the partially evaluated expressions in a module <code>Foo</code>. The
resulting splice is nearly 700 lines long (due to partially evaluating the
relatively complex phone number regex), but it is enough to look at only a few
lines.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(((((((((((((((<span class="op">GHC.Base.&lt;|&gt;</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      (\<span class="kw">case</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>         (c'_a5jT <span class="op">:</span> rest_a5jU) <span class="op">|</span> (<span class="ch">'0'</span> <span class="op">==</span> c'_a5jT) <span class="ot">-&gt;</span> <span class="dt">Just</span> rest_a5jU</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>         _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>))</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">&lt;*&gt;</span> <span class="fu">pure</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">Control.Monad.&gt;=&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    (((<span class="op">GHC.Base.&lt;|&gt;</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;$&gt;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>          (\<span class="kw">case</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>             (c'_a5jV <span class="op">:</span> rest_a5jW) <span class="op">|</span> (<span class="ch">'0'</span> <span class="op">==</span> c'_a5jV) <span class="ot">-&gt;</span> <span class="dt">Just</span> rest_a5jW</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>             _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>))</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>       <span class="op">&lt;*&gt;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>         (((<span class="op">GHC.Base.&lt;|&gt;</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>             <span class="op">&lt;$&gt;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>               (\<span class="kw">case</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>                  (c'_a5jX <span class="op">:</span> rest_a5jY) <span class="op">|</span> (<span class="ch">'1'</span> <span class="op">==</span> c'_a5jX) <span class="ot">-&gt;</span> <span class="dt">Just</span> rest_a5jY</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>                  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>))</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;*&gt;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>              (((<span class="op">GHC.Base.&lt;|&gt;</span>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&lt;$&gt;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>                    (\<span class="kw">case</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>                       (c'_a5jZ <span class="op">:</span> rest_a5k0) <span class="op">|</span> (<span class="ch">'2'</span> <span class="op">==</span> c'_a5jZ) <span class="ot">-&gt;</span> <span class="dt">Just</span> rest_a5k0</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>                       _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;*&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>We can see that this expression optionally looks for a <code>0</code> followed by one of
<code>0</code>, <code>1</code>, <code>2</code>, and so on. This shouldn’t be surprising as that’s what our phone
number specification dictates. The crucial thing is what is missing. Namely,
there are no <code>:.:</code> or <code>:|:</code> constructors used to represent sequencing and
alternatives. These are gone now and so is the need to branch on them. So the
unoptimised staged regex compiler does better than the interpreter because it
does less work.</p>
<p>The same splice also reveals the answer to the next question. Optimisations do
well on this expression because there is a larger surface area to optimise.
Staging generated one big state machine where most information is available such
as the branching structure and the concrete arguments of combinators. This is
not the case for the interepreter and the optimiser is restricted to work on
what is in each branch for the regex constructors.</p>
<p>To confirm this, we compare intermediate representation (Core) dumps of Haskell
with and without optimisations. To do so, we pass the <code>-O0</code> or <code>-O1</code>,
<code>-ddump-simpl</code>, and <code>-ddump-to-file</code> GHC options which generate a
<code>Foo.dump-simpl</code> file with a Core output after optimisations are applied at the
desired optimisation level. At the top of these files, there some basic
statistics, comparing these alone tells a story.</p>
<pre><code>-O0:
  Result size of Tidy Core
    = {terms: 2,432, types: 4,705, coercions: 0, joins: 0/0}
-O1
  Result size of Tidy Core
    = {terms: 1,623, types: 1,069, coercions: 0, joins: 70/70}:</code></pre>
<p>The first difference is the significant decline in the number of terms and
types. This is not surprising when we look at the core output. While the
unoptimised code is full of calls to functorial, applicative, and monadic
operators we used to implement regular expressions, the optimised version
doesn’t have any. These could be eliminated because their arguments became known
with staging.</p>
<p>Here are representative excerpts from the core files. Don’t focus too much on
what they do, but just observe the lack of combinators in the optimised version.</p>
<p>Unoptimised core:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>compiledPhoneNumber <span class="ot">=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="op">Control.Monad.&gt;=&gt;</span> <span class="op">@</span> <span class="dt">Maybe</span> <span class="op">@</span> <span class="dt">String</span> <span class="op">@</span> [<span class="dt">Char</span>] <span class="op">@</span> <span class="dt">String</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">GHC.Base.$</span>fMonadMaybe</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ***Omitted 10 nested calls to of monadic/applicative combinators***</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  (<span class="op">Control.Monad.&gt;=&gt;</span> <span class="op">@</span> <span class="dt">Maybe</span> <span class="op">@</span> <span class="dt">String</span> <span class="op">@</span> [<span class="dt">Char</span>] <span class="op">@</span> [<span class="dt">Char</span>]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">GHC.Base.$</span>fMonadMaybe</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>     (<span class="op">&lt;*&gt;</span> <span class="op">@</span> ((<span class="ot">-&gt;</span>) [<span class="dt">Char</span>]) (<span class="op">GHC.Base.$</span>fApplicative<span class="ot">-&gt;</span> <span class="op">@</span> [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>])</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>])</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        (<span class="op">&lt;$&gt;</span> <span class="op">@</span> ((<span class="ot">-&gt;</span>) [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Char</span>])</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>           (<span class="op">GHC.Base.$</span>fFunctor<span class="ot">-&gt;</span> <span class="op">@</span> [<span class="dt">Char</span>])</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>           (<span class="op">GHC.Base.&lt;|&gt;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">@</span> <span class="dt">Maybe</span> <span class="op">GHC.Base.$</span>fAlternativeMaybe <span class="op">@</span> [<span class="dt">Char</span>])</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>           (\ (<span class="ot">ds_d62q ::</span> [<span class="dt">Char</span>]) <span class="ot">-&gt;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> ds_d62q <span class="kw">of</span> {</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>                [] <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Nothing</span> <span class="op">@</span> [<span class="dt">Char</span>];</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">:</span> c'_a5jT rest_a5jU <span class="ot">-&gt;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">case</span> <span class="op">==</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>                         <span class="op">@</span> <span class="dt">Char</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>                         ghc<span class="op">-</span>prim<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="dv">1</span><span class="op">:GHC.Classes.$</span>fEqChar</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>                         (ghc<span class="op">-</span>prim<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="dv">1</span><span class="op">:</span><span class="dt">GHC.Types.C</span><span class="op">#</span> <span class="ch">'0'</span><span class="op">#</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>                         c'_a5jT</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">of</span> {</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Nothing</span> <span class="op">@</span> [<span class="dt">Char</span>];</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Just</span> <span class="op">@</span> [<span class="dt">Char</span>] rest_a5jU</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>                  }</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>              }))</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">pure</span> <span class="op">@</span> <span class="dt">Maybe</span> <span class="op">GHC.Base.$</span>fApplicativeMaybe <span class="op">@</span> [<span class="dt">Char</span>]))</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>     (<span class="op">&lt;*&gt;</span> <span class="op">@</span> ((<span class="ot">-&gt;</span>) [<span class="dt">Char</span>])</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>        (<span class="op">GHC.Base.$</span>fApplicative<span class="ot">-&gt;</span> <span class="op">@</span> [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>])</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>        (<span class="op">&lt;$&gt;</span> <span class="op">@</span> ((<span class="ot">-&gt;</span>) [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>]) <span class="op">@</span> (<span class="dt">Maybe</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Char</span>])</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>           (<span class="op">GHC.Base.$</span>fFunctor<span class="ot">-&gt;</span> <span class="op">@</span> [<span class="dt">Char</span>])</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>           (<span class="op">GHC.Base.&lt;|&gt;</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>              <span class="op">@</span> <span class="dt">Maybe</span> <span class="op">GHC.Base.$</span>fAlternativeMaybe <span class="op">@</span> [<span class="dt">Char</span>])</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>           (\ (<span class="ot">ds_d62t ::</span> [<span class="dt">Char</span>]) <span class="ot">-&gt;</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> ds_d62t <span class="kw">of</span> {</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>                [] <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Nothing</span> <span class="op">@</span> [<span class="dt">Char</span>];</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>                <span class="op">:</span> c'_a5jV rest_a5jW <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>Optimised core:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>StagedPhoneNumber.compiledPhoneNumber2 <span class="ot">=</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>\ (x_X5SR [<span class="dt">OS</span><span class="ot">=</span><span class="dt">OneShot</span>]<span class="ot"> ::</span> [<span class="dt">Char</span>]) <span class="ot">-&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>join {</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>w<span class="op">$</span>j_sa1I [<span class="dt">InlPrag</span><span class="ot">=</span><span class="dt">NOUSERINLINE</span>[<span class="dv">2</span>], <span class="dt">Dmd</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">C1</span>(<span class="dt">U</span>)<span class="op">&gt;</span>]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> ghc<span class="op">-</span>prim<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="dv">1</span><span class="op">:</span><span class="dt">GHC.Prim.Void</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">LclId</span>[<span class="dt">JoinId</span>(<span class="dv">1</span>)], <span class="dt">Arity</span><span class="ot">=</span><span class="dv">1</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dt">A</span><span class="op">&gt;</span>, <span class="dt">Unf</span><span class="ot">=</span><span class="dt">OtherCon</span> []]</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>w<span class="op">$</span>j_sa1I _ [<span class="dt">Occ</span><span class="ot">=</span><span class="dt">Dead</span>, <span class="dt">OS</span><span class="ot">=</span><span class="dt">OneShot</span>]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Omitted 5 levels of nested joins</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> join {</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span>w<span class="op">$</span>j6_sa1w [<span class="dt">InlPrag</span><span class="ot">=</span><span class="dt">NOUSERINLINE</span>[<span class="dv">2</span>], <span class="dt">Dmd</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">C1</span>(<span class="dt">U</span>)<span class="op">&gt;</span>]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> ghc<span class="op">-</span>prim<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="dv">1</span><span class="op">:</span><span class="dt">GHC.Prim.Void</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>      [<span class="dt">LclId</span>[<span class="dt">JoinId</span>(<span class="dv">1</span>)], <span class="dt">Arity</span><span class="ot">=</span><span class="dv">1</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dt">A</span><span class="op">&gt;</span>, <span class="dt">Unf</span><span class="ot">=</span><span class="dt">OtherCon</span> []]</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span>w<span class="op">$</span>j6_sa1w _ [<span class="dt">Occ</span><span class="ot">=</span><span class="dt">Dead</span>, <span class="dt">OS</span><span class="ot">=</span><span class="dt">OneShot</span>]</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> <span class="kw">case</span> x_X5SR <span class="kw">of</span> {</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>            [] <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Nothing</span> <span class="op">@</span> <span class="dt">String</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> c'_a886 rest_a887 <span class="ot">-&gt;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> c'_a886 <span class="kw">of</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>              { ghc<span class="op">-</span>prim<span class="op">-</span><span class="fl">0.6</span><span class="op">.</span><span class="dv">1</span><span class="op">:</span><span class="dt">GHC.Types.C</span><span class="op">#</span> y_a5S2 <span class="ot">-&gt;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> y_a5S2 <span class="kw">of</span> {</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>                __DEFAULT <span class="ot">-&gt;</span> <span class="dt">GHC.Maybe.Nothing</span> <span class="op">@</span> <span class="dt">String</span>;</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>                <span class="ch">'7'</span><span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>                  StagedPhoneNumber.compiledPhoneNumber3</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>                    rest_a887;</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>                <span class="ch">'8'</span><span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>                  StagedPhoneNumber.compiledPhoneNumber3</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>                    rest_a887;</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>                <span class="ch">'9'</span><span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>                  StagedPhoneNumber.compiledPhoneNumber3</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>                    rest_a887</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>The second thing to observe the proliferation of joins. These are both present
above in the optimised core output and also in the summary. The unoptimised core
had no joins, but the optimised version has 70. What are these joins? They are
evidence of <em>commuting conversion</em> optimisation taking place. Given a nested
conditional, this conversion brings the inner conditional with the outer one,
e.g.,</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> (<span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3) <span class="kw">then</span> e4 <span class="kw">else</span> e5</span></code></pre></div>
<p>becomes</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 <span class="kw">then</span> (<span class="kw">if</span> e2 <span class="kw">then</span> e4 <span class="kw">else</span> e5) <span class="kw">else</span> (<span class="kw">if</span> e3 <span class="kw">then</span> e4 <span class="kw">else</span> e5)</span></code></pre></div>
<p>This conversion can trivialise some conditionals to the extent that we can
delete them.</p>
<p>The following nested case expressions for testing an empty list</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> (<span class="kw">case</span> as <span class="kw">of</span> { [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span>; (p<span class="op">:</span>_) <span class="ot">-&gt;</span> <span class="dt">Just</span> p }) <span class="kw">of</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">False</span></span></code></pre></div>
<p>becomes</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  []  <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="dt">Nothing</span> <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> z  <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  p<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="dt">Just</span> p <span class="kw">of</span> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> _ <span class="ot">-&gt;</span> <span class="dt">False</span></span></code></pre></div>
<p>which in turn simplifies to</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> as <span class="kw">of</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  []  <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  p<span class="op">:</span>_ <span class="ot">-&gt;</span> <span class="dt">False</span></span></code></pre></div>
<p>Join points in GHC are used to mitigate the effects of duplication of
expressions due to commuting conversion. You can learn more about them and
commuting conversion in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf">Join Points in
GHC</a>
(Maurer et al. 2017).</p>
<p>The abundance of joins in the optimised Core program combined with the nested
case expressions due to staging make it likely that commuting conversion is a
significant factor in why optimisations are effective on our staged code. At
least, that is my educated guess.</p>
<h2 id="qualitative-remarks-on-ergonomics">Qualitative remarks on ergonomics</h2>
<h3 id="staging-might-require-restructuring">Staging might require restructuring</h3>
<p>Whether the staging is as simple as placing quotations and splices depends on
the structure of the implementation. Consider the following implementation
without using any combinators:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpret ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Matcher</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Null</span> cs <span class="ot">=</span> <span class="dt">Just</span> cs</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Char</span> c) cs <span class="ot">=</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> cs <span class="kw">of</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>interpret (re1 <span class="op">:|:</span> re2) cs <span class="ot">=</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> interpret re1 cs <span class="kw">of</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> cs' <span class="ot">-&gt;</span> <span class="dt">Just</span> cs'</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> interpret re2 cs</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>interpret (re1 <span class="op">:.:</span> re2) cs <span class="ot">=</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> interpret re1 cs <span class="kw">of</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> cs' <span class="ot">-&gt;</span> interpret re2 cs'</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Star</span> re) cs <span class="ot">=</span> matchStar (interpret re) cs</span></code></pre></div>
<p>This implementation is not amenable to staging only by placing quotations and
splices. We need to move <code>cs</code> over to the right side of the equations because
unlike <code>Matcher</code>, <code>Code Matcher</code> is not a function type. Once that is done, we
can mechanically place quotations and splices as before.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compile ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Code</span> <span class="dt">Matcher</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>compile <span class="dt">Null</span> <span class="ot">=</span> [<span class="op">||</span> <span class="dt">Just</span> <span class="op">||</span>]</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>compile (<span class="dt">Char</span> c) <span class="ot">=</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  [<span class="op">||</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    \<span class="kw">case</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>      (c' <span class="op">:</span> rest) <span class="op">|</span> c <span class="op">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">||</span>]</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:|:</span> re2) <span class="ot">=</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>  [<span class="op">||</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    \cs <span class="ot">-&gt;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="op">$$</span>(compile re1) cs <span class="kw">of</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> cs' <span class="ot">-&gt;</span> <span class="dt">Just</span> cs'</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="op">$$</span>(compile re2) cs</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">||</span>]</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>compile (re1 <span class="op">:.:</span> re2) <span class="ot">=</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>  [<span class="op">||</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    \cs <span class="ot">-&gt;</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="op">$$</span>(compile re1) cs <span class="kw">of</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> cs' <span class="ot">-&gt;</span> <span class="op">$$</span>(compile re2) cs'</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">||</span>]</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>compile (<span class="dt">Star</span> re) <span class="ot">=</span> [<span class="op">||</span> matchStar <span class="op">$$</span>(compile re) <span class="op">||</span>]</span></code></pre></div>
<p>Although this is something to be aware, it is not a big price to pay.</p>
<h3 id="arent-quotations-and-splices-automatic">Aren’t quotations and splices automatic?</h3>
<p>Using <code>Code Matcher</code> instead of <code>Matcher</code> completely determines where the
splices and quotations need to be placed without any ambiguity or significant
modification to the code. This raises the question why do we need to do
something that requires no programmer ingenuity? Isn’t it better to leave it to
the compiler to synthesise? I am not sure about the answer.</p>
<p>I know staged computation in <a href="https://www.cs.cmu.edu/~fp/papers/jacm00.pdf">ML-like languages can be understood as the S4
temporal modal logic</a> (2000,
Davies and Pfenning). Quoting and splicing correspond to boxing and unboxing.
Further, I know that in some linear logics boxing and unboxing at term-level can
sometimes be synthesised. This makes me wonder if the same is possible for
staged computation. If so, it feels like a shame to do something mechanical by
hand.</p>
<h3 id="polymorphism-have-your-interpreter-and-your-compiler-too">Polymorphism: have your interpreter and your compiler too!</h3>
<p>Although we framed the staged interpreter as a more efficient version of the
original interpreter, staging can’t help us if the regular expression isn’t
known at compile time.</p>
<h2 id="conclusion">Conclusion</h2></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
