<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Staged Wins</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on April 10, 2020
  
  
    and last updated on September  1, 2020
  
</div>

<h1>Staged Wins</h1>


<p class="in-which">In which we look at how effortless and profitable staged programming is in Haskell by microbenchmarking a regular expression interpreter and staged compiler.</p>


<div class="post"><p>As Haskell programmers, we live and die by the maxim “never do at runtime what could be done at compile time”. However, we (or at least me) almost exclusively understand this as doing safety checks before runtime and do not appreciate the full generality of the maxim. Although an optimising compiler will do much computation before runtime, as a programmer we hardly ever have a say on the matter.</p>
<p>The singular exception to this in many languages compiled or otherwise is <em>metaprogramming</em> where the purpose of our code is to generate code. If you think about it, the concept is remarkably prevalent in many languages from C preprocessor macros to abuses of C++ template system, from Ruby’s highly maleable object model to Java’s class loader API. In fact, in Haskell alone it comes at least in three flavours: datatype-generic programming, Template Haskell (henceforth TH), Typed-Template Haskell (henceforth TTH). The first is convenient but comes at a runtime cost. The second one is performed at compile time, but is unprincipled, potentially unhygienic, and effectively untyped. The third restricts Template Haskell, but it achieves principled and well-typed metaprograms with decent error messages!</p>
<p>TTH is thus what I discuss in this post. In particular, I take a naïve regular expression recogniser and mindlessly apply TTH’s quotations and splices to answer two questions:</p>
<ol type="1">
<li>Is it a pain to do use TTH?</li>
<li>What do I get out of going through this exercise?</li>
</ol>
<p>The short answers are “not really” and “4x performance improvement in time”. However, the justification for the first answer is my highly subjective value judgements with caveats and that for the second is microbenchmarks on a few examples. So if your reputation is on the line, I suggest you don’t cite this blog post to support your argument. For that, I’d go read articles, posts, and libraries by <a href="https://mpickering.github.io">Matthew Pickering</a>, <a href="https://www.cl.cam.ac.uk/~jdy22/">Jeremy Yallop</a>, or <a href="https://namin.seas.harvard.edu/people/nada-amin">Nada Amin</a>.</p>
<p>In the rest of this post, we first quickly look at the regular expression recogniser in question. We then stage it. Having two these interpreted and staged versions at hand, we qualitatively compare them using microbenchmarks and look at the generated code to try to understand the performance difference. Finally, we remark on the convenience of staging this program and conclude.</p>
<h2 id="a-simple-regular-expression-interpreter">A simple regular expression interpreter</h2>
<p>We implement an interpreter just sophisticated enough to represent some fictional phone number regular expression: <code>0?\d\d\d\d(\w|-)*\d\d\d(\w|-)*\d\d\d</code>. This would recognise <code>01234 567 890</code> without the leading zero and with or without spaces at the designated places and optionally with hyphens.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">RegExp</span> <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="dt">Null</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">|</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="fu">|</span> <span class="dt">RegExp</span> <span class="fu">:|:</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="fu">|</span> <span class="dt">RegExp</span> <span class="fu">:.:</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="fu">|</span> <span class="dt">Star</span> <span class="dt">RegExp</span></a></code></pre></div>
<p>A number of useful regular expressions and primitives can be defined right away.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">digit ::</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb2-2" title="2">digit <span class="fu">=</span> <span class="fu">foldr1</span> (<span class="fu">:|:</span>) (<span class="fu">map</span> <span class="dt">Char</span> [<span class="ch">'0'</span><span class="fu">..</span><span class="ch">'9'</span>])</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">whitespace ::</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb2-5" title="5">whitespace <span class="fu">=</span> <span class="dt">Char</span> <span class="ch">' '</span> <span class="fu">:|:</span> <span class="dt">Char</span> <span class="ch">'\t'</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">-- r+</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="ot">plus ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb2-9" title="9">plus re <span class="fu">=</span> re <span class="fu">:.:</span> <span class="dt">Star</span> re</a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">-- r?</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="ot">optional ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb2-13" title="13">optional re <span class="fu">=</span> re <span class="fu">:|:</span> <span class="dt">Null</span></a></code></pre></div>
<p>This is enough to represent our target regular expression.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">phoneNumber ::</span> <span class="dt">RegExp</span></a>
<a class="sourceLine" id="cb3-2" title="2">phoneNumber <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" title="3">  optional <span class="st">&quot;0&quot;</span> <span class="fu">:.:</span></a>
<a class="sourceLine" id="cb3-4" title="4">  digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> (<span class="dt">Star</span> whitespace <span class="fu">:|:</span> <span class="st">&quot;-&quot;</span>) <span class="fu">:.:</span></a>
<a class="sourceLine" id="cb3-5" title="5">  digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> (<span class="dt">Star</span> whitespace <span class="fu">:|:</span> <span class="st">&quot;-&quot;</span>) <span class="fu">:.:</span></a>
<a class="sourceLine" id="cb3-6" title="6">  digit <span class="fu">:.:</span> digit <span class="fu">:.:</span> digit</a></code></pre></div>
<p>All there remains is to interpret these regular expressions. We interpret regular expressions as <code>Matcher</code>s which are functions that takes a string input, matches the regular expression to the longest prefix, and returns whatever remains. If the string could not be matched at all, it returns nothing.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> <span class="dt">Matcher</span> <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">matchStar ::</span> <span class="dt">Matcher</span> <span class="ot">-&gt;</span> <span class="dt">Matcher</span></a>
<a class="sourceLine" id="cb4-4" title="4">matchStar matcher str <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="kw">case</span> matcher str <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dt">Just</span> rest <span class="ot">-&gt;</span> matchStar matcher rest</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> str</a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="ot">interpret ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Matcher</span></a>
<a class="sourceLine" id="cb4-10" title="10">interpret <span class="dt">Null</span> <span class="fu">=</span> <span class="fu">pure</span></a>
<a class="sourceLine" id="cb4-11" title="11">interpret (<span class="dt">Char</span> c) <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-12" title="12">  (c' <span class="fu">:</span> rest) <span class="fu">|</span> c <span class="fu">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</a>
<a class="sourceLine" id="cb4-13" title="13">  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb4-14" title="14">interpret (re1 <span class="fu">:|:</span> re2) <span class="fu">=</span> (<span class="fu">&lt;|&gt;</span>) <span class="fu">&lt;$&gt;</span> interpret re1 <span class="fu">&lt;*&gt;</span> interpret re2</a>
<a class="sourceLine" id="cb4-15" title="15">interpret (re1 <span class="fu">:.:</span> re2) <span class="fu">=</span> interpret re1 <span class="fu">&gt;=&gt;</span> interpret re2</a>
<a class="sourceLine" id="cb4-16" title="16">interpret (<span class="dt">Star</span> re)     <span class="fu">=</span> matchStar (interpret re)</a></code></pre></div>
<p>The interpreter does not try to be clever. It compositionally interprets regular expressions and combines them using monadic or applicative combinators.</p>
<p>A matcher defined by the interpreter is not quite what we are after as we want exact matches. It is easy enough to make one of those out of a matcher.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">Recogniser</span> <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ot">toRecogniser ::</span> <span class="dt">Matcher</span> <span class="ot">-&gt;</span> <span class="dt">Recogniser</span></a>
<a class="sourceLine" id="cb5-4" title="4">toRecogniser m str <span class="fu">=</span> m str <span class="fu">==</span> <span class="dt">Just</span> []</a></code></pre></div>
<p>This is all there is to our regular expression interpreter.</p>
<h2 id="staging-the-interpreter">Staging the interpreter</h2>
<p>So what treacherous road to optimisation is ahead of us? As it turns out, it is a short and painless one. You only need to be aware of three things if you want to use TTH: <code>TExpQ</code>, the quotation operator <code>[|| exp ||]</code>, and and the splice operator <code>$$code</code>.</p>
<p><code>TExpQ a</code> is the typed equivalent of TH’s <code>Q Exp</code>. This already gives away that we can only generate expressions with TTH. The type parameter <code>a</code> is the type of the expression the generated code will evaluate to. This is entirely missing in <code>Q Exp</code>, hence the “Typed” in TTH. This <code>TExpQ</code> constructor is, however, does not have a terribly informative name, so I alias it with <code>Code</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">type</span> <span class="dt">Code</span> a <span class="fu">=</span> <span class="dt">TExpQ</span> a</a></code></pre></div>
<p>The quotation operator (<code>[|| exp ||]</code>) takes an expression of type <code>a</code> and turns it into <code>Code a</code>. The splice (<code>$$code</code>) operator goes the other way. In other words, the former produces the code for some evaluation and the latter <em>in the right context</em> evaluates that code.</p>
<p>If you then have something you want evaluated at compile time for sure, you just write a function of the form <code>a -&gt; Code b</code>. The <code>a</code> is what you want to get rid of at runtime and the <code>Code b</code> is what you end up with as a result.</p>
<p>In our case, we had an interpreter with type <code>RegExp -&gt; Matcher</code> and we want to compile the regular expression away, so we’d like a function <code>RegExp -&gt; Code Matcher</code> instead. Well, how are we going to get there? Mechanically! Mindlessly! Mercilessly?</p>
<p>Let’s take the first case:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">interpret <span class="dt">Null</span> <span class="fu">=</span> <span class="fu">pure</span></a></code></pre></div>
<p>The <code>Matcher</code> is just <code>pure</code> and we want <code>Code Matcher</code>, so we just do <code>[|| pure ||]</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">compile <span class="dt">Null</span> <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">pure</span> <span class="fu">||</span>]</a></code></pre></div>
<p>Okay, maybe we got lucky with that one. Let’s try the second case.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">interpret (<span class="dt">Char</span> c) <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-2" title="2">  (c' <span class="fu">:</span> rest) <span class="fu">|</span> c <span class="fu">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</a>
<a class="sourceLine" id="cb9-3" title="3">  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Remember that <code>Matcher</code> is a lambda, so that forces us to place the quotation outside the lambda case expression and we are done.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">compile (<span class="dt">Char</span> c) <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-2" title="2">  [<span class="fu">||</span></a>
<a class="sourceLine" id="cb10-3" title="3">    \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-4" title="4">      (c' <span class="fu">:</span> rest) <span class="fu">|</span> c <span class="fu">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</a>
<a class="sourceLine" id="cb10-5" title="5">      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="fu">||</span>]</a></code></pre></div>
<p>Now, you’re thinking that base cases are always easy, so let’s try a recursive one.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">interpret (re1 <span class="fu">:|:</span> re2) <span class="fu">=</span> (<span class="fu">&lt;|&gt;</span>) <span class="fu">&lt;$&gt;</span> interpret re1 <span class="fu">&lt;*&gt;</span> interpret re2</a></code></pre></div>
<p>We know the result is going to be <code>Code Matcher</code>, so we place the quotation outsite the body once more.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">compile (re1 <span class="fu">:|:</span> re2) <span class="fu">=</span> [<span class="fu">||</span> (<span class="fu">&lt;|&gt;</span>) <span class="fu">&lt;$&gt;</span> compile re1 <span class="fu">&lt;*&gt;</span> compile re2 <span class="fu">||</span>]</a></code></pre></div>
<p>However, this won’t compile because <code>compile</code> has type <code>RegExp -&gt; Code Matcher</code> then the expression inside the quotation needs to have the type <code>Matcher</code>. Thus, the recursive calls are ill-typed. They have type <code>Code Matcher</code> instead of <code>Matcher</code>, but we already know how to go in this direction with a splice!</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">compile (re1 <span class="fu">:|:</span> re2) <span class="fu">=</span> [<span class="fu">||</span> (<span class="fu">&lt;|&gt;</span>) <span class="fu">&lt;$&gt;</span> <span class="fu">$$</span>(compile re1) <span class="fu">&lt;*&gt;</span> <span class="fu">$$</span>(compile re2) <span class="fu">||</span>]</a></code></pre></div>
<p>We are done once more. The next two recursive cases are treated similarly. So overall, we end up with a compiler strikingly similar to the interpreter. Most surprisingly, we exercised almost no brain cells along the way.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">compile ::</span> <span class="dt">RegExp</span> <span class="ot">-&gt;</span> <span class="dt">Code</span> <span class="dt">Matcher</span></a>
<a class="sourceLine" id="cb14-2" title="2">compile <span class="dt">Null</span> <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">pure</span> <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb14-3" title="3">compile (<span class="dt">Char</span> c) <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-4" title="4">  [<span class="fu">||</span></a>
<a class="sourceLine" id="cb14-5" title="5">    \<span class="kw">case</span></a>
<a class="sourceLine" id="cb14-6" title="6">      (c' <span class="fu">:</span> rest) <span class="fu">|</span> c <span class="fu">==</span> c' <span class="ot">-&gt;</span> <span class="dt">Just</span> rest</a>
<a class="sourceLine" id="cb14-7" title="7">      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb14-8" title="8">  <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb14-9" title="9">compile (re1 <span class="fu">:|:</span> re2) <span class="fu">=</span> [<span class="fu">||</span> (<span class="fu">&lt;|&gt;</span>) <span class="fu">&lt;$&gt;</span> <span class="fu">$$</span>(compile re1) <span class="fu">&lt;*&gt;</span> <span class="fu">$$</span>(compile re2) <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb14-10" title="10">compile (re1 <span class="fu">:.:</span> re2) <span class="fu">=</span> [<span class="fu">||</span> <span class="fu">$$</span>(compile re1) <span class="fu">&gt;=&gt;</span> <span class="fu">$$</span>(compile re2) <span class="fu">||</span>]</a>
<a class="sourceLine" id="cb14-11" title="11">compile (<span class="dt">Star</span> re)     <span class="fu">=</span> [<span class="fu">||</span> matchStar <span class="fu">$$</span>(compile re) <span class="fu">||</span>]</a></code></pre></div>
<p>Let’s use it on an example. We first start a new file with a new module (this bit is important and <a href="#qualitative-remarks">an explanation will follow</a>). Then, we see if the regular expression <code>&quot;ab&quot;</code> recognises the string <code>&quot;ababababab&quot;</code> in the module.</p>
<pre><code>resInterpreted = toRecogniser $ interpret $ Star &quot;ab&quot;
resCompiled    = toRecogniser $$(compile $ Star &quot;ab&quot;)</code></pre>
<h2 id="microbenchmarks">Microbenchmarks</h2>
<p>Staging was easy enough, but what does it buy us? A general answer is difficult, but here’s one microbenchmark. We look at the speed at which the interpreted and staged regular expression recognisers match <code>0?\d\d\d\d(\w|-)*\d\d\d(\w|-)*\d\d\d</code> against the following:</p>
<pre><code>04207999163
0420799916
04207 999 163
04207-999-163
04207 a99 163
04207    999    163
04207  0 999    163
4207    999    163</code></pre>
<p>The results indicate a convincing ~4x win when compiled with <code>-O0</code> and <code>-O2</code> indicated by the microbenchmarks conducted using the <code>criterion</code> library.</p>
<figure>
<img src="../images/staged-wins/microbenchmarks-O0.png" alt="Microbenchmark results for -O0" /><figcaption>Microbenchmark results for -O0</figcaption>
</figure>
<figure>
<img src="../images/staged-wins/microbenchmarks-O2.png" alt="Microbenchmark results for -O2" /><figcaption>Microbenchmark results for -O2</figcaption>
</figure>
<h3 id="but-why">But why?</h3>
<p>There are four reasons I can think of why staging would yield performance benefits: domain-specific optimisations, enabling compiler optimisations, microarchitectural wins, and doing less work.</p>
<p>We know it is not domain-specific optimisations because we haven’t done any. By comparing the graphs of -O0 and -O2, we can also see that the timings for <code>compile</code> are consistent, so it is not GHC doing more optimisations (this surprises me).</p>
<p>There remains the microarchitectural wins and doing less work. To see if these are in play we need to take a deeper look.</p>
<h2 id="qualitative-remarks">Qualitative remarks</h2>
<h2 id="conclusion">Conclusion</h2></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
