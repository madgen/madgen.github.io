<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-41394820-3"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-41394820-3');
        </script>

        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="description" content="Mistral Contrastin's thought bubble,
          blog, and personal revelations." />
        <meta name="author" content="Mistral Contrastin" />
        <title>Do disturb me | Automatic Subgoal Scheduling for Datalog</title>
        <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" href="../atom.xml" />

        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png" />
    </head>
    <body>
        <div id="header">
            <div class="top-container">
              <div id="logo">
                  <a href="../">Do Disturb Me</a>
              </div>
              <div id="navigation">
                  <a href="../archive.html">Blog</a>
                  <a href="../teaching.html">Teaching</a>
              </div>
            </div>
            <div id="mandelbrot"></div>
        </div>

        <div id="content">
            <div class="info">
  Posted on October  8, 2018
  
  
  by Mistral Contrastin
</div>

<h1>Automatic Subgoal Scheduling for Datalog</h1>


<p class="in-which">In which we investigate dataflow in declarative programs and talk about how to make Datalog safer by statically reordering goals when predicates with dataflow constraints are involved.</p>


<div class="post"><p>I recently presented <em>“Automatic Reordering for Dataflow Safety of Datalog”</em>
(can be accessed freely if you follow the link from <a href="https://dodisturb.me">my
homepage</a>) in the <a href="http://ppdp-lopstr-18.cs.uni-frankfurt.de/ppdp18.html">20th Symposium on Principles and
Practice of Declarative
Languages</a>. I
collaborated with <a href="https://www.cs.kent.ac.uk/people/staff/dao7/">Dr Dominic
Orchard</a> and <a href="https://www.cl.cam.ac.uk/~acr31/">Dr Andrew
Rice</a> for this work. A few commented that the
paper is technically dense and consequently hard going. I don’t want this work
to be ignored because I suck at writing. So in an attempt to make things right
and also to do some PR, I will explain the major ideas of the paper without the
formalism and with numerous examples.</p>
<p>I want this post to be understandable with ease. If you find yourself confused
or bored at any point or found some terms that are not very well explained,
contact me via Twitter or email (both on <a href="https://dodisturb.me">my homepage</a>).</p>
<p>After explaining some standard terminology about Datalog, we start by describing
what extralogical predicates are, why one might want them in Datalog, and what
problems they bring along. Then we clarify what is meant by invocation safety of
such predicates. This will lead us to the naïve, incomplete, and inefficient
solution and that will lead us to a better solution. I’ll conclude by giving
summarising the main points, mentioning where this work work might go and why
you might like to look at the paper.</p>
<h2 id="terminology">Terminology</h2>
<p>Let’s briefly look at basic Datalog terminology through an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ancestor(<span class="dt">X</span><span class="kw">,</span><span class="dt">Z</span>) <span class="kw">:-</span> parent(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> parent(<span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)<span class="kw">.</span></span></code></pre></div>
<pre><code>                 -----------  -----------
                   Subgoal      Subgoal
-------------    ------------------------
    Head                   Body
------------------------------------------
                  Rule</code></pre>
<ul>
<li>This is a <strong>rule</strong> in Datalog (as it happens also in Prolog) with some parts
highlighted.</li>
<li>A rule consists of a <strong>head</strong> (to the left of <code class="sourceCode prolog"><span class="kw">:-</span></code>) and a <strong>body</strong>
(everything to the right of <code class="sourceCode prolog"><span class="kw">:-</span></code>). A body is a comma separated list of
subgoals.</li>
<li>A <strong>subgoal</strong> is a predicate applied to a tuple.</li>
<li>A <strong>predicate</strong> qualifies a tuple with a name (sort). Throughout the text, we
write subgoals in <code>monospace</code> and predicates in <span class="math inline">\(italic\)</span>. We sometimes say “the
<span class="math inline">\(p\)</span> subgoal” to refer to a subgoal formed by applying the predicate <span class="math inline">\(p\)</span> to a
tuple. We also say “the <span class="math inline">\(p\)</span> rule(s)” to mean the rules with the predicate <span class="math inline">\(p\)</span>
featured in the head.</li>
<li>A tuple of subgoal consists of <strong>terms</strong> which are either <strong>constants</strong> like
<code>"Dragon Fruit"</code> (with quotation marks) or <strong>variables</strong> like <code>Fruit</code> (no
quotations, always capitalised).</li>
</ul>
<p>We’re good to go! All other terms will be defined in the text as we go along.</p>
<h2 id="motivation">Motivation</h2>
<h4 id="example-1">Example 1</h4>
<p>Here’s a hypothetical Datalog rule that authenticates a user:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>The reading of any rule in Datalog is “if every subgoal in the body holds, then
we can conclude the head.” In this specific case, we can authenticate a user if
we have a known password for a that user and the hash of that user is known to
be valid. One of the nicest parts of this reading is that it doesn’t matter
which order the subgoals are presented, we still reach the same conclusion. For
example,</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>would authenticate exactly the same users as the previous example.</p>
<p>When the predicates in a program are <em>logical</em>, there are no
dataflow restrictions for evaluation of a subgoal with that predicate. For
example, <code class="sourceCode prolog">password(<span class="ot">&quot;</span><span class="er">Milner</span><span class="ot">&quot;</span><span class="kw">,</span><span class="dt">Pass</span>)</code> would bind the password of Milner to
<code>Pass</code> while <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> would generate all known user and
password pairs. There are no inherent input and output parameters to a logical
predicate.</p>
<p>However, the <span class="math inline">\(hash\)</span> predicate stands out because hash functions (if they are any
good) work only in one direction. It is unreasonable to expect <span class="math inline">\(hash\)</span> to bind a
value for the password given a hash. Let’s refer to predicates like <span class="math inline">\(hash\)</span>
(those with dataflow requirements) as <em>extralogical</em> predicates.</p>
<p>In light of this knowledge, the versions of the rule defining <span class="math inline">\(auth\)</span> above are
not equivalent. Evaluation of the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> produces a
runtime error if the value of <code>Pass</code> is unknown. Suddenly, we have to be careful
about the way we order subgoals. Not only those that are obviously extralogical
like <span class="math inline">\(hash\)</span>, but also any user-defined predicates that make use of extralogical
ones! To make the matters worse, although semantically arithmetic
relations such as <span class="math inline">\(&gt;\)</span> are logical, they are usually implemented as extralogical
predicates (or relations).</p>
<h4 id="example-2">Example 2</h4>
<p>Just when you think things are looking bleak, it gets worse. Extralogical
predicates may also cause code duplication. Let’ look at another example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Here, we define a predicate <span class="math inline">\(weak\)</span> that checks if a password or a hash is weak.
It does so looking for the hash of the password in a rainbow function (a
function that can reverse <em>some</em> hashes). Like <span class="math inline">\(hash\)</span>, <span class="math inline">\(rainbow\)</span> is also
extralogical but in its second argument rather than the first. Now it is
beneficial for both the client and the server to check if a hash is weak, but
the client shouldn’t know the hash of a given password (otherwise it can
construct a rainbow table of its own!) and the server shouldn’t know the
password (in case it gets stolen). Hence, there are two predicates
<span class="math inline">\(check\_client\)</span> that takes a password and <span class="math inline">\(check\_server\)</span> that takes a hash that
can be used by the client and server respectively.</p>
<p>This example is worse than the previous one because regardless how careful the
programmer is, she can’t rewrite the definition of <span class="math inline">\(weak\)</span> in a single rule such
that all dataflow requirements are satisfied. Now when <span class="math inline">\(check\_client\)</span> is used,
<span class="math inline">\(weak\)</span> should have the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first, since the
password is known (satisfying <span class="math inline">\(hash\)</span>’s dataflow requirement) and evaluating this
subgoal produces a hash, satisfying the dataflow requirement of <span class="math inline">\(rainbow\)</span>. If
<span class="math inline">\(check\_server\)</span> is used, we need the opposite ordering because this time the
hash value is known initially. So neither rule alone can be used to satisfy the
requirements of the whole program. The only solution is a code duplicating
rewrite:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak_client(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak_server(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>weak_client(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>weak_server(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<h4 id="example-3">Example 3</h4>
<p>If you’re still not sold on the idea, I have one final motivating example. Even
in the purely logical implementations of Datalog, dataflow problems exist.
Negation is indispensable in logic programming. However, there is a difficulty
with it. Consider the following rule:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>accessed(<span class="ot">&quot;</span><span class="er">Mistral</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>accessed(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>accessed(<span class="ot">&quot;</span><span class="er">Rebecca</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>password(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span> <span class="kw">,</span><span class="ot">&quot;171717&quot;</span>)<span class="kw">.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>password(<span class="ot">&quot;</span><span class="er">Rebecca</span><span class="ot">&quot;</span><span class="kw">,</span><span class="ot">&quot;242424&quot;</span>)<span class="kw">.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>guest(<span class="dt">User</span>) <span class="kw">:-</span> not password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> accessed(<span class="dt">User</span>)<span class="kw">,</span> guest(<span class="dt">User</span>)<span class="kw">.</span></span></code></pre></div>
<p>This program poses the query “out of those who are known to access the system,
which ones are guests?”. Being a guest is defined as not having a password
recorded for the given user identifier. Most implementations would reject this
program because of something called <em>allowedness</em>. This means we can only
conclude facts about constants that are known to the system. In this example, we
can only conclude positive or negative facts about Mistral, Rebecca, and Hattie,
but not about Alice.</p>
<p>In principle, this should be fine because the values <code>User</code> variable can take
are already restricted by the <code class="sourceCode prolog">accessed(<span class="dt">User</span>)</code> subgoal in the query.
However, most implementations of Datalog would reject this as this subgoal does
not appear directly within the rule of <span class="math inline">\(guest\)</span> and before the negated subgoal.
This is a conservative approximation. Notice that we have not used any
extralogical predicates, yet negated subgoals automatically require all
variables appearing inside them to be bound by the subgoals preceding them. This
is precisely the problem we have with extralogical predicates.</p>
<h3 id="overall-sentiment">Overall sentiment</h3>
<p>The chances are if you chose a declarative language such as Datalog over an
imperative alternative, these sort of details are exactly what you are trying to
run away from. It seems here we’re forced to choose between useful functionality
and high-level programming. The work that follows allows you to have both and
do so without incurring a runtime performance penalty.</p>
<h2 id="understanding-invocation-safety">Understanding invocation safety</h2>
<p>Although the examples illustrate the problems with extralogical predicates, they
do not provide us anything concrete to compute with. We need a way of
representing bindings of parameters and dataflow requirements in the program.
As soon as we define these, the precise definition of invocation safety is
simple.</p>
<h3 id="adornments-concrete-parameter-binding">Adornments: concrete parameter binding</h3>
<p><em>Adornments</em> indicate whether a parameter is bound or not. <em>Adornment
transformation</em> is the standard analysis that computes it. Let’s understand this
using <a href="#example-1">Example 1</a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Is the argument <code>Pass</code> in the subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> bound? Yes, it
is because the preceding subgoal <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> has this
variable in it and its evaluation binds <code>Pass</code>. How about the <code>Pass</code> argument in
<code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code>? It is free because we haven’t even seen this
variable before<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, there is no way something else could have bound
it. How about the <code>User</code> argument appearing in the same subgoal? It depends on
the caller of the <span class="math inline">\(auth\)</span> predicate.</p>
<p>Different queries yield different answers:</p>
<ol type="1">
<li><code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> asks which user &amp; password pairs can be
authenticated. Since we do not know which user to authenticate, the variables
in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> are not bound to values.</li>
<li><code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span><span class="kw">,</span><span class="dt">Pass</span>)</code> asks if Alice is authenticated. Since we
know which user to authenticate, <code>User</code> in <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> is
bound to a value but not <code>Pass</code>.</li>
</ol>
<p>What we learn from that example is the following:</p>
<ol type="1">
<li>Adornment is a top-down procedure starting from the query, the binding
information flows down.</li>
<li>Constants such as <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span></code> are ground, hence are bound.</li>
<li>Variables of a subgoal are bound if they appear in subgoals that precede
them like <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> preceding <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>.</li>
<li>Variables of a subgoal are also bound when they are bound in the head of a
rule. For example, <code class="sourceCode prolog"><span class="fu">?-</span> auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span><span class="kw">,</span><span class="dt">Pass</span>)</code> makes the <code>User</code> variable
in the head of the <span class="math inline">\(user\)</span> rule bound. Consequently, the <code>User</code> variable in
<code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> is bound.</li>
</ol>
<p>These four rules define a top-down procedure for binding. Let’s invent something
concrete to compute with. Let’s annotate parameters that are bound with <code>b</code> and
those that are free with <code>f</code>. In the query, <code class="sourceCode prolog">auth(<span class="ot">&quot;</span><span class="er">Alice</span><span class="ot">&quot;</span><span class="kw">,</span><span class="dt">Pass</span>)</code>
receives the pattern <code>bf</code> due to the constant and this information flows down to
the rules with head predicate <span class="math inline">\(auth\)</span>. Then, <code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> in
the body of <span class="math inline">\(auth\)</span> rule receives <code>bf</code> because <code>User</code> is bound in the head and
<code>Pass</code> is not. The subgoal <code class="sourceCode prolog">hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> would have <code>bf</code> because
<code>Pass</code> appears in the preceding subgoal and <code>Hash</code> has never been observed
before. As an exercise you can try to figure out the binding pattern for
<code class="sourceCode prolog">valid(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> from the previous example (the answer<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>).</p>
<h4 id="example-4">Example 4</h4>
<p>Before moving on from adornments, let’s look at an extension of Example 2. There
is something that brings us closer to the solution of the code duplication
problem described above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> check_client(<span class="ot">&quot;123456&quot;</span>)<span class="kw">.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> check_server(<span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>check_client(<span class="dt">Pass</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>check_server(<span class="dt">Hash</span>) <span class="kw">:-</span> weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>This is the same program in <a href="#example-2">Example 2</a> except that we have two
queries one using the <span class="math inline">\(check\_client\)</span> predicate and the other using
<span class="math inline">\(check\_server\)</span>. Now let’s adorn this program but rather than noting the
adornment patterns separately, let’s make them suffixes to the names of the
predicates. This is how this analysis is usually conduct and is the reason why
it is referred as a transformation despite being an analysis in spirit. As it is
a top-down procedure we start from the queries.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> check_client_b(<span class="ot">&quot;123456&quot;</span>)<span class="kw">.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> check_server_b(<span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span></span></code></pre></div>
<p>Both queries receive the pattern <code>b</code> because all arguments are constants. Next
we propagate this to the rules defining <span class="math inline">\(check\_client\)</span> and <span class="math inline">\(check\_server\)</span>
predicates.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>check_client_b(<span class="dt">Pass</span>) <span class="kw">:-</span> weak_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>check_server_b(<span class="dt">Hash</span>) <span class="kw">:-</span> weak_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>The heads of each predicate receive their adornments directly from their
callers. Since both callers have the pattern <code>b</code>, so do the heads. Now in the
bodies, we have <span class="math inline">\(weak\_bf\)</span> and <span class="math inline">\(weak\_fb\)</span> predicates because
<code class="sourceCode prolog">check_client_bf(<span class="dt">User</span>)</code> binds the first parameter of
<code class="sourceCode prolog">weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> and
<code class="sourceCode prolog">check_client_fb(<span class="dt">User</span>)</code> binds the second parameter of
<code class="sourceCode prolog">weak(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>. Since
we have two different bindings for <span class="math inline">\(weak\)</span>, we need two versions of <span class="math inline">\(weak\)</span> body.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>weak_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_bf(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_bb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>weak_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_fb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_bb(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>The adornment of these rules are done exactly as before, so I won’t describe
them again. The important point is the adornment patterns of subgoals are
effected by the adornments patern of the head. The binding patterns of <code>hash</code>
above are <code>bf</code> and <code>fb</code> and this difference stems only from the head of the
rules.</p>
<p>This looks remarkably similar to the code duplication solution we found to the
problem described in <a href="#example-2">Example 2</a>. Once again, we ended up with two
different versions of weak with suffixes are <code>bf</code> and <code>fb</code> instead of <code>client</code>
and <code>server</code>. This is a superfluous difference. The important difference is that
the <span class="math inline">\(weak\_fb\)</span> rule is not reordered while the <span class="math inline">\(weak\_check\)</span> rule is. So it
can’t be a solution to the invocation safety on its own, but it is a step in the
right direction and we develop this further <a href="#generalised-adornment">below</a>.</p>
<h3 id="modes-concrete-dataflow-requirements">Modes: concrete dataflow requirements</h3>
<p>A <em>mode</em> is an indication of input/output behaviour. Each predicate logical or
otherwise have a <em>mode pattern</em> associated with it. We only need two modes for
Datalog <code>+</code> and <code>?</code>. If the invocation a predicate is going to be safe,
parameters with mode <code>+</code> must be bound and those with mode <code>?</code> are always safe
bound or not.</p>
<p>For example, <span class="math inline">\(hash\)</span> from <a href="#example-1">Example 1</a> has a <code>+?</code> pattern because its
first parameter needs to be bound at the time of invocation and the second
parameter may be bound or not. If we evaluate the subgoal
<code class="sourceCode prolog">hash(<span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span><span class="kw">,</span><span class="ot">&quot;42&quot;</span>)</code>, <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span></code> must be there to safely
execute <span class="math inline">\(hash\)</span>, but it doesn’t matter <code class="sourceCode prolog"><span class="ot">&quot;42&quot;</span></code> is there because if the
hash of <code class="sourceCode prolog"><span class="ot">&quot;</span><span class="er">Hattie</span><span class="ot">&quot;</span></code> is <code class="sourceCode prolog"><span class="ot">&quot;0&quot;</span></code>, then we can compare
<code class="sourceCode prolog"><span class="ot">&quot;0&quot;</span></code> and <code class="sourceCode prolog"><span class="ot">&quot;42&quot;</span></code> safely. Let’s look at <span class="math inline">\(password\)</span> now. That
predicate is a lot like a database table, there are no restrictions on what you
can use to look up values. Hence, it has the mode pattern <code>??</code>. In standard
Datalog, all predicates have <code>?</code> mode associated with all of their
parameters<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Let’s adopt a scheme of amending the predicate name with mode patterns to make
things syntactically obvious just as we did in the <a href="#example-4">adornments
example</a>. <a href="#example-1">Example 1</a> becomes</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>You notice there is an <code>xx</code> in place of <code>f</code>s and <code>b</code>s for the <span class="math inline">\(auth\)</span> predicate.
That’s because we don’t know a way of determining modes of user-defined
predicates. Intuitively, dataflow requirements of a user-defined predicate is
some function of the subgoals that define those predicates. Indeed, finding an
effective procedure to precisely determine mode patterns of user-defined
predicates is the only hard part of our quest to ensure invocation safety. We
explore this soon in the <a href="#solution">solution</a>.</p>
<h3 id="relating-adornments-to-modes-aka.-invocation-safety">Relating adornments to modes (aka. invocation safety)</h3>
<p>Remember <code>b</code> means the parameter <strong>is bound</strong> and <code>+</code> means the parameter
<strong>needs to be bound</strong>. Modes and adornments are clearly related. Their main
differences are:</p>
<ul>
<li>Adornment transformation needs an entry point (a query) and <strong>dataflow
information flows top-down</strong> from heads to the bodies. We don’t have a
procedure for computing modes (yet), but we mentioned the predicates defined in
the heads should be a function of those in the body. This suggests a
<strong>bottom-up information flow</strong>.</li>
<li>Binding (adornment) patterns <strong>qualify subgoals</strong> (predicates
applied to tuples of variable and constants). Mode patterns, on the other hand,
<strong>qualify predicates</strong> and hence don’t change from one subgoal to another.</li>
<li>Related to the previous point, adornment is entirely dependent on the query,
whereas modes are not. This suggests we can perhaps compute modes beforehand
and consult them as queries change.</li>
</ul>
<p>The agreement between adornments and modes be made precise: in an adorned
program, invocations of extralogical predicates are safe when all subgoals with
extralogical predicates are adorned with <code>b</code> for parameters with mode <code>+</code>. This
can be restated as the following almost tautological statement: <strong>if something
needs to be bound, then it is bound.</strong></p>
<p>In the literature, invocation safety is called <em>well-modedness</em>. A well-moded
query &amp; program pair doesn’t produce invocation errors just as “well-typed
programs don’t go wrong” as <a href="https://en.wikipedia.org/wiki/Robin_Milner">Robin
Milner</a> put it.</p>
<h2 id="solution">Solution</h2>
<p>Now we start with the stupidest possible thing we can do and refine our
approach.</p>
<h3 id="naïve-solution">Naïve solution</h3>
<p>The examples so far suggest that we need a simple reordering of bodies. So why
not give that a go. Recall the variation of <a href="#example-1">Example 1</a> with
<a href="#modes-concrete-dataflow-requirements">mode embellishments</a>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Let’s adorn versions of this rule with the subgoals permuted with respect to
the query <code class="sourceCode prolog"><span class="fu">?-</span> auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code>. The heads of the rules are omitted
as they are always <code class="sourceCode prolog">auth_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="er">✖</span>password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?<span class="dt">_bf</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="er">✖</span>password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="er">✖</span>valid_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="er">✓</span>valid_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="er">✓</span>hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="er">✓</span>hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>The last three are invocation safe while the first three are not. Since <span class="math inline">\(hash\)</span>
is the only extralogical predicate with dataflow requirements, namely on its
first parameter <code>Pass</code>, orderings that leads to a bound mode
(<code>b</code>) at the first parameter are well-moded, while the others are not.</p>
<p>The obvious problem is if there are <span class="math inline">\(n\)</span> subgoals we may need to adorn <span class="math inline">\(n\)</span>
factorial orderings to find a suitable ordering. But perhaps that’s not a big
problem, if in practice programmers stick to 3 to 5 subgoals per rule. The
real problem is that we cannot isolate rules.</p>
<h4 id="example-5">Example 5</h4>
<p>Let’s say we do some software engineering and factor
<code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> and <code class="sourceCode prolog">valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> into a new
rule with head predicate <span class="math inline">\(check\)</span> as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Now let’s try adorning this program while considering different orderings of
<span class="math inline">\(check\)</span> as that is where the extralogical predicate <span class="math inline">\(hash\)</span> occurs.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> auth_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>auth_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?<span class="dt">_ff</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_fb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>check_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> valid_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>This looks bad because when we reorder <span class="math inline">\(check\)</span> rule alone, neither of the
orderings lead to an adornment that makes the invocation of <span class="math inline">\(hash\)</span> safe. They
both lead to a free first argument.</p>
<p>At this point we can just say that we have a sound but incomplete analysis,
tough luck. Alternatively, we recognise that the first parameter of the subgoal
with <span class="math inline">\(hash\)</span> is <code>Pass</code> which appear in the head of the rule. As we learn in
<a href="#adornments-concrete-parameter-binding">adornment transformation rules</a>,
if a parameter is bound in the head then it is also bound in the body. So all we
need is to turn the <code>ff</code> binding pattern of the head to <code>fb</code> or <code>bb</code>. This is
indeed possible if we reorder the use of <span class="math inline">\(check\)</span> within the <span class="math inline">\(auth\)</span> rule as
follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> auth_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>auth_xx_ff(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  password_??<span class="dt">_ff</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?<span class="dt">_bf</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??<span class="dt">_bb</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>check_xx_bb(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> valid_??<span class="dt">_bf</span>(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>After permuting the subgoals with <span class="math inline">\(password\)</span> and <span class="math inline">\(check\)</span>, we end up with <code>bb</code>
adornment for the head of <span class="math inline">\(check\)</span> and regardless the order of subgoals in the
body <span class="math inline">\(check\)</span>. This makes invocations of <span class="math inline">\(hash\)</span> safe in both cases.
Computationally, however, this is problematic. Search space is exponential not
only in the size of individual bodies but it is a multiplication of all possible
orderings of all rules from query down to the relevant rule. This is
intractable even for small programs. We address this not with elegance but with
some greed.</p>
<h3 id="greed-is-good">Greed is good</h3>
<p>We can’t do better than exponential asymptotically, but we can make it
exponential the way <a href="https://en.wikipedia.org/wiki/Hindley-Milner_type_system">Hindley-Milner type
inference</a> is—only
in degenerate cases.</p>
<p><strong>The most important insight</strong> to our solution is the following: although
dataflow requirements are inherent to the predicates, they are contextual. That
is to say if a predicate parameter has mode <code>+</code> (requiring it to be bound) and
the subgoal using that predicate has the variable <code>V</code> at that parameter, if a
preceding subgoal already binds <code>V</code>, we can safely pretend as if the predicate
has mode <code>?</code> in this context. So we can treat</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>... <span class="kw">:-</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> ...</span></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>... <span class="kw">:-</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_??(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> ...</span></code></pre></div>
<p>so <span class="math inline">\(hash\)</span> in that context behaves as if it is a logical predicate.</p>
<p>Now we exploit the contextual nature of dataflow. We schedule subgoals with no
dataflow requirements first such as <span class="math inline">\(password\)</span> and <span class="math inline">\(valid\)</span>. These subgoals can
be freely placed anywhere in the body as they are always safe to execute. So we
<strong>adopt a greedy approach</strong> and schedule subgoals with such predicates as early
as possible.</p>
<p>The benefits of this approach are twofold:</p>
<ol type="1">
<li>Combinatorially, there are fewer orderings to consider as placement of
logical subgoals are restricted.</li>
<li>More importantly, variables of scheduled subgoals are propagated to the
remaining alternatives to relax the dataflow constraints as described above.
This would lead to further opportunities to apply the greedy scheduling
principle.</li>
</ol>
<p>Scheduling of subgoals fit nicely into a graph where the edges are labelled with
subgoals to schedule and orderings are the paths from the root to vertices with
no successors.</p>
<h4 id="example-6">Example 6</h4>
<p>Let’s apply this strategy to <a href="#example-1">Example 1</a>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>The corresponding graph is:</p>
<pre><code>     {password, valid}             {hash}
V0 --------------------&gt; V1 -------------------&gt; V2</code></pre>
<p>This graph stores orderings where subgoals with predicates <span class="math inline">\(password\)</span> and
<span class="math inline">\(valid\)</span> are scheduled first and it doesn’t matter in which order, only then the
<span class="math inline">\(hash\)</span> subgoal is scheduled.</p>
<p>The subgoals with predicates <span class="math inline">\(password\)</span> and <span class="math inline">\(valid\)</span> could be scheduled first
because they have no dataflow requirements (indicated by <code>??</code> mode pattern).
The subgoal with <span class="math inline">\(hash\)</span> could not be scheduled at that point due to <code>+?</code> mode
pattern. However, as we established earlier in this section, mode
patterns can be relaxed in the right context. So if we treat the vertex <code>V1</code> in
the graph as a context, <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> behaves as
<code class="sourceCode prolog">hash_??(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> because on this path the subgoal
<code class="sourceCode prolog">password(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)</code> precedes it and binds <code>Pass</code>, thus we can
schedule it at that point using the greedy principle.</p>
<p>More concretely, this leads to the following orderings:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>These are the two of the three well-moded orderings found through brute-force
search in the <a href="#naïve-solution">naïve solution</a> described above. The ordering
we miss has <code>valid_??(User,Hash)</code> at the end of the body. Greedy scheduling
prevents us from discovering this ordering.</p>
<p>This raises the question <strong>“are there cases in which we discard the only safe
ordering?”</strong> The answer is no. If there is at least one safe ordering that can
be found by reordering, greedy scheduling will also find at least one valid
ordering. Surprisingly, <em>greed is good</em><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> and it doesn’t compromise
completeness.</p>
<p>Before we move on to other examples of scheduling graphs, we can finally address
the pending problem of determining mode patterns for user-defined predicates
posed where <a href="#modes-concrete-dataflow-requirements">modes are introduced</a>.</p>
<h3 id="modes-of-user-defined-predicates">Modes of user-defined predicates</h3>
<p>Let’s continue with <a href="#example-6">Example 6</a> and deduce what <code>xx</code> in
<code>auth_xx(User,Pass)</code> should be.</p>
<p>Since a mode marks a requirement of boundness, the first <code>x</code> should be <code>+</code> if
<code>User</code> needs to be bound for the invocation to be safe and it should be <code>?</code> if
invocation of all predicates in the body are safe regardless binding status of
<code>User</code>. The same reasoning applies to the second parameter. If invocation is
safe with a <code>?</code> mode, then it is also safe with a <code>+</code> mode, so we are looking
for the most relaxed mode<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. The orderings from the graph above
didn’t make any conditional reasoning about boundedness of <code>User</code> or <code>Pass</code>,
hence <code>??</code> is suitable for <span class="math inline">\(auth\)</span>. We can revise the two versions of the rule as
follows:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>auth_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>auth_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Here’s <strong>the beauty of this analysis result</strong>: despite the fact that we defined
<code>auth</code> with the use an extralogical predicate, we manage to make it behave as a
logical predicate wherever it is invoked. We just restored some of the lost
declarative promise!</p>
<h4 id="example-7">Example 7</h4>
<p>We first look at <a href="#example-5">Example 5</a> again:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>auth_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">,</span> password_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>)<span class="kw">.</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>check_xx(<span class="dt">User</span><span class="kw">,</span><span class="dt">Pass</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Let’s examine the interesting scheduling graph first that is the one for <code>check</code>
rule.</p>
<pre><code>     {valid}        {hash}
V1 ----------&gt; V2 ---------&gt; V3</code></pre>
<p>This graph looks similar to the previous one. We apply the greedy principle and
schedule <code class="sourceCode prolog">valid_??(<span class="dt">User</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first. The difference is the variable
bound by this subgoal (<code>User</code> and <code>Hash</code>) don’t include <code>Pass</code> which is the
dataflow restricted argument of <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code>. So the only way
we can schedule <span class="math inline">\(hash\)</span> is if <code>Pass</code> is already bound at the moment we start
evaluating the rule. This is same as saying the second parameter of <span class="math inline">\(check\)</span>
(which is <code>Pass</code>) has to be bound at the caller. For the first parameter, there
are no restrictions posed. Then, the overall mode pattern for check is <code>?+</code>.</p>
<p>In the description above, we kept track of which variables on the path has to be
resolved by the invoker of the predicate being defined. This information
naturally fits in the vertices of the graph. This is how we do it in the paper,
but we elide the details here to simplify the presentation.</p>
<p>Now that we know the mode pattern for <span class="math inline">\(check\)</span>, we can draw a scheduling graph
for the rule that defines <span class="math inline">\(auth\)</span> and deduce its predicate (again). This time we
do not give a detailed explanation. It’d be a good exercise to see why we
scheduled which predicate and what the mode pattern of <span class="math inline">\(auth\)</span> is.</p>
<pre><code>     {password}        {check}
V1 -------------&gt; V2 ----------&gt; V3</code></pre>
<p>We cheat here a bit and impose an order on building the graphs. In general, we
can’t find such an order because rules can refer to themselves recursively or be
mutually recursive with other rules. Proper way of handling that situation is
to assume <code>?</code> in place of <code>x</code> for modes of user-defined predicates initially,
and repeatedly apply this graph-based analysis to update the mode patterns until
they stabilise (fixpoint) for all user-defined predicates. You can refer to the
paper on why this works and why it terminates at all.</p>
<h4 id="example-8">Example 8</h4>
<p>So far it looks like all the scheduling graphs are just single paths. This is
not the case in general and we can use <a href="#example-2">Example 2</a> to demonstrate
it:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>We don’t have any logical predicates in this body. This can’t be a good start.
There is only one thing we do, that is to default to brute-force search for a
moment and try scheduling both subgoals.</p>
<pre><code>      {hash}          {rainbow}
  -------------&gt; V2 -------------&gt; V3
 /
V1
 \
  -------------&gt; V5 -------------&gt; V6
    {rainbow}           {hash}</code></pre>
<p>Finally, some more interesting <code>ASCII</code> art.</p>
<p>Let’s inspect the branch we try scheduling <code class="sourceCode prolog">hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)</code> first.
In this path, scheduling the subgoal with <span class="math inline">\(hash\)</span> predicate binds <code>Pass</code> and
<code>Hash</code>, as a result at the context of <span class="math inline">\(V2\)</span>, rainbow behaves like a logical
predicate (the dataflow constrained second parameter has <code>Pass</code> which is already
bound). Since we couldn’t schedule the <span class="math inline">\(hash\)</span> subgoal for free, it seems we need
to constraint the first parameter (<code>Pass</code>) of <span class="math inline">\(weak\)</span> leading <code>+?</code> mode pattern.</p>
<p>But wait a second! if we inspect the other branch instead, we commit to
requiring <code>Hash</code> to be bound in the head of the rule (and consequently dealt
with by the caller) instead. This suggests a mode pattern <code>?+</code>.</p>
<p>So which is it? In a way, it is both. Depending on the ordering of the rules
we have different dataflow requirements. This is good! Now we can just select a
representative ordering for each mode pattern. When the rule is used
differently, we use the appropriate ordering. So the overall mode pattern of
<span class="math inline">\(weak\)</span> is <code>+?/?+</code> to signify either of them can be used.</p>
<p>One reason we ended with two alternatives is that the mode patterns we obtained
are incomparable. If we had options <code>+?</code> and <code>++</code>, instead we could have
discarded <code>++</code> because <code>+?</code> is a more favourable alternative. This allows us to
store fewer orderings. We say more about that in the paper.</p>
<h3 id="multiple-rules">Multiple rules</h3>
<p>So far we have been assuming that a predicate is defined by a single rule. Now
we look at those defined by multiple rules. Let’s extend <a href="#example-8">Example 8</a>
to have a custom extralogical predicate that checks weakness of a password &amp;
hash pair and requires both of its parameters to be bound to execute safely.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>weak_xx(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> custom_weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>We already know the first rule leads to the mode pattern <code>+?/?+</code>. The second
rule is so simple that we can tell the mode pattern it leads without drawing the
relevant scheduling graph, namely <code>++</code> inherited from its single defining
subgoal.</p>
<p>Now what does it mean to invoke a predicate in Datalog? It means we are going to
try each of its defining rules to collect all possible conclusions. This implies
any invocation of <span class="math inline">\(weak\)</span> is going to evaluate both rules. Therefore, the only
thing we can do to ensure safety is to satisfy the dataflow requirements of each
rule simultaneously. What this means in our example is that we generate all
possible combinations that is <code>++</code> &amp; <code>+?</code> and <code>++</code> &amp; <code>?+</code>. In each case, <code>++</code> is
stricter for every parameter, so it shadows the other. Hence, we end up with
<code>++/++</code>, but since both alternatives are identical, the overall mode pattern for
<span class="math inline">\(weak\)</span> is <code>++</code>. Here this sounds <em>ad hoc</em>, but there is an <em>algebraic</em> method to
this madness<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. The details of which are in the paper.</p>
<h3 id="generalised-adornment">Generalised adornment</h3>
<p>Now we know how to determine dataflow requirements of user-defined predicates as
well as orderings of subgoals that lead to these requirements. However, this
does not help very much with our definition of <a href="#relating-adornments-to-modes-aka.-invocation-safety">invocation
safety</a>. The reason is
that definition rely on adorning a program in the given order of subgoals. This
is already in the result of <a href="#example-4">Example 4</a> with two different versions
of the <span class="math inline">\(weak\)</span> rule with different adornments but static ordering of subgoals.</p>
<p>So the final step in our quest to invocation safety is to generalise adornment
procedure such that it can take reorderings into the account.</p>
<p>We modify the adornment procedure in a single way. We let the procedure take a
reordering function that given a rule and a binding pattern produces an
ordering. Of course, we compute these orderings through scheduling graphs as
above. Then, right before we start adorning the body of a rule, we apply the
reordering first, then adorn from left to right as usual.</p>
<h4 id="example-9">Example 9</h4>
<p>Consider the following example adapted from <a href="#example-4">Example 4</a>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> weak_+?/?+(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)<span class="kw">.</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>weak_+?/?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>So the head of <span class="math inline">\(weak\)</span> rule will have the adornment <code>fb</code> due to the query. We
almost computed the ordering function for <span class="math inline">\(weak\)</span> in <a href="#example-8">Example 8</a>. For
<code>?+</code> mode pattern alternative which is the only alternative compatible with <code>fb</code>
binding pattern, we have an ordering in which the subgoal with <span class="math inline">\(rainbow\)</span> comes
first and the subgoal with <span class="math inline">\(hash\)</span> comes second. So we reorder the body first and
then perform the adornment and that leads to the following adorned program:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> rainbow_?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> hash_+?<span class="dt">_bb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>And voilà, we have a <span class="math inline">\(rainbow\)</span> subgoal with an adornment for its second
parameter <code>b</code> and <span class="math inline">\(hash\)</span> subgoal with an adornment for its first parameter <code>b</code>
as required. As all extralogical predicates are used in subgoals with adornments
that match their modes, the program is safe to execute.</p>
<h3 id="checking-invocation-safety">Checking invocation safety</h3>
<p>Once we compute modes for all-user defined predicates including the query, we
don’t have to adorn the program to see if the program is well-moded. We only
need to look at the query.</p>
<h4 id="example-10">Example 10</h4>
<p>In <a href="#example-9">Example 9</a> the query was <code class="sourceCode prolog"><span class="fu">?-</span> weak_+?/?+<span class="dt">_fb</span>(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)</code>, here the fact that <code>fb</code> is consistent
with one of the mode pattern alternatives, namely <code>?+</code> immediately indicates
that we have a ordering function that satisfy all dataflow requirements.</p>
<p>If, on the other, hand we pose the same query to the version of weak used in
explaining <a href="#multiple-rules">modes of predicates with multiple rules</a>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">?-</span> weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="ot">&quot;</span><span class="er">deadbeaf</span><span class="ot">&quot;</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> hash_+?(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">,</span> rainbow_?+(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>) <span class="kw">:-</span> custom_weak_++(<span class="dt">Pass</span><span class="kw">,</span><span class="dt">Hash</span>)<span class="kw">.</span></span></code></pre></div>
<p>Just by looking at the query, we know the program is not well-moded with respect
to this query because the predicate <span class="math inline">\(weak\)</span> in this case requires both of its
parameters to be bound but the first argument to the query is the free variable
<code>Pass</code>.</p>
<h3 id="some-properties">Some properties</h3>
<p>This algorithm enjoys a number of properties. I am neither going to get into
their proofs nor the mathematical details, but it would be amiss to omit them
entirely:</p>
<ol type="1">
<li>Soundness: if the algorithm finds a reordering function for a program, the
the reordered rules will be safe to invoke.</li>
<li>Completeness: if there are any orderings of rules that ensure invocation
safety, then the algorithm will find a (possibly different) set of orderings
that ensure invocation safety.</li>
<li>Incremental computation: addition of new rules don’t invalidate the old
results, hence the mode patterns of existing user-defined predicates can be
used to seed the analysis leading to faster execution.</li>
<li>Termination: the analysis terminates on all inputs.</li>
</ol>
<p>In particular, incremental computation is useful for making this analysis
scalable. In the special case that the added rule does not extend an existing
predicate, <em>i.e.</em>, have a fresh head, we don’t have to reanalyse old rules.
This means we can analyse libraries and ship the mode patterns of predicates
defined in the library with them. The users of the library won’t have to
reanalyse the code in the library.</p>
<h2 id="summary-concluding-thoughts">Summary &amp; concluding thoughts</h2>
<p>The main take away is declarative programming is awesome! In the case of
Datalog, we can supplement expressivity by allowing extralogical predicates.
This brings the syntactic order of execution problem with it, but our analysis
completely eliminates this and restores the promise of declarative programming!</p>
<p>The analysis relies on computing dataflow requirements (modes) of user-defined
predicates and verifying their consistency with respect to the actual bindings
(adornments) of the program &amp; query pairs.</p>
<p>We avoid inefficiency through a greedy scheduling algorithm, but we don’t
sacrifice completeness. Additionally, our analysis is incremental and thus
scalable to multi module programs with relative ease.</p>
<p>Here are few reasons why you might like to read the paper:</p>
<ul>
<li>understanding the mathematical foundation for modes &amp; bindings,</li>
<li>gaining insights into about an implementation (paper is effectively
executable maths),</li>
<li>need more advanced examples (illustrating omitted aspects of the algorithm),</li>
<li>looking for generalisation from Datalog to other contexts,</li>
<li>and seeing how this algorithm behaves with common Datalog examples such as
negation, aggregation, and effectful extralogical predicates.</li>
</ul>
<p>There is a number of directions this work may go. I believe the constraint-based
approach of the work can be generalised to other declarative languages which
need more sophisticated modes. I firmly believe there is a fundamental link
between the mode operations we defined and dataflow in general. We didn’t
discuss user-level annotations as you noticed. There are interesting design
questions about an annotation language for modes that might work exploring.
Finally (and a bit more abstractly), extralogical predicates are inevitable in
logic programming but they are afterthoughts to the semantics of the language.
I’d like them to be first-class citizens, so we can reason about them better.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><code>Pass</code> in this rule is an existentially quantified variable, so
there is indeed nothing that could have bound it out of the rule context.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It is <code>bb</code> because both <code>User</code> and <code>Pass</code> appear in preceding
subgoals.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This seems to contradict what I said in <a href="#example-3">Example 3</a>, so let
me clarify. In a subgoal like <code class="sourceCode prolog">not r(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span><span class="kw">,</span><span class="dt">Z</span>)</code>, the predicate <span class="math inline">\(r\)</span> still
has <code>???</code> mode pattern. It is the negation that imposes makes <code>r</code> behave as if
it has <code>+++</code> pattern.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is a quote from a famous movie speech by the character <a href="https://en.wikipedia.org/wiki/Gordon_Gekko">Gordon
Gekko</a> in <a href="https://www.rottentomatoes.com/m/wall_street">Wall
Street</a>. Highly
recommended.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>In the paper, we show and heavily use the fact that
constraints (which are derived from modes) form a bounded partial order. We can
talk about <em>principal moding</em> or <em>sub moding</em>, but they are only relevant if we
have explicit annotations for modes which are not strictly necessary for safety
checking and automated reordering. Perhaps another paper? Feel free to contact
me if you want to discuss this more.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>This is the second time we are combining mode patterns and there is a form of
subsumption going on. When we consider two alternative dataflow requirements and
their combination leads to a more relaxed mode pattern. When we combine two mode
patterns that need to be satisfied simultaneously, the combination is more
strict. You must have noticed that these two operations sound very algebraic.
Indeed, to our surprise, they form <a href="https://www.cl.cam.ac.uk/teaching/0910/L11/L11_04_08.pdf">Martelli’s
semiring</a> (sorry,
there aren’t any non-academic resources I could find) originally used to compute
cut-sets of a graph. To the best of my knowledge this hasn’t been used in
dataflow context before and seems general enough to be used beyond Datalog and
extralogical predicates.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div>

<script>
var figures =
  Array.prototype.slice.call(document.getElementsByClassName("figure"),0)
  .concat(
    Array.prototype.slice.call(document.getElementsByTagName("figure"),0));

for (var i = 0; i < figures.length; i++) {
  var figure = figures[i];
  var imgs = figure.getElementsByTagName("img");
  if (imgs.length > 0) {
    classes = imgs[0].classList;
    for (var j = 0; j < classes.length; j++) {
      figure.classList.add(classes[j] + "-figure");
    }
  }
}
</script>

        </div>
        <div id="footer">
          <div class="top-container">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </div>
    </body>
</html>
